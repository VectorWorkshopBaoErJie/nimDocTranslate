<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim手册</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<!-- JS -->
<script type="text/javascript" src="dochack.js"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim手册</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">🌗 Match OS</option>
        <option value="dark">🌑 Dark</option>
        <option value="light">🌕 Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" onkeyup="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="关于手册_toc" href="#关于手册">关于手册</a></li>
<li><a class="reference" id="定义_toc" href="#定义">定义</a></li>
<li><a class="reference" id="词法分析_toc" href="#词法分析">词法分析</a></li>
<ul class="simple"><li><a class="reference" id="词法分析-编码_toc" href="#词法分析-编码">编码</a></li>
<li><a class="reference" id="词法分析-缩进_toc" href="#词法分析-缩进">缩进</a></li>
<li><a class="reference" id="词法分析-注释_toc" href="#词法分析-注释">注释</a></li>
<li><a class="reference" id="词法分析-多行注释_toc" href="#词法分析-多行注释">多行注释</a></li>
<li><a class="reference" id="词法分析-标识符和关键字_toc" href="#词法分析-标识符和关键字">标识符和关键字</a></li>
<li><a class="reference" id="词法分析-标识符相等_toc" href="#词法分析-标识符相等">标识符相等</a></li>
<li><a class="reference" id="词法分析-作为标识符的关键词_toc" href="#词法分析-作为标识符的关键词">作为标识符的关键词</a></li>
<li><a class="reference" id="词法分析-字符串字面值_toc" href="#词法分析-字符串字面值">字符串字面值</a></li>
<li><a class="reference" id="词法分析-三重引用字符串字面值_toc" href="#词法分析-三重引用字符串字面值">三重引用字符串字面值</a></li>
<li><a class="reference" id="词法分析-原始字符串字面值_toc" href="#词法分析-原始字符串字面值">原始字符串字面值</a></li>
<li><a class="reference" id="词法分析-广义的原始字符串字面值_toc" href="#词法分析-广义的原始字符串字面值">广义的原始字符串字面值</a></li>
<li><a class="reference" id="词法分析-字符字面值_toc" href="#词法分析-字符字面值">字符字面值</a></li>
<li><a class="reference" id="词法分析-数值字面值_toc" href="#词法分析-数值字面值">数值字面值</a></li>
<ul class="simple"><li><a class="reference" id="数值字面值-自定义数值字面值_toc" href="#数值字面值-自定义数值字面值">自定义数值字面值</a></li>
</ul><li><a class="reference" id="词法分析-运算符_toc" href="#词法分析-运算符">运算符</a></li>
<li><a class="reference" id="词法分析-其他标记_toc" href="#词法分析-其他标记">其他标记</a></li>
</ul><li><a class="reference" id="句法_toc" href="#句法">句法</a></li>
<ul class="simple"><li><a class="reference" id="句法-结合律_toc" href="#句法-结合律">结合律</a></li>
<li><a class="reference" id="句法-优先级_toc" href="#句法-优先级">优先级</a></li>
<li><a class="reference" id="句法-点类运算符_toc" href="#句法-点类运算符">点类运算符</a></li>
<li><a class="reference" id="句法-语法_toc" href="#句法-语法">语法</a></li>
</ul><li><a class="reference" id="求值顺序_toc" href="#求值顺序">求值顺序</a></li>
<li><a class="reference" id="常量和常量表达式_toc" href="#常量和常量表达式">常量和常量表达式</a></li>
<li><a class="reference" id="对编译期执行的限制_toc" href="#对编译期执行的限制">对编译期执行的限制</a></li>
<li><a class="reference" id="类型_toc" href="#类型">类型</a></li>
<ul class="simple"><li><a class="reference" id="类型-序数类型_toc" href="#类型-序数类型">序数类型</a></li>
<li><a class="reference" id="类型-预定义整数类型_toc" href="#类型-预定义整数类型">预定义整数类型</a></li>
<li><a class="reference" id="类型-子范围类型_toc" href="#类型-子范围类型">子范围类型</a></li>
<li><a class="reference" id="类型-预定义浮点类型_toc" href="#类型-预定义浮点类型">预定义浮点类型</a></li>
<li><a class="reference" id="类型-布尔类型_toc" href="#类型-布尔类型">布尔类型</a></li>
<li><a class="reference" id="类型-字符类型_toc" href="#类型-字符类型">字符类型</a></li>
<li><a class="reference" id="类型-枚举类型_toc" href="#类型-枚举类型">枚举类型</a></li>
<li><a class="reference" id="类型-字符串类型_toc" href="#类型-字符串类型">字符串类型</a></li>
<li><a class="reference" id="类型-cstring类型_toc" href="#类型-cstring类型">cstring类型</a></li>
<li><a class="reference" id="类型-结构化类型_toc" href="#类型-结构化类型">结构化类型</a></li>
<li><a class="reference" id="类型-数组和序列类型_toc" href="#类型-数组和序列类型">数组和序列类型</a></li>
<li><a class="reference" id="类型-开放数组_toc" href="#类型-开放数组">开放数组</a></li>
<li><a class="reference" id="类型-可变参数_toc" href="#类型-可变参数">可变参数</a></li>
<li><a class="reference" id="类型-未检查数组_toc" href="#类型-未检查数组">未检查数组</a></li>
<li><a class="reference" id="类型-元组和对象类型_toc" href="#类型-元组和对象类型">元组和对象类型</a></li>
<li><a class="reference" id="类型-对象构造_toc" href="#类型-对象构造">对象构造</a></li>
<li><a class="reference" id="类型-对象变体_toc" href="#类型-对象变体">对象变体</a></li>
<li><a class="reference" id="类型-cast-uncheckedassign_toc" href="#类型-cast-uncheckedassign">cast uncheckedAssign</a></li>
<li><a class="reference" id="类型-集合类型_toc" href="#类型-集合类型">集合类型</a></li>
<ul class="simple"><li><a class="reference" id="集合类型-位域_toc" href="#集合类型-位域">位域</a></li>
</ul><li><a class="reference" id="类型-引用和指针类型_toc" href="#类型-引用和指针类型">引用和指针类型</a></li>
<li><a class="reference" id="类型-空-nil_toc" href="#类型-空-nil">空(Nil)</a></li>
<li><a class="reference" id="类型-混合gc内存和-nimptr_toc" href="#类型-混合gc内存和-nimptr">混合GC内存和 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt></a></li>
<li><a class="reference" id="类型-过程类型_toc" href="#类型-过程类型">过程类型</a></li>
<li><a class="reference" id="类型-distinct类型_toc" href="#类型-distinct类型">Distinct类型</a></li>
<ul class="simple"><li><a class="reference" id="distinct类型-模拟货币_toc" href="#distinct类型-模拟货币">模拟货币</a></li>
<li><a class="reference" id="distinct类型-避免sql注入攻击_toc" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></li>
</ul><li><a class="reference" id="类型-auto类型_toc" href="#类型-auto类型">Auto类型</a></li>
</ul><li><a class="reference" id="类型关系_toc" href="#类型关系">类型关系</a></li>
<ul class="simple"><li><a class="reference" id="类型关系-类型相等性_toc" href="#类型关系-类型相等性">类型相等性</a></li>
<li><a class="reference" id="类型关系-subtype关系_toc" href="#类型关系-subtype关系">Subtype关系</a></li>
<li><a class="reference" id="类型关系-交换关系_toc" href="#类型关系-交换关系">交换关系</a></li>
<li><a class="reference" id="类型关系-赋值兼容_toc" href="#类型关系-赋值兼容">赋值兼容</a></li>
</ul><li><a class="reference" id="重载解决方案_toc" href="#重载解决方案">重载解决方案</a></li>
<ul class="simple"><li><a class="reference" id="重载解决方案-基于-var-t-的重载_toc" href="#重载解决方案-基于-var-t-的重载">基于 'var T' 的重载</a></li>
<li><a class="reference" id="重载解决方案-untyped惰性类型解析_toc" href="#重载解决方案-untyped惰性类型解析">untyped惰性类型解析</a></li>
<li><a class="reference" id="重载解决方案-可变参数匹配_toc" href="#重载解决方案-可变参数匹配">可变参数匹配</a></li>
<li><a class="reference" id="重载解决方案-迭代器_toc" href="#重载解决方案-迭代器">迭代器</a></li>
</ul><li><a class="reference" id="重载歧义消除_toc" href="#重载歧义消除">重载歧义消除</a></li>
<ul class="simple"><li><a class="reference" id="重载歧义消除-命名参数重载_toc" href="#重载歧义消除-命名参数重载">命名参数重载</a></li>
</ul><li><a class="reference" id="语句和表达式_toc" href="#语句和表达式">语句和表达式</a></li>
<ul class="simple"><li><a class="reference" id="语句和表达式-语句列表表达式_toc" href="#语句和表达式-语句列表表达式">语句列表表达式</a></li>
<li><a class="reference" id="语句和表达式-discard语句_toc" href="#语句和表达式-discard语句">Discard语句</a></li>
<li><a class="reference" id="语句和表达式-void下上文_toc" href="#语句和表达式-void下上文">Void下上文</a></li>
<li><a class="reference" id="语句和表达式-var语句_toc" href="#语句和表达式-var语句">Var语句</a></li>
<li><a class="reference" id="语句和表达式-let语句_toc" href="#语句和表达式-let语句">Let语句</a></li>
<li><a class="reference" id="语句和表达式-元组解包_toc" href="#语句和表达式-元组解包">元组解包</a></li>
<li><a class="reference" id="语句和表达式-常量域_toc" href="#语句和表达式-常量域">常量域</a></li>
<li><a class="reference" id="语句和表达式-静态语句slash表达式_toc" href="#语句和表达式-静态语句slash表达式">静态语句/表达式</a></li>
<li><a class="reference" id="语句和表达式-if语句_toc" href="#语句和表达式-if语句">If语句</a></li>
<li><a class="reference" id="语句和表达式-case-语句_toc" href="#语句和表达式-case-语句">Case 语句</a></li>
<li><a class="reference" id="语句和表达式-when-语句_toc" href="#语句和表达式-when-语句">When 语句</a></li>
<li><a class="reference" id="语句和表达式-when-nimvm-语句_toc" href="#语句和表达式-when-nimvm-语句">When nimvm 语句</a></li>
<li><a class="reference" id="语句和表达式-return-语句_toc" href="#语句和表达式-return-语句">Return 语句</a></li>
<li><a class="reference" id="语句和表达式-yield-语句_toc" href="#语句和表达式-yield-语句">Yield 语句</a></li>
<li><a class="reference" id="语句和表达式-block-语句_toc" href="#语句和表达式-block-语句">Block 语句</a></li>
<li><a class="reference" id="语句和表达式-break-语句_toc" href="#语句和表达式-break-语句">Break 语句</a></li>
<li><a class="reference" id="语句和表达式-while-语句_toc" href="#语句和表达式-while-语句">While 语句</a></li>
<li><a class="reference" id="语句和表达式-continue-语句_toc" href="#语句和表达式-continue-语句">Continue 语句</a></li>
<li><a class="reference" id="语句和表达式-汇编语句_toc" href="#语句和表达式-汇编语句">汇编语句</a></li>
<li><a class="reference" id="语句和表达式-using语句_toc" href="#语句和表达式-using语句">Using语句</a></li>
<li><a class="reference" id="语句和表达式-if-表达式_toc" href="#语句和表达式-if-表达式">If 表达式</a></li>
<li><a class="reference" id="语句和表达式-when表达式_toc" href="#语句和表达式-when表达式">When表达式</a></li>
<li><a class="reference" id="语句和表达式-case表达式_toc" href="#语句和表达式-case表达式">Case表达式</a></li>
<li><a class="reference" id="语句和表达式-block表达式_toc" href="#语句和表达式-block表达式">Block表达式</a></li>
<li><a class="reference" id="语句和表达式-表构造器_toc" href="#语句和表达式-表构造器">表构造器</a></li>
<li><a class="reference" id="语句和表达式-类型转换_toc" href="#语句和表达式-类型转换">类型转换</a></li>
<li><a class="reference" id="语句和表达式-类型强转_toc" href="#语句和表达式-类型强转">类型强转</a></li>
<li><a class="reference" id="语句和表达式-addr操作符_toc" href="#语句和表达式-addr操作符">addr操作符</a></li>
<li><a class="reference" id="语句和表达式-unsafeaddr操作符_toc" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></li>
</ul><li><a class="reference" id="过程_toc" href="#过程">过程</a></li>
<ul class="simple"><li><a class="reference" id="过程-导出标记_toc" href="#过程-导出标记">导出标记</a></li>
<li><a class="reference" id="过程-方法调用语法_toc" href="#过程-方法调用语法">方法调用语法</a></li>
<li><a class="reference" id="过程-属性_toc" href="#过程-属性">属性</a></li>
<li><a class="reference" id="过程-命令调用语法_toc" href="#过程-命令调用语法">命令调用语法</a></li>
<li><a class="reference" id="过程-闭包_toc" href="#过程-闭包">闭包</a></li>
<ul class="simple"><li><a class="reference" id="闭包-在循环中创建闭包_toc" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></li>
</ul><li><a class="reference" id="过程-匿名过程_toc" href="#过程-匿名过程">匿名过程</a></li>
<li><a class="reference" id="过程-do-标记_toc" href="#过程-do-标记">Do 标记</a></li>
<li><a class="reference" id="过程-函数_toc" href="#过程-函数">函数</a></li>
<li><a class="reference" id="过程-例程_toc" href="#过程-例程">例程</a></li>
<li><a class="reference" id="过程-类型绑定操作符_toc" href="#过程-类型绑定操作符">类型绑定操作符</a></li>
<li><a class="reference" id="过程-nonoverloadable-内置命令_toc" href="#过程-nonoverloadable-内置命令">Nonoverloadable 内置命令</a></li>
<li><a class="reference" id="过程-var-参数_toc" href="#过程-var-参数">Var 参数</a></li>
<li><a class="reference" id="过程-var-返回类型_toc" href="#过程-var-返回类型">Var 返回类型</a></li>
<ul class="simple"><li><a class="reference" id="var-返回类型-未来的方向_toc" href="#var-返回类型-未来的方向">未来的方向</a></li>
</ul><li><a class="reference" id="过程-具名返回值优化-nrvo_toc" href="#过程-具名返回值优化-nrvo">具名返回值优化 (NRVO)</a></li>
<li><a class="reference" id="过程-重载下标运算符_toc" href="#过程-重载下标运算符">重载下标运算符</a></li>
</ul><li><a class="reference" id="方法_toc" href="#方法">方法</a></li>
<ul class="simple"><li><a class="reference" id="方法-多重方法-multiminusmethods_toc" href="#方法-多重方法-multiminusmethods">多重方法 (Multi-methods)</a></li>
<li><a class="reference" id="方法-通过-procall-防止动态方法解析_toc" href="#方法-通过-procall-防止动态方法解析">通过 proCall 防止动态方法解析</a></li>
</ul><li><a class="reference" id="迭代器与-for-循环语句_toc" href="#迭代器与-for-循环语句">迭代器与 for 循环语句</a></li>
<ul class="simple"><li><a class="reference" id="迭代器与-for-循环语句-隐式-itemsslashpairs-调用_toc" href="#迭代器与-for-循环语句-隐式-itemsslashpairs-调用">隐式 items/pairs 调用</a></li>
<li><a class="reference" id="迭代器与-for-循环语句-一等迭代器_toc" href="#迭代器与-for-循环语句-一等迭代器">一等迭代器</a></li>
</ul><li><a class="reference" id="转换器_toc" href="#转换器">转换器</a></li>
<li><a class="reference" id="type-段_toc" href="#type-段">Type 段</a></li>
<li><a class="reference" id="异常处理_toc" href="#异常处理">异常处理</a></li>
<ul class="simple"><li><a class="reference" id="异常处理-try-语句_toc" href="#异常处理-try-语句">Try 语句</a></li>
<li><a class="reference" id="异常处理-try-表达式_toc" href="#异常处理-try-表达式">Try 表达式</a></li>
<li><a class="reference" id="异常处理-except-子句_toc" href="#异常处理-except-子句">Except 子句</a></li>
<li><a class="reference" id="异常处理-自定义异常_toc" href="#异常处理-自定义异常">自定义异常</a></li>
<li><a class="reference" id="异常处理-defer-语句_toc" href="#异常处理-defer-语句">Defer 语句</a></li>
<li><a class="reference" id="异常处理-raise-语句_toc" href="#异常处理-raise-语句">Raise 语句</a></li>
<li><a class="reference" id="异常处理-异常的层级_toc" href="#异常处理-异常的层级">异常的层级</a></li>
<li><a class="reference" id="异常处理-导入的异常_toc" href="#异常处理-导入的异常">导入的异常</a></li>
</ul><li><a class="reference" id="effect-系统_toc" href="#effect-系统">Effect 系统</a></li>
<ul class="simple"><li><a class="reference" id="effect-系统-异常追踪_toc" href="#effect-系统-异常追踪">异常追踪</a></li>
<li><a class="reference" id="effect-系统-effectsof-编译指示_toc" href="#effect-系统-effectsof-编译指示">EffectsOf 编译指示</a></li>
<li><a class="reference" id="effect-系统-标签追踪_toc" href="#effect-系统-标签追踪">标签追踪</a></li>
<li><a class="reference" id="effect-系统-副作用_toc" href="#effect-系统-副作用">副作用</a></li>
<li><a class="reference" id="effect-系统-gc-安全的作用_toc" href="#effect-系统-gc-安全的作用">GC 安全的作用</a></li>
<li><a class="reference" id="effect-系统-effects-编译指示_toc" href="#effect-系统-effects-编译指示">Effects 编译指示</a></li>
</ul><li><a class="reference" id="泛型_toc" href="#泛型">泛型</a></li>
<ul class="simple"><li><a class="reference" id="泛型-is-运算符_toc" href="#泛型-is-运算符">Is 运算符</a></li>
<li><a class="reference" id="泛型-类型类_toc" href="#泛型-类型类">类型类</a></li>
<li><a class="reference" id="泛型-隐式泛型_toc" href="#泛型-隐式泛型">隐式泛型</a></li>
<li><a class="reference" id="泛型-泛型推断的局限_toc" href="#泛型-泛型推断的局限">泛型推断的局限</a></li>
<li><a class="reference" id="泛型-泛型中的符号查找_toc" href="#泛型-泛型中的符号查找">泛型中的符号查找</a></li>
<ul class="simple"><li><a class="reference" id="泛型中的符号查找-开放和封闭符号_toc" href="#泛型中的符号查找-开放和封闭符号">开放和封闭符号</a></li>
</ul><li><a class="reference" id="泛型-mixin-语句_toc" href="#泛型-mixin-语句">Mixin 语句</a></li>
<li><a class="reference" id="泛型-bind-语句_toc" href="#泛型-bind-语句">Bind 语句</a></li>
<li><a class="reference" id="泛型-委托绑定语句_toc" href="#泛型-委托绑定语句">委托绑定语句</a></li>
</ul><li><a class="reference" id="模板_toc" href="#模板">模板</a></li>
<ul class="simple"><li><a class="reference" id="模板-typed-参数和-untyped-参数的比较_toc" href="#模板-typed-参数和-untyped-参数的比较">Typed 参数和 untyped 参数的比较</a></li>
<li><a class="reference" id="模板-传递代码块到模板_toc" href="#模板-传递代码块到模板">传递代码块到模板</a></li>
<li><a class="reference" id="模板-untyped-可变参数_toc" href="#模板-untyped-可变参数">untyped 可变参数</a></li>
<li><a class="reference" id="模板-模板中的符号绑定_toc" href="#模板-模板中的符号绑定">模板中的符号绑定</a></li>
<li><a class="reference" id="模板-标识符的构建_toc" href="#模板-标识符的构建">标识符的构建</a></li>
<li><a class="reference" id="模板-模板参数的查找规则_toc" href="#模板-模板参数的查找规则">模板参数的查找规则</a></li>
<li><a class="reference" id="模板-模板的卫生性_toc" href="#模板-模板的卫生性">模板的卫生性</a></li>
<li><a class="reference" id="模板-方法调用语法的局限_toc" href="#模板-方法调用语法的局限">方法调用语法的局限</a></li>
</ul><li><a class="reference" id="宏_toc" href="#宏">宏</a></li>
<ul class="simple"><li><a class="reference" id="宏-debug-示例_toc" href="#宏-debug-示例">debug 示例</a></li>
<li><a class="reference" id="宏-bindsym_toc" href="#宏-bindsym">bindSym</a></li>
<li><a class="reference" id="宏-语句后的代码块_toc" href="#宏-语句后的代码块">语句后的代码块</a></li>
<li><a class="reference" id="宏-for-循环宏_toc" href="#宏-for-循环宏">For 循环宏</a></li>
<li><a class="reference" id="宏-case-语句宏_toc" href="#宏-case-语句宏">Case 语句宏</a></li>
</ul><li><a class="reference" id="特殊类型_toc" href="#特殊类型">特殊类型</a></li>
<ul class="simple"><li><a class="reference" id="特殊类型-static-t_toc" href="#特殊类型-static-t">static[T]</a></li>
<li><a class="reference" id="特殊类型-typedesc-t_toc" href="#特殊类型-typedesc-t">typedesc[T]</a></li>
<li><a class="reference" id="特殊类型-typeof-运算符_toc" href="#特殊类型-typeof-运算符">typeof 运算符</a></li>
</ul><li><a class="reference" id="模块_toc" href="#模块">模块</a></li>
<ul class="simple"><li><a class="reference" id="模块-import-语句_toc" href="#模块-import-语句">Import 语句</a></li>
<li><a class="reference" id="模块-include-语句_toc" href="#模块-include-语句">Include 语句</a></li>
<li><a class="reference" id="模块-导入语句里的模块名_toc" href="#模块-导入语句里的模块名">导入语句里的模块名</a></li>
<li><a class="reference" id="模块-从目录里集体导入_toc" href="#模块-从目录里集体导入">从目录里集体导入</a></li>
<li><a class="reference" id="模块-用于-importslashinclude-的伪路径_toc" href="#模块-用于-importslashinclude-的伪路径">用于 import/include 的伪路径</a></li>
<li><a class="reference" id="模块-from-import-语句_toc" href="#模块-from-import-语句">From import 语句</a></li>
<li><a class="reference" id="模块-export-语句_toc" href="#模块-export-语句">Export 语句</a></li>
<li><a class="reference" id="模块-作用域规则_toc" href="#模块-作用域规则">作用域规则</a></li>
<ul class="simple"><li><a class="reference" id="作用域规则-块作用域_toc" href="#作用域规则-块作用域">块作用域</a></li>
<li><a class="reference" id="作用域规则-元组或对象作用域_toc" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></li>
<li><a class="reference" id="作用域规则-模块作用域_toc" href="#作用域规则-模块作用域">模块作用域</a></li>
</ul><li><a class="reference" id="模块-包_toc" href="#模块-包">包</a></li>
</ul><li><a class="reference" id="编译器消息_toc" href="#编译器消息">编译器消息</a></li>
<li><a class="reference" id="编译指示_toc" href="#编译指示">编译指示</a></li>
<ul class="simple"><li><a class="reference" id="编译指示-deprecated-编译指示_toc" href="#编译指示-deprecated-编译指示">deprecated 编译指示</a></li>
<li><a class="reference" id="编译指示-compiletime-编译指示_toc" href="#编译指示-compiletime-编译指示">compileTime 编译指示</a></li>
<li><a class="reference" id="编译指示-noreturn-编译指示_toc" href="#编译指示-noreturn-编译指示">noreturn 编译指示</a></li>
<li><a class="reference" id="编译指示-acyclic-编译指示_toc" href="#编译指示-acyclic-编译指示">acyclic 编译指示</a></li>
<li><a class="reference" id="编译指示-final-编译指示_toc" href="#编译指示-final-编译指示">final 编译指示</a></li>
<li><a class="reference" id="编译指示-shallow-编译指示_toc" href="#编译指示-shallow-编译指示">shallow 编译指示</a></li>
<li><a class="reference" id="编译指示-pure-编译指示_toc" href="#编译指示-pure-编译指示">pure 编译指示</a></li>
<li><a class="reference" id="编译指示-asmnostackframe-编译指示_toc" href="#编译指示-asmnostackframe-编译指示">asmNoStackFrame 编译指示</a></li>
<li><a class="reference" id="编译指示-error-编译指示_toc" href="#编译指示-error-编译指示">error 编译指示</a></li>
<li><a class="reference" id="编译指示-fatal-编译指示_toc" href="#编译指示-fatal-编译指示">fatal 编译指示</a></li>
<li><a class="reference" id="编译指示-warning-编译指示_toc" href="#编译指示-warning-编译指示">warning 编译指示</a></li>
<li><a class="reference" id="编译指示-hint-编译指示_toc" href="#编译指示-hint-编译指示">hint 编译指示</a></li>
<li><a class="reference" id="编译指示-line-编译指示_toc" href="#编译指示-line-编译指示">line 编译指示</a></li>
<li><a class="reference" id="编译指示-linearscanend-编译指示_toc" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></li>
<li><a class="reference" id="编译指示-computedgoto-编译指示_toc" href="#编译指示-computedgoto-编译指示">computedGoto 编译指示</a></li>
<li><a class="reference" id="编译指示-immediate-编译指示_toc" href="#编译指示-immediate-编译指示">immediate 编译指示</a></li>
<li><a class="reference" id="编译指示-redefine-编译指示_toc" href="#编译指示-redefine-编译指示">redefine 编译指示</a></li>
<li><a class="reference" id="编译指示-与编译选项相关的编译指示_toc" href="#编译指示-与编译选项相关的编译指示">与编译选项相关的编译指示</a></li>
<li><a class="reference" id="编译指示-push-和-pop-编译指示_toc" href="#编译指示-push-和-pop-编译指示">push 和 pop 编译指示</a></li>
<li><a class="reference" id="编译指示-register-编译指示_toc" href="#编译指示-register-编译指示">register 编译指示</a></li>
<li><a class="reference" id="编译指示-global-编译提示_toc" href="#编译指示-global-编译提示">global 编译提示</a></li>
<li><a class="reference" id="编译指示-禁用某些信息_toc" href="#编译指示-禁用某些信息">禁用某些信息</a></li>
<li><a class="reference" id="编译指示-used-编译提示_toc" href="#编译指示-used-编译提示">used 编译提示</a></li>
<li><a class="reference" id="编译指示-expermimental-编译指示_toc" href="#编译指示-expermimental-编译指示">expermimental 编译指示</a></li>
</ul><li><a class="reference" id="与实现紧密相关的编译指示_toc" href="#与实现紧密相关的编译指示">与实现紧密相关的编译指示</a></li>
<ul class="simple"><li><a class="reference" id="与实现紧密相关的编译指示-bitsize-编译指示_toc" href="#与实现紧密相关的编译指示-bitsize-编译指示">Bitsize 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-align-编译指示_toc" href="#与实现紧密相关的编译指示-align-编译指示">Align 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-noalias-编译指示_toc" href="#与实现紧密相关的编译指示-noalias-编译指示">Noalias 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-volatile-编译指示_toc" href="#与实现紧密相关的编译指示-volatile-编译指示">Volatile 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-nodecl-编译指示_toc" href="#与实现紧密相关的编译指示-nodecl-编译指示">nodecl 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-header-编译指示_toc" href="#与实现紧密相关的编译指示-header-编译指示">Header 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-incompletestruct-编译指示_toc" href="#与实现紧密相关的编译指示-incompletestruct-编译指示">IncompleteStruct 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-compile-编译指示_toc" href="#与实现紧密相关的编译指示-compile-编译指示">Compile 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-link-编译指示_toc" href="#与实现紧密相关的编译指示-link-编译指示">Link 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-passc-编译指示_toc" href="#与实现紧密相关的编译指示-passc-编译指示">passc 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-localpassc-编译指示_toc" href="#与实现紧密相关的编译指示-localpassc-编译指示">localPassC 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-passl-编译指示_toc" href="#与实现紧密相关的编译指示-passl-编译指示">passl 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-emit-编译指示_toc" href="#与实现紧密相关的编译指示-emit-编译指示">Emit 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-importcpp-编译指示_toc" href="#与实现紧密相关的编译指示-importcpp-编译指示">ImportCpp 编译指示</a></li>
<ul class="simple"><li><a class="reference" id="importcpp-编译指示-命名空间_toc" href="#importcpp-编译指示-命名空间">命名空间</a></li>
<li><a class="reference" id="importcpp-编译指示-importcpp-应用于枚举_toc" href="#importcpp-编译指示-importcpp-应用于枚举">Importcpp 应用于枚举</a></li>
<li><a class="reference" id="importcpp-编译指示-importcpp-应用于过程_toc" href="#importcpp-编译指示-importcpp-应用于过程">Importcpp 应用于过程</a></li>
<li><a class="reference" id="importcpp-编译指示-包装构造函数_toc" href="#importcpp-编译指示-包装构造函数">包装构造函数</a></li>
<li><a class="reference" id="importcpp-编译指示-包装析构函数_toc" href="#importcpp-编译指示-包装析构函数">包装析构函数</a></li>
<li><a class="reference" id="importcpp-编译指示-importcpp-应用于对象_toc" href="#importcpp-编译指示-importcpp-应用于对象">Importcpp 应用于对象</a></li>
</ul><li><a class="reference" id="与实现紧密相关的编译指示-importjs-编译指示_toc" href="#与实现紧密相关的编译指示-importjs-编译指示">ImportJs 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-importobjc-编译指示_toc" href="#与实现紧密相关的编译指示-importobjc-编译指示">ImportObjC 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-codegendecl-编译指示_toc" href="#与实现紧密相关的编译指示-codegendecl-编译指示">CodegenDecl 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-nimcppnonpod-编译指示_toc" href="#与实现紧密相关的编译指示-nimcppnonpod-编译指示"><tt class="docutils literal"><span class="pre"><span class="Identifier">cppNonPod</span></span></tt> 编译指示</a></li>
<li><a class="reference" id="与实现紧密相关的编译指示-编译期的-define-编译指示_toc" href="#与实现紧密相关的编译指示-编译期的-define-编译指示">编译期的 define 编译指示</a></li>
</ul><li><a class="reference" id="用户定义的编译指示_toc" href="#用户定义的编译指示">用户定义的编译指示</a></li>
<ul class="simple"><li><a class="reference" id="用户定义的编译指示-pragma-编译指示_toc" href="#用户定义的编译指示-pragma-编译指示">pragma 编译指示</a></li>
<li><a class="reference" id="用户定义的编译指示-定制注解_toc" href="#用户定义的编译指示-定制注解">定制注解</a></li>
<li><a class="reference" id="用户定义的编译指示-宏编译指示_toc" href="#用户定义的编译指示-宏编译指示">宏编译指示</a></li>
</ul><li><a class="reference" id="外部函数接口_toc" href="#外部函数接口">外部函数接口</a></li>
<ul class="simple"><li><a class="reference" id="外部函数接口-importc-编译指示_toc" href="#外部函数接口-importc-编译指示">Importc 编译指示</a></li>
<li><a class="reference" id="外部函数接口-exportc-编译指示_toc" href="#外部函数接口-exportc-编译指示">Exportc 编译指示</a></li>
<li><a class="reference" id="外部函数接口-extern-编译指示_toc" href="#外部函数接口-extern-编译指示">Extern 编译指示</a></li>
<li><a class="reference" id="外部函数接口-bycopy-编译指示_toc" href="#外部函数接口-bycopy-编译指示">Bycopy 编译指示</a></li>
<li><a class="reference" id="外部函数接口-byref-编译指示_toc" href="#外部函数接口-byref-编译指示">Byref 编译指示</a></li>
<li><a class="reference" id="外部函数接口-varargs-编译指示_toc" href="#外部函数接口-varargs-编译指示">Varargs 编译指示</a></li>
<li><a class="reference" id="外部函数接口-union-编译指示_toc" href="#外部函数接口-union-编译指示">Union 编译指示</a></li>
<li><a class="reference" id="外部函数接口-packed-编译指示_toc" href="#外部函数接口-packed-编译指示">Packed 编译指示</a></li>
<li><a class="reference" id="外部函数接口-用于导入的-dynlib-编译指示_toc" href="#外部函数接口-用于导入的-dynlib-编译指示">用于导入的 dynlib 编译指示</a></li>
<li><a class="reference" id="外部函数接口-dynlib-编译指示应用于导出_toc" href="#外部函数接口-dynlib-编译指示应用于导出">Dynlib 编译指示应用于导出</a></li>
</ul><li><a class="reference" id="线程_toc" href="#线程">线程</a></li>
<ul class="simple"><li><a class="reference" id="线程-thread-编译指示_toc" href="#线程-thread-编译指示">Thread 编译指示</a></li>
<li><a class="reference" id="线程-threadvar-编译指示_toc" href="#线程-threadvar-编译指示">Threadvar 编译指示</a></li>
<li><a class="reference" id="线程-线程和异常_toc" href="#线程-线程和异常">线程和异常</a></li>
</ul><li><a class="reference" id="守卫和锁_toc" href="#守卫和锁">守卫和锁</a></li>
<ul class="simple"><li><a class="reference" id="守卫和锁-守卫和锁块_toc" href="#守卫和锁-守卫和锁块">守卫和锁块</a></li>
<ul class="simple"><li><a class="reference" id="守卫和锁块-受保护的全局变量_toc" href="#守卫和锁块-受保护的全局变量">受保护的全局变量</a></li>
<li><a class="reference" id="守卫和锁块-保护常规地址_toc" href="#守卫和锁块-保护常规地址">保护常规地址</a></li>
</ul></ul>
</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">作者:</th><td>Andreas Rumpf, Zahary Karadjov</td></tr>
<tr><th class="docinfo-name">版本:</th><td>1.6.8以上</td></tr>
</tbody></table><blockquote class="markdown-quote"><p>&quot;复杂性&quot; 如同 &quot;能量&quot;: 终端用户把它转嫁给其他参与者，但给定任务的总量似乎没变。 -- Ran</p></blockquote>

<h1><a class="toc-backref" id="关于手册" href="#关于手册">关于手册</a></h1><p><strong>注意</strong>: 当前手册还是草案! Nim的一些功能需要更加准确的描述。手册内容也在不断更新，使其逐渐成为规范。</p>
<p><strong>注意</strong>: Nim的实现性功能在<a class="reference external" href="manual_experimental.html">这里</a>。</p>
<p><strong>注意</strong>: 赋值、移动和析构在特定的<a class="reference external" href="destructors.html">析构</a>文档。</p>
<p>当前手册对Nim语言的词法、语法和语义做了描述。</p>
<p>打算学习怎样编译Nim程序和生成文档，请阅读<a class="reference external" href="nimc.html">用户编译指南</a>和<a class="reference external" href="docgen.html">文档生成工具指南</a>。</p>
<p>Nim语言使用&quot;扩展BNF&quot;来解释结构， <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">*</span></span></tt> 表示0个或多个 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span><span class="Operator">+</span></span></tt> 表示1个或多个 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">?</span></span></tt> 表示1个可选的 <em>a</em> ，圆括号用来分组元素。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> 是预先运算符； <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span><span class="Identifier">a</span></span></tt> 表示期望一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> ，但没有用掉，而在之后的规则中被消耗。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">|</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">/</span></span></tt> 符号用来标记备选项，优先级最低。<tt class="docutils literal"><span class="pre"><span class="Operator">/</span></span></tt> 是有序选择，要求解析器按照给定的顺序来尝试备选项，<tt class="docutils literal"><span class="pre"><span class="Operator">/</span></span></tt> 常用来消除语法二义性。</p>
<p>非终端符号以小写字母开头，抽象终端符号字母全大写，逐字的终端符号(包括关键词)用 <tt class="docutils literal"><span class="pre"><span class="CharLit">'</span></span></tt> 引起来。例如:</p>
<p>ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?</p>
<p>二元的 <tt class="docutils literal"><span class="pre"><span class="Operator">^*</span></span></tt> 运算符表示为0或更多，由第二个参数做为间隔；<tt class="docutils literal"><span class="pre"><span class="Operator">^+</span></span></tt> 表示1或更多。 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">^+</span> <span class="Identifier">b</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Punctuation">(</span><span class="Identifier">b</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">*</span></span></tt> 的简写， <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">^*</span> <span class="Identifier">b</span></span></tt> 则是 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Punctuation">(</span><span class="Identifier">b</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Operator">*</span><span class="Punctuation">)</span><span class="Operator">?</span></span></tt> 的简写。 例如:<pre>arrayConstructor = '[' expr ^* ',' ']'</pre>
</p>
<p>Nim的其他，如作用域规则或运行时语义，使用非标准的描述。</p>

<h1><a class="toc-backref" id="定义" href="#定义">定义</a></h1><p>Nim代码是特定的计算单元，作用于称为 <span id="locations_1">locations</span> &quot;地址&quot;组件构成的内存。变量本质上是地址的名称，每个变量和地址都有特定的 <span id="type_1">type</span> &quot;类型&quot;，变量的类型被称为 <span id="static-type_1">static type</span> &quot;静态类型&quot;，地址的类型被称为 <span id="dynamic-type_1">dynamic type</span> &quot;动态类型&quot;。如果静态类型与动态类型不相同，它就是动态类型的父类或子类。</p>
<p><span id="identifier_1">identifier</span> &quot;标识符&quot;是变量、类型、过程等的名称声明符号，一个声明所适用的程序区域被称为该声明的 <span id="scope_1">scope</span> &quot;作用域&quot;，作用域可以嵌套，一个标识符的含义由标识符所声明的最小包围作用域决定，除非重载的解析规则另有建议。</p>
<p>一个表达式特指产生值或地址的计算，产生地址的表达式被称为 <span id="lminusvalues_1">l-values</span> &quot;左值&quot;，左值可以表示地址，也可以表示该地址包含的值，这取决于上下文。</p>
<p>Nim <span id="program_1">program</span> &quot;程序&quot;由一个或多个包含Nim代码的文本 <span id="source-files_1">source files</span> &quot;源文件&quot;组成，由Nim <span id="compiler_1">compiler</span> &quot;编译器&quot;处理成 <span id="executable_1">executable</span> &quot;可执行&quot;文件，这个可执行文件的性质取决于编译器实现，例如，它可能是一个本地二进制文件或JavaScript源代码。</p>
<p>常规的Nim程序，大部分代码被编译至可执行文件，而有些代码可能会在 <span id="compileminustime_1">compile-time</span> &quot;编译期&quot; 执行。包括常量表达式、宏定义和宏定义使用的Nim程序。编译期执行支持Nim语言的大部分，但有限制 -- 详情查看<a class="reference internal" href="#编译期执行限制">编译期执行限制</a>。其术语<span id="runtime_1">runtime</span> &quot;运行时&quot;涵盖了编译期执行和可执行文件中的代码执行。</p>
<p>编译器将Nim源码解析成称为 <span id="abstract-syntax-tree_1">abstract syntax tree</span> (<span id="ast_1">AST</span>) &quot;抽象语法树&quot;的内部数据结构，在执行代码或将其编译为可执行文件之前，通过 <span id="semantic-analysis_1">semantic analysis</span> &quot;语义分析&quot;对AST进行转换，增加了语义信息，如表达式类型、标识符的含义，以及在某些情况下表达式的值。在语义分析中检测到的错误被称为 <span id="static-error_1">static error</span> &quot;静态错误&quot;，当前手册中描述的错误在没有其他约定时，就是静态错误。</p>
<p><span id="panic_1">panic</span> &quot;恐慌&quot;是在运行时执行检测和报告的错误。报告这种错误是通过 <em>引发异常</em> 或 <em>以致命错误</em> 结束的方式。也提供了一种方法来禁用这些 <span id="runtime-checks_1">runtime checks</span> &quot;运行时检查&quot;。详见<a class="reference internal" href="#编译指示">编译指示</a>一节。</p>
<p>恐慌的结果是异常还是致命的错误，实现是特定的，因此，下面的程序无效，尽管代码试图捕获越界访问数组的 <tt class="docutils literal"><span class="pre"><span class="Identifier">IndexDefect</span></span></tt> ，但编译器可能会以致命错误结束程序。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'N'</span>
<span class="Keyword">except</span> <span class="Identifier">IndexDefect</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;invalid index&quot;</span></pre></p>
<p>目前允许通过 <tt class="docutils literal"><span class="pre option">--panics:on|off</span></tt> 在不同方式之间切换，当打开时，程序会因恐慌而结束，当关闭时，运行时的错误会变为异常。 <tt class="docutils literal"><span class="pre option">--panics:on</span></tt> 的好处是产生的二进制代码更小，编译器可以更自由地优化。</p>
<p><span id="unchecked-runtime-error_1">unchecked runtime error</span> &quot;未检查的运行时错误&quot;是不能保证被检测到的错误，它可能导致计算产生意外后果，如果只使用 <span id="safe_1">safe</span> &quot;安全&quot;的语言特性，并且没有禁用运行时检查，就不会产生这类错误。</p>
<p><span id="constant-expression_1">constant expression</span> &quot;常量表达式&quot;，在对包含它的代码进行语义分析时，其值就可以被计算出来，并且不局限于语义分析时求值的能力，例如常量折叠。它从来不会是左值，也不会有副作用。它可以使用编译期支持执行的所有Nim语言特性。由于常量表达式可以作为语义分析时的输入，比如定义数组边界，鉴于这种灵活性要求，编译器交错进行语义分析和编译期代码执行。</p>
<p>想象一下，语义分析原本在源代码中从上到下、从左到右地进行，而在必要时，为了计算后续语义分析所需要的数值，交错执行编译期的代码，产生了语义分析并不完全是自上而下、自左而右进行的情况。这一点非常明确，我们将在文档的后面进一步了解。宏调用需要这种交错。</p>

<h1><a class="toc-backref" id="词法分析" href="#词法分析">词法分析</a></h1>
<h2><a class="toc-backref" id="词法分析-编码" href="#词法分析-编码">编码</a></h2><p>所有的Nim源文件都采用UTF-8编码(或其ASCII子集)，不支持其他编码。可以使用任意标准平台的线性序列终端 —— Unix形式使用ASCII LF(换行)，Windows形式使用ASCII序列CR LF(换行后返回)，或旧的Macintosh形式使用ASCII CR(返回)字符，无论在那个平台上，都可以无差别地使用这些形式。</p>

<h2><a class="toc-backref" id="词法分析-缩进" href="#词法分析-缩进">缩进</a></h2><p>Nim的标准语法描述了 <span id="indentation-sensitive_1">indentation sensitive</span> &quot;缩进敏感&quot;的语言特性，表示其所有的控制结构可以通过缩进来识别，缩进只包括空格，不允许使用制表符。</p>
<p>处理缩进的实现方式如下，词法分析器用前导空格数来解释随后的token，缩进不是单独的token，这个技巧使得Nim解析时只需要预先检查1个token。</p>
<p>语法分析器使用一个缩进级别的堆栈：该堆栈由计算空格的整数组成，语法分析器在对应的策略位置查询缩进信息，而忽略其他地方。伪终端 <tt class="docutils literal"><span class="pre"><span class="Identifier">IND</span><span class="Punctuation">{</span><span class="Operator">&gt;</span><span class="Punctuation">}</span></span></tt> 表示缩进相比堆栈顶部的条目包含更多的空格， <tt class="docutils literal"><span class="pre"><span class="Identifier">IND</span><span class="Punctuation">{</span><span class="Operator">=</span><span class="Punctuation">}</span></span></tt> 表示缩进有相同的空格数，<tt class="docutils literal"><span class="pre"><span class="Identifier">DED</span></span></tt> 是另一个伪终端，表示从堆栈中弹出一个值的 <em>action</em> 动作， <tt class="docutils literal"><span class="pre"><span class="Identifier">IND</span><span class="Punctuation">{</span><span class="Operator">&gt;</span><span class="Punctuation">}</span></span></tt> 则意味着推到堆栈中。</p>
<p>用这些标记，我们现在可以容易地定义出核心语法：语句块。以下简化的例子:<pre>ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{&gt;} stmt ^+ IND{=} DED  # 语句列表
     / simpleStmt                 # 或者单个语句</pre>
</p>

<h2><a class="toc-backref" id="词法分析-注释" href="#词法分析-注释">注释</a></h2><p>注释，是在字符串或字符字面值之外的任意位置，以 <tt class="docutils literal"><span class="pre"><span class="Comment">#</span></span></tt> 字符开始，注释由 <span id="comment-pieces_1">comment pieces</span> &quot;注释段&quot;连接组成，一个注释段以 <tt class="docutils literal"><span class="pre"><span class="Comment">#</span></span></tt> 开始直到行尾，并包括行末的字符。如果下一行只由一个注释段组成，在它和前面的注释段之间没有其他标记，就不会开启一个新的注释。</p>
<p><pre class="listing">
<span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># 这是一个多行注释。</span>
  <span class="Comment"># 词法分析器将这两部分合并在一起。</span>
  <span class="Comment"># 注释在这里继续。</span></pre></p>
<p><span id="documentation-comments_1">Documentation comments</span> &quot;文档注释&quot;以两个 <tt class="docutils literal"><span class="pre"><span class="Comment">##</span></span></tt> 开头，文档注释是token标记，它们属于语法树，只允许在输入文件的某些地方出现。</p>

<h2><a class="toc-backref" id="词法分析-多行注释" href="#词法分析-多行注释">多行注释</a></h2><p>从0.13.0版本的语言开始，Nim支持多行注释。如下:</p>
<p><pre class="listing">
<span class="LongComment">#[Comment here.
Multiple lines
are not a problem.]#</span></pre></p>
<p>多行注释支持嵌套:</p>
<p><pre class="listing">
<span class="LongComment">#[  #[ Multiline comment in already
   commented out code. ]#
proc p[T](x: T) = discard
]#</span></pre></p>
<p>还有多行文档注释，同样支持嵌套:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span> <span class="Operator">=</span>
  <span class="LongComment">##[Long documentation comment
     here.
  ]##</span></pre></p>

<h2><a class="toc-backref" id="词法分析-标识符和关键字" href="#词法分析-标识符和关键字">标识符和关键字</a></h2><p>Nim中的标识符可以是任何字母、数字和下划线组成的字符串，但有以下限制:</p>
<ul class="simple"><li>字母开头</li>
<li>不允许下划线 <tt class="docutils literal"><span class="pre"><span class="Identifier">_</span></span></tt> 结尾</li>
<li><p>不允许双下划线 <tt class="docutils literal"><span class="pre"><span class="Identifier">__</span></span></tt> 结尾。</p>
<p><pre class="listing">
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff'
digit ::= '0'..'9'
IDENTIFIER ::= letter ( ['_'] (letter | digit) )*</pre></p>
</li>
</ul>
<p>目前，任何序数值大于127的Unicode字符(非ASCII)都被归类为 <tt class="docutils literal"><span class="pre"><span class="Identifier">letter</span></span></tt> &quot;字&quot;，因而可以做为标识符的一部分，但以后的语言版本可能会将一些Unicode字符指定为运算符。</p>
<p>以下关键词被保留，不能作为标识符使用:</p>
<p><pre class="listing"><span class="Keyword">addr</span> <span class="Keyword">and</span> <span class="Keyword">as</span> <span class="Keyword">asm</span>
<span class="Keyword">bind</span> <span class="Keyword">block</span> <span class="Keyword">break</span>
<span class="Keyword">case</span> <span class="Keyword">cast</span> <span class="Keyword">concept</span> <span class="Keyword">const</span> <span class="Keyword">continue</span> <span class="Keyword">converter</span>
<span class="Keyword">defer</span> <span class="Keyword">discard</span> <span class="Keyword">distinct</span> <span class="Keyword">div</span> <span class="Keyword">do</span>
<span class="Keyword">elif</span> <span class="Keyword">else</span> <span class="Keyword">end</span> <span class="Keyword">enum</span> <span class="Keyword">except</span> <span class="Keyword">export</span>
<span class="Keyword">finally</span> <span class="Keyword">for</span> <span class="Keyword">from</span> <span class="Keyword">func</span>
<span class="Keyword">if</span> <span class="Keyword">import</span> <span class="Keyword">in</span> <span class="Keyword">include</span> <span class="Keyword">interface</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">iterator</span>
<span class="Keyword">let</span>
<span class="Keyword">macro</span> <span class="Keyword">method</span> <span class="Keyword">mixin</span> <span class="Keyword">mod</span>
<span class="Keyword">nil</span> <span class="Keyword">not</span> <span class="Keyword">notin</span>
<span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Keyword">or</span> <span class="Keyword">out</span>
<span class="Keyword">proc</span> <span class="Keyword">ptr</span>
<span class="Keyword">raise</span> <span class="Keyword">ref</span> <span class="Keyword">return</span>
<span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">static</span>
<span class="Keyword">template</span> <span class="Keyword">try</span> <span class="Keyword">tuple</span> <span class="Keyword">type</span>
<span class="Keyword">using</span>
<span class="Keyword">var</span>
<span class="Keyword">when</span> <span class="Keyword">while</span>
<span class="Keyword">xor</span>
<span class="Keyword">yield</span>
</pre></p>
<p>有些关键词是未使用的保留字，提供给语言未来拓展。</p>

<h2><a class="toc-backref" id="词法分析-标识符相等" href="#词法分析-标识符相等">标识符相等</a></h2><p>如果以下算法返回真，则认为两个标识符相等:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">sameIdentifier</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Keyword">and</span>
    <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;_&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toLowerAscii</span></pre></p>
<p>这意味着，在进行比较时，只有第一个字母是区分大小写的，其他字母在ASCII范围内不区分大小，并忽略下划线。</p>
<p>这种相当非正统的标识符比较方式被称为 <span id="partial-caseminusinsensitivity_1">partial case-insensitivity</span> &quot;部分大小写不敏感&quot;，比传统的大小写敏感有一些优势。</p>
<p>它允许程序员使用自己喜欢的拼写风格。humpStyle&quot;驼峰风格&quot;还是snake_style&quot;蛇形风格&quot;，要求不同程序员编写的库不能使用不兼容的约定。另一个好处是，按Nim思考的编辑器或IDE可以显示首选的标识符，使程序员不必记住标识符的准确拼写。而第一个字母例外的原因是，允许明确解析如 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span></span></tt> 这种常见代码。</p>
<p>需注意，这个规则也适用于关键字，即 <tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt> 、 <tt class="docutils literal"><span class="pre"><span class="Keyword">notIn</span></span></tt> 、 <tt class="docutils literal"><span class="pre"><span class="Keyword">not_in</span></span></tt> 相同，建议关键字的书写方式首选全小写方式，如 <tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">isnot</span></span></tt> 。</p>
<p>Nim曾经是一种 <span id="styleminusinsensitive_1">style-insensitive</span> 完全&quot;大小写不敏感&quot;的语言，意味着不区分大小写，忽略下划线，甚至 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span></span></tt> 之间没有区别。</p>

<h2><a class="toc-backref" id="词法分析-作为标识符的关键词" href="#词法分析-作为标识符的关键词">作为标识符的关键词</a></h2><p>如果一个关键词被括在反撇号里，它就失去了关键词的属性，变成了一个普通的标识符。</p>
<p>Examples</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Punctuation">`</span><span class="Keyword">var</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello Stropping&quot;</span></pre></p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Punctuation">`</span><span class="Keyword">type</span><span class="Punctuation">`</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">let</span> <span class="Punctuation">`</span><span class="Keyword">object</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Keyword">type</span><span class="Punctuation">`</span><span class="Punctuation">:</span> <span class="DecNumber">9</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Keyword">object</span><span class="Punctuation">`</span> <span class="Keyword">is</span> <span class="Identifier">Obj</span>
<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Keyword">object</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Keyword">type</span><span class="Punctuation">`</span> <span class="Operator">==</span> <span class="DecNumber">9</span>

<span class="Keyword">var</span> <span class="Punctuation">`</span><span class="Keyword">var</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Keyword">let</span> <span class="Punctuation">`</span><span class="Keyword">let</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Keyword">var</span><span class="Punctuation">`</span> <span class="Operator">+</span> <span class="Punctuation">`</span><span class="Keyword">let</span><span class="Punctuation">`</span> <span class="Operator">==</span> <span class="DecNumber">50</span>

<span class="Keyword">const</span> <span class="Punctuation">`</span><span class="Identifier">assert</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="Identifier">true</span>
<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Identifier">assert</span><span class="Punctuation">`</span></pre></p>

<h2><a class="toc-backref" id="词法分析-字符串字面值" href="#词法分析-字符串字面值">字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre"><span class="Identifier">STR_LIT</span></span></tt> .</p>
<p>字符串可以用配对的双引号来分隔，可以包含以下 <span id="escape-sequences_1">escape sequences</span>&quot;转义字符&quot;:</p>
<table border="1" class="docutils"><tr><th>转义字符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\p</span></tt></td><td>平台特定的换行符:Windows上的CRLF, Unix上的LF</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_1">carriage return</span> 回车</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_1">line feed</span> 换行(通常叫创建新行 <span id="newline_1">newline</span>)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_1">form feed</span> 换页</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_1">tabulator</span> 制表符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_1">vertical tabulator</span> 垂直制表符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_1">backslash</span> 反斜线</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_1">quotation mark</span> 双引号</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_1">apostrophe</span> 撇号</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_1">character with decimal value d</span>; 十进制值字符 后面的所有十进制数字都用于该字符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_1">alert</span> 警报</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_1">backspace</span> 退格符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_1">escape</span> <span id="esc_1">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_1">character with hex value HH</span> ; 十进制值HH 只允许两个十六进制数字</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> HHHH</td><td><span id="unicode-codepoint-with-hex-value-hhhh_1">unicode codepoint with hex value HHHH</span>; 十进制值HHHH 只允许四个十六进制数字</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\u</span></tt> {H+}</td><td><span id="unicode-codepoint_1">unicode codepoint</span>; unicode字码元素 包含在 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">}</span></span></tt> 中的所有十六进制数字都用于字码元素</td></tr>
</table><p>Nim中的字符串可以包含任意8-bit值，甚至嵌入零，然而，某此操作可能会将第一个二进制零解释为终止符。</p>

<h2><a class="toc-backref" id="词法分析-三重引用字符串字面值" href="#词法分析-三重引用字符串字面值">三重引用字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre"><span class="Identifier">TRIPLESTR_LIT</span></span></tt>.</p>
<p>字符串字面值也可以用三个双引号 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot;</span></span></tt> ... <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot;</span></span></tt> 来分隔，这种形式支持多行，可以包含 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;</span></span></tt> ，并且不解释任何转义字符，为了方便，开头 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot;</span></span></tt> 后面换行符以及空格并不包括在字符串中，字符串的结尾定义为 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot;[^&quot;]</span></span></tt> 模式，如下:</p>
<p><pre class="listing">
<span class="LongStringLit">&quot;&quot;&quot;&quot;long string within quotes&quot;&quot;&quot;&quot;</span></pre></p>
<p>产生:<pre>&quot;long string within quotes&quot;</pre>
</p>

<h2><a class="toc-backref" id="词法分析-原始字符串字面值" href="#词法分析-原始字符串字面值">原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre"><span class="Identifier">RSTR_LIT</span></span></tt> 。</p>
<p>还有原始字符串字面值，前面为字母 <tt class="docutils literal"><span class="pre"><span class="Identifier">r</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">R</span></span></tt> ，并匹配一对双引号普通字符串，它不解释转义字符，这在正则表达式或Windows的路径中使用时很方便。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">openFile</span><span class="Punctuation">(</span><span class="RawData">r&quot;C:\texts\text.txt&quot;</span><span class="Punctuation">)</span> <span class="Comment"># a raw string, so ``\t`` is no tab</span></pre></p>
<p>要在原始字符串字面值中含有 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;</span></span></tt> 则必须成双。</p>
<p><pre class="listing">
<span class="RawData">r&quot;a&quot;&quot;</span><span class="RawData">b&quot;</span></pre></p>
<p>产生:<pre>a&quot;b</pre>
</p>
<p>不能用 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">r&quot;&quot;&quot;&quot;</span></span></tt> 这个标记，因为原始字符串中又引入了三引号的字符串字面值。 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">r&quot;&quot;&quot;</span></span></tt> 与 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot;</span></span></tt> 是相同的，三引号原始字符串字面值也不解释转义字符。</p>

<h2><a class="toc-backref" id="词法分析-广义的原始字符串字面值" href="#词法分析-广义的原始字符串字面值">广义的原始字符串字面值</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre"><span class="Identifier">GENERALIZED_STR_LIT</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">GENERALIZED_TRIPLESTR_LIT</span></span></tt> .</p>
<p><tt class="docutils literal"><span class="pre"><span class="RawData">identifier&quot;string literal&quot;</span></span></tt> 结构是广义的原始字符串字面值，注意，标识符和开头的引号之间没有空格。它是 <tt class="docutils literal"><span class="pre"><span class="Identifier">identifier</span><span class="Punctuation">(</span><span class="RawData">r&quot;string literal&quot;</span><span class="Punctuation">)</span></span></tt> 结构的简写方式，表示以原始字符串字面值为唯一参数的常规调用。广义的原始字符串字面值的价值，在于便捷嵌入mini语言，例如正则表达式。</p>
<p>还有 <tt class="docutils literal"><span class="pre"><span class="LongStringLit">identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;</span></span></tt> 结构，是 <tt class="docutils literal"><span class="pre"><span class="Identifier">identifier</span><span class="Punctuation">(</span><span class="LongStringLit">&quot;&quot;&quot;string literal&quot;&quot;&quot;</span><span class="Punctuation">)</span></span></tt> 的简写方式。</p>

<h2><a class="toc-backref" id="词法分析-字符字面值" href="#词法分析-字符字面值">字符字面值</a></h2><p>字符字面值用单引号 <tt class="docutils literal"><span class="pre"><span class="CharLit">''</span></span></tt> 括起来，可以包含与字符串相同的转义字符 —— 但有一种例外：不允许与平台有关的 <span id="newline_2">newline</span> (<tt class="docutils literal"><span class="pre">\p</span></tt>) &quot;换行符&quot;，因为它可能比一个字符宽(它可能是一对CR/LF)。下面是有效的 <span id="escape-sequences_2">escape sequences</span> &quot;转义字符&quot;字面值。</p>
<table border="1" class="docutils"><tr><th>转义字符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\c</span></tt></td><td><span id="carriage-return_2">carriage return</span> 回车</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\l</span></tt></td><td><span id="line-feed_2">line feed</span> 换行(通常叫创建新行 <span id="newline_3">newline</span>)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\f</span></tt></td><td><span id="form-feed_2">form feed</span> 换页</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\t</span></tt></td><td><span id="tabulator_2">tabulator</span> 制表符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\v</span></tt></td><td><span id="vertical-tabulator_2">vertical tabulator</span> 垂直制表符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\\</span></tt></td><td><span id="backslash_2">backslash</span> 反斜线</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\&quot;</span></tt></td><td><span id="quotation-mark_2">quotation mark</span> 双引号</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\'</span></tt></td><td><span id="apostrophe_2">apostrophe</span> 撇号</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\</span></tt> '0'..'9'+</td><td><span id="character-with-decimal-value-d_2">character with decimal value d</span>; 十进制值字符 后面的所有十进制数字都用于该字符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\a</span></tt></td><td><span id="alert_2">alert</span> 警报</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\b</span></tt></td><td><span id="backspace_2">backspace</span> 退格符</td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\e</span></tt></td><td><span id="escape_2">escape</span> <span id="esc_2">[ESC]</span></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">\x</span></tt> HH</td><td><span id="character-with-hex-value-hh_2">character with hex value HH</span>; 十进制值HH 只允许两个十六进制数字</td></tr>
</table><p>一个字符不是一个Unicode字符，而是单字节。</p>
<p>原由：为了能够有效地支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span></span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">Rune</span></span></tt> 类型可以代表任何Unicode字符。 <tt class="docutils literal"><span class="pre"><span class="Identifier">Rune</span></span></tt> 声明在<a class="reference external" href="unicode.html">unicode模块</a>中。</p>
<p>如果前面有一个反引号token，则不以 <tt class="docutils literal"><span class="pre"><span class="CharLit">'</span></span></tt> 结尾的字符字面值被解释为 <tt class="docutils literal"><span class="pre"><span class="CharLit">'</span></span></tt> 。在前面的反引号标记和字符字面值之间不能有空格。这种特殊情况是为了保证像 <tt class="docutils literal"><span class="pre">proc `'customLiteral`(s: string)</span></tt> 这样的声明有效。 <tt class="docutils literal"><span class="pre">proc `'customLiteral`(s: string)</span></tt> 与 <tt class="docutils literal"><span class="pre">proc `'\''customLiteral`(s: string)</span></tt> 相同。</p>
<p>参阅<a class="reference internal" href="#自定义数值字面量">自定义数值字面量</a>。</p>

<h2><a class="toc-backref" id="词法分析-数值字面值" href="#词法分析-数值字面值">数值字面值</a></h2><p>数值字面值具有这种形式:<pre>hexdigit = digit | 'A'..'F' | 'a'..'f'
octdigit = '0'..'7'
bindigit = '0'..'1'
unary_minus = '-' # See the section about unary minus
HEX_LIT = unary_minus? '0' ('x' | 'X' ) hexdigit ( ['_'] hexdigit )*
DEC_LIT = unary_minus? digit ( ['_'] digit )*
OCT_LIT = unary_minus? '0' 'o' octdigit ( ['_'] octdigit )*
BIN_LIT = unary_minus? '0' ('b' | 'B' ) bindigit ( ['_'] bindigit )*

INT_LIT = HEX_LIT
        | DEC_LIT
        | OCT_LIT
        | BIN_LIT

INT8_LIT = INT_LIT ['\''] ('i' | 'I') '8'
INT16_LIT = INT_LIT ['\''] ('i' | 'I') '16'
INT32_LIT = INT_LIT ['\''] ('i' | 'I') '32'
INT64_LIT = INT_LIT ['\''] ('i' | 'I') '64'

UINT_LIT = INT_LIT ['\''] ('u' | 'U')
UINT8_LIT = INT_LIT ['\''] ('u' | 'U') '8'
UINT16_LIT = INT_LIT ['\''] ('u' | 'U') '16'
UINT32_LIT = INT_LIT ['\''] ('u' | 'U') '32'
UINT64_LIT = INT_LIT ['\''] ('u' | 'U') '64'

exponent = ('e' | 'E' ) ['+' | '-'] digit ( ['_'] digit )*
FLOAT_LIT = unary_minus? digit (['_'] digit)* (('.' digit (['_'] digit)* [exponent]) |exponent)
FLOAT32_SUFFIX = ('f' | 'F') ['32']
FLOAT32_LIT = HEX_LIT '\'' FLOAT32_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT32_SUFFIX
FLOAT64_SUFFIX = ( ('f' | 'F') '64' ) | 'd' | 'D'
FLOAT64_LIT = HEX_LIT '\'' FLOAT64_SUFFIX
            | (FLOAT_LIT | DEC_LIT | OCT_LIT | BIN_LIT) ['\''] FLOAT64_SUFFIX

CUSTOM_NUMERIC_LIT = (FLOAT_LIT | INT_LIT) '\'' CUSTOM_NUMERIC_SUFFIX

# CUSTOM_NUMERIC_SUFFIX 是任意非预定义类型后缀的Nim标识符。</pre>
</p>
<p>从描述中可以看出，数值字面值可以包含下划线，以便于阅读。整数和浮点数可以用十进制(无前缀)、二进制(前缀 <tt class="docutils literal"><span class="pre"><span class="BinNumber">0b</span></span></tt> )、八进制(前缀 <tt class="docutils literal"><span class="pre"><span class="OctNumber">0o</span></span></tt> )和十六进制(前缀 <tt class="docutils literal"><span class="pre"><span class="HexNumber">0x</span></span></tt> )注解表示。</p>
<p>像 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 这样的数值字面值中的一元减号 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span></span></tt> 是字面值的一部分，为了让 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="DecNumber">128'i8</span></span></tt> 等表达式有效，后来被添加到语言中。如果没有这种例外，则只有 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="DecNumber">128</span></span></tt> 有效， -- <tt class="docutils literal"><span class="pre"><span class="DecNumber">128</span></span></tt> 将不是有效的 <tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt> 值。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">unary_minus</span></span></tt> &quot;一元减号&quot;规则有一些限制，这在正式语法中没有提到。 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span></span></tt> 是数值字面值的一部分时，前面的字符必须在 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="CharLit">' '</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="CharLit">'\n'</span><span class="Punctuation">,</span> <span class="CharLit">'\r'</span><span class="Punctuation">,</span> <span class="CharLit">','</span><span class="Punctuation">,</span> <span class="CharLit">';'</span><span class="Punctuation">,</span> <span class="CharLit">'('</span><span class="Punctuation">,</span> <span class="CharLit">'['</span><span class="Punctuation">,</span> <span class="CharLit">'{'</span><span class="Punctuation">}</span></span></tt> 集合中，这个设计是为了涵盖大多数合理情况。</p>
<p>在下面的例子中， <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 是一个单独的token标记:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="Operator">-</span><span class="DecNumber">1</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Punctuation">[</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
<span class="Identifier">echo</span> <span class="DecNumber">3</span><span class="Punctuation">,</span><span class="Operator">-</span><span class="DecNumber">1</span>

<span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">;</span><span class="Operator">-</span><span class="DecNumber">1</span></pre></p>
<p>在下面的例子中， <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 被解析为两个独立的token标记( <tt class="docutils literal"><span class="pre tok">-</span></tt> <tt class="docutils literal"><span class="pre tok">1</span></tt> ):</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Operator">-</span><span class="DecNumber">1</span>
<span class="Identifier">echo</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span>
<span class="Identifier">echo</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">-</span><span class="DecNumber">1</span>
<span class="StringLit">&quot;abc&quot;</span><span class="Operator">-</span><span class="DecNumber">1</span></pre></p>
<p>以撇号 ( <tt class="docutils literal"><span class="pre"><span class="Operator">\</span><span class="CharLit">'</span></span></tt> ) 开始的后缀被称为 <span id="type-suffix_1">type suffix</span> &quot;类型后缀&quot;。没有类型后缀的字面值是整数类型，当包含一个点或 <tt class="docutils literal"><span class="pre"><span class="Identifier">E</span><span class="Operator">|</span><span class="Identifier">e</span></span></tt> 时是 <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt> 类型。如果字面值的范围在 <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">int32</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int32</span><span class="Punctuation">)</span></span></tt> 之间，那么这个整数类型就是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> ，否则就是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int64</span></span></tt> 。为了记数方便，如果类型后缀明确，那么后缀的撇号是可选的(只有带类型后缀的十六进制浮点数字面值的含义才会不明确)。</p>
<p>预定义的类型后缀有:</p>
<table border="1" class="docutils"><tr><th>类型后缀</th><th>产生的字面值类型</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'i8</span></span></tt></td><td>int8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'i16</span></span></tt></td><td>int16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'i32</span></span></tt></td><td>int32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'i64</span></span></tt></td><td>int64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'u</span></span></tt></td><td>uint</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'u8</span></span></tt></td><td>uint8</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'u16</span></span></tt></td><td>uint16</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'u32</span></span></tt></td><td>uint32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'u64</span></span></tt></td><td>uint64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'f</span></span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'d</span></span></tt></td><td>float64</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'f32</span></span></tt></td><td>float32</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="CharLit">'f64</span></span></tt></td><td>float64</td></tr>
</table><p>浮点数字面值也可以采用二进制、八进制或十六进制的注解: <tt class="docutils literal"><span class="pre"><span class="FloatNumber">0B0_10001110100_0000101001000111101011101111111011000101001101001001'f64</span></span></tt> 根据IEEE浮点标准，约为1.72826e35。</p>
<p>字面值必须匹配数据类型，例如， <tt class="docutils literal"><span class="pre"><span class="DecNumber">333'i8</span></span></tt> 是一个无效的字面值。以非10进制表示的字面值主要用于标记和比特位模式，因此检查是对位宽而不是值范围进行的，所以: 0b10000000'u8 == 0x80'u8 == 128，但是， 0b10000000'i8 == 0x80'i8 == -128 而不是 -1。</p>

<h3><a class="toc-backref" id="数值字面值-自定义数值字面值" href="#数值字面值-自定义数值字面值">自定义数值字面值</a></h3><p>如果后缀未预定义，那么后缀会被认为是对proc过程、template模板、macro宏或其他可调用标识符的调用，包含字面值的字符串被传递给该标识符。可调用标识符需要用特定的 <tt class="docutils literal"><span class="pre">'</span></tt> 前缀声明。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">type</span> <span class="Identifier">u4</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">uint8</span> <span class="Comment"># 一个4位无符号整数，又称 &quot;nibble&quot;</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="CharLit">'u4`(n: string): u4 =</span>
  <span class="Comment"># 这是必需的。</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="HexNumber">0x0F</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">u4</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">5'</span><span class="Identifier">u4</span></pre></p>
<p>更确切地说，自定义的数值字面值 <tt class="docutils literal"><span class="pre"><span class="DecNumber">123'</span><span class="Identifier">custom</span></span></tt> 在解析步骤中被转换为 r&quot;123&quot;.<tt class="docutils literal"><span class="pre"><span class="CharLit">'custom</span></span></tt> 。并没有对应于这种转换的AST节点种类，这种转换在额外参数传递给被调用者的情况时，处理更合理。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">strutils</span>
<span class="Keyword">type</span> <span class="Identifier">u4</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">uint8</span> <span class="Comment"># 4位无符号整数，又称 &quot;nibble&quot;</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="CharLit">'u4`(n: string; moreData: int): u4 =</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="HexNumber">0x0F</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">u4</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">5'</span><span class="Identifier">u4</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span></pre></p>
<p>自定义数值字面值由名称为 <tt class="docutils literal"><span class="pre"><span class="Identifier">CUSTOM_NUMERIC_LIT</span></span></tt> 的语法规则涵盖。自定义的数值字面值是单独的token标记。</p>

<h2><a class="toc-backref" id="词法分析-运算符" href="#词法分析-运算符">运算符</a></h2><p>Nim允许用户定义运算符。运算符可以是以下字符的任意组合:<pre>=     +     -     *     /     &lt;     &gt;
@     $     ~     &amp;     %     |
!     ?     ^     .     :     \</pre>
</p>
<p>(语法中使用终端OPR来表示这里定义的运算符标识符。)</p>
<p>这些关键字也是运算符: <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span> <span class="Keyword">or</span> <span class="Keyword">not</span> <span class="Keyword">xor</span> <span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Keyword">div</span> <span class="Keyword">mod</span> <span class="Keyword">in</span> <span class="Keyword">notin</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">of</span> <span class="Keyword">as</span> <span class="Keyword">from</span></span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre tok">.</span></tt>, <tt class="docutils literal"><span class="pre tok">=</span></tt>, <tt class="docutils literal"><span class="pre tok">:</span></tt>, <tt class="docutils literal"><span class="pre tok">::</span></tt> 不能作为一般运算符使用;，其目的是应用于其他符号。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">*:</span></span></tt> 是特殊情况，会处理为两个token标记 <tt class="docutils literal"><span class="pre tok">*</span></tt> 和 <tt class="docutils literal"><span class="pre tok">:</span></tt> ，是为了支持 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">v</span><span class="Operator">*:</span> <span class="Identifier">T</span></span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">not</span></span></tt> 关键字总会是一元运算符, <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Keyword">not</span> <span class="Identifier">b</span></span></tt> 解析为 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span><span class="Punctuation">(</span><span class="Keyword">not</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> , 而不是 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 。</p>

<h2><a class="toc-backref" id="词法分析-其他标记" href="#词法分析-其他标记">其他标记</a></h2><p>以下字符串表示其他标记:<pre>`   (    )     {    }     [    ]    ,  ;   [.    .]  {.   .}  (.  .)  [:</pre>
</p>
<p><span id="slice_1">slice</span> &quot;切片&quot;运算符 <tt class="docutils literal"><span class="pre tok">..</span></tt> 优先于其他包含点的标记: <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">..</span><span class="Punctuation">}</span></span></tt> 是三个标记 <tt class="docutils literal"><span class="pre tok">{</span></tt>, <tt class="docutils literal"><span class="pre tok">..</span></tt>, <tt class="docutils literal"><span class="pre tok">}</span></tt> 而不是两个标记 <tt class="docutils literal"><span class="pre tok">{.</span></tt>, <tt class="docutils literal"><span class="pre tok">.}</span></tt> 。</p>

<h1><a class="toc-backref" id="句法" href="#句法">句法</a></h1><p>本节列出了Nim的标准语法。语法分析器如何处理缩进问题，在<a class="reference internal" href="#词法分析">词法分析</a>一节有说明。</p>
<p>Nim允许用户定义运算符。二元运算符有11个不同的优先级。</p>

<h2><a class="toc-backref" id="句法-结合律" href="#句法-结合律">结合律</a></h2><p>第一个字符为 <tt class="docutils literal"><span class="pre"><span class="Operator">^</span></span></tt> 的二元运算符是右结合，所有其他二元运算符是左结合。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">^/</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># 右结合除法运算符</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">/</span> <span class="Identifier">y</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span> <span class="Operator">^/</span> <span class="DecNumber">4</span> <span class="Operator">^/</span> <span class="DecNumber">8</span> <span class="Comment"># 24.0 (4 / 8 = 0.5, then 12 / 0.5 = 24.0)</span>
<span class="Identifier">echo</span> <span class="DecNumber">12</span>  <span class="Operator">/</span> <span class="DecNumber">4</span>  <span class="Operator">/</span> <span class="DecNumber">8</span> <span class="Comment"># 0.375 (12 / 4 = 3.0, then 3 / 8 = 0.375)</span></pre></p>

<h2><a class="toc-backref" id="句法-优先级" href="#句法-优先级">优先级</a></h2><p>一元运算符总是比任意二元运算符结合性更强: <tt class="docutils literal"><span class="pre"><span class="Operator">$</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">b</span></span></tt> 而不是 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 。</p>
<p>如果一个一元运算符的第一个字符是 <tt class="docutils literal"><span class="pre"><span class="Operator">@</span></span></tt> ，它就是一个 <span id="sigilminuslike_1">sigil-like</span> 运算符，比 <tt class="docutils literal"><span class="pre"><span class="Identifier">primarySuffix</span></span></tt> 的结合性更强: <tt class="docutils literal"><span class="pre"><span class="Operator">@</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">abc</span></span></tt> 被解析为 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">abc</span></span></tt> ，而 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">abc</span></span></tt> 被解析为 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">abc</span><span class="Punctuation">)</span></span></tt> 。</p>
<p>对于不是关键字的二元运算符，优先级由以下规则决定:</p>
<p>以 <tt class="docutils literal"><span class="pre"><span class="Operator">-&gt;</span></span></tt> 、 <tt class="docutils literal"><span class="pre"><span class="Operator">~&gt;</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Operator">=&gt;</span></span></tt> 结尾的运算符被称为 <span id="arrow-like_1">arrow like</span> &quot;箭头&quot;，在所有运算符中优先级最低。</p>
<p>如果运算符以 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> 结尾，并且其第一个字符不是 <tt class="docutils literal"><span class="pre"><span class="Operator">&lt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&gt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">!</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">~</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">?</span></span></tt> 中的任意一个，那么它就是一个 <em>赋值运算符</em> ，具有第二低的优先级。</p>
<p>否则，优先级由第一个字符决定。</p>
<table border="1" class="docutils"><tr><th>优先级</th><th>运算符</th><th>第一个字符</th><th>终端符号</th></tr>
<tr><td>10 (最高)</td><td></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">$</span> <span class="Operator">^</span></span></tt></td><td>OP10</td></tr>
<tr><td>9</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">*</span> <span class="Operator">/</span> <span class="Keyword">div</span> <span class="Keyword">mod</span> <span class="Keyword">shl</span> <span class="Keyword">shr</span> <span class="Operator">%</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">*</span> <span class="Operator">%</span> <span class="Operator">\</span> <span class="Operator">/</span></span></tt></td><td>OP9</td></tr>
<tr><td>8</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">~</span> <span class="Operator">|</span></span></tt></td><td>OP8</td></tr>
<tr><td>7</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt></td><td>OP7</td></tr>
<tr><td>6</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">..</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt></td><td>OP6</td></tr>
<tr><td>5</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">==</span> <span class="Operator">&lt;=</span> <span class="Operator">&lt;</span> <span class="Operator">&gt;=</span> <span class="Operator">&gt;</span> <span class="Operator">!=</span> <span class="Keyword">in</span> <span class="Keyword">notin</span> <span class="Keyword">is</span> <span class="Keyword">isnot</span> <span class="Keyword">not</span> <span class="Keyword">of</span> <span class="Keyword">as</span> <span class="Keyword">from</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">=</span> <span class="Operator">&lt;</span> <span class="Operator">&gt;</span> <span class="Operator">!</span></span></tt></td><td>OP5</td></tr>
<tr><td>4</td><td><tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt></td><td></td><td>OP4</td></tr>
<tr><td>3</td><td><tt class="docutils literal"><span class="pre"><span class="Keyword">or</span> <span class="Keyword">xor</span></span></tt></td><td></td><td>OP3</td></tr>
<tr><td>2</td><td></td><td><tt class="docutils literal"><span class="pre"><span class="Operator">@</span> <span class="Punctuation">:</span> <span class="Operator">?</span></span></tt></td><td>OP2</td></tr>
<tr><td>1</td><td><em>赋值运算符</em> (如 <tt class="docutils literal"><span class="pre"><span class="Operator">+=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">*=</span></span></tt>)</td><td></td><td>OP1</td></tr>
<tr><td>0 (最低)</td><td><em>箭头运算符</em> (like <tt class="docutils literal"><span class="pre"><span class="Operator">-&gt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">=&gt;</span></span></tt>)</td><td></td><td>OP0</td></tr>
</table><p>一个运算符是否被用作前缀，会受到前置空格影响 (这个解析变化是在0.13.0版本中引入的) 。</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">foo</span>
<span class="Comment"># 解析为</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">foo</span><span class="Punctuation">)</span></pre></p>
<p>空格也决定了 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 是被解析为调用的参数列表，还是被解析为元组构造。</p>
<p><pre class="listing">
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 把 1 和 2 传递给 echo</span></pre></p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># 把 tuple (1, 2) 传递给 echo</span></pre></p>

<h2><a class="toc-backref" id="句法-点类运算符" href="#句法-点类运算符">点类运算符</a></h2><p>语法中的终端符号: <tt class="docutils literal"><span class="pre"><span class="Identifier">DOTLIKEOP</span></span></tt> 。</p>
<p>点类运算符是以 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> 开头的运算符，但不是以 <tt class="docutils literal"><span class="pre"><span class="Operator">..</span></span></tt> 开头，例如 <tt class="docutils literal"><span class="pre"><span class="Operator">.?</span></span></tt> ，它们的优先级与 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> 相同，因此 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span><span class="Operator">.?</span><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">c</span></span></tt> 被解析为 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.?</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">c</span></span></tt> ，而不是 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span><span class="Operator">.?</span> <span class="Punctuation">(</span><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">c</span><span class="Punctuation">)</span></span></tt> 。</p>

<h2><a class="toc-backref" id="句法-语法" href="#句法-语法">语法</a></h2><p>语法的起始符号是 <tt class="docutils literal"><span class="pre"><span class="Identifier">module</span></span></tt> 。</p>
<pre># This file is generated by compiler/parser.nim.
module = stmt ^* (';' / IND{=})
comma = ',' COMMENT?
semicolon = ';' COMMENT?
colon = ':' COMMENT?
colcom = ':' COMMENT?
operator =  OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9
         | 'or' | 'xor' | 'and'
         | 'is' | 'isnot' | 'in' | 'notin' | 'of' | 'as' | 'from'
         | 'div' | 'mod' | 'shl' | 'shr' | 'not' | 'static' | '..'
prefixOperator = operator
optInd = COMMENT? IND?
optPar = (IND{&gt;} | IND{=})?
simpleExpr = arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr = assignExpr (OP1 optInd assignExpr)*
assignExpr = orExpr (OP2 optInd orExpr)*
orExpr = andExpr (OP3 optInd andExpr)*
andExpr = cmpExpr (OP4 optInd cmpExpr)*
cmpExpr = sliceExpr (OP5 optInd sliceExpr)*
sliceExpr = ampExpr (OP6 optInd ampExpr)*
ampExpr = plusExpr (OP7 optInd plusExpr)*
plusExpr = mulExpr (OP8 optInd mulExpr)*
mulExpr = dollarExpr (OP9 optInd dollarExpr)*
dollarExpr = primary (OP10 optInd primary)*
operatorB = OP0 | OP1 | OP2 | OP3 | OP4 | OP5 | OP6 | OP7 | OP8 | OP9 |
            'div' | 'mod' | 'shl' | 'shr' | 'in' | 'notin' |
            'is' | 'isnot' | 'not' | 'of' | 'as' | 'from' | '..' | 'and' | 'or' | 'xor'
symbol = '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'
       | IDENT | KEYW
exprColonEqExpr = expr (':'|'=' expr)?
exprList = expr ^+ comma
exprColonEqExprList = exprColonEqExpr (comma exprColonEqExpr)* (comma)?
qualifiedIdent = symbol ('.' optInd symbol)?
setOrTableConstr = '{' ((exprColonEqExpr comma)* | ':' ) '}'
castExpr = 'cast' ('[' optInd typeDesc optPar ']' '(' optInd expr optPar ')') /
parKeyw = 'discard' | 'include' | 'if' | 'while' | 'case' | 'try'
        | 'finally' | 'except' | 'for' | 'block' | 'const' | 'let'
        | 'when' | 'var' | 'mixin'
par = '(' optInd
          ( &amp;parKeyw (ifExpr / complexOrSimpleStmt) ^+ ';'
          | ';' (ifExpr / complexOrSimpleStmt) ^+ ';'
          | pragmaStmt
          | simpleExpr ( ('=' expr (';' (ifExpr / complexOrSimpleStmt) ^+ ';' )? )
                       | (':' expr (',' exprColonEqExpr     ^+ ',' )? ) ) )
          optPar ')'
literal = | INT_LIT | INT8_LIT | INT16_LIT | INT32_LIT | INT64_LIT
          | UINT_LIT | UINT8_LIT | UINT16_LIT | UINT32_LIT | UINT64_LIT
          | FLOAT_LIT | FLOAT32_LIT | FLOAT64_LIT
          | STR_LIT | RSTR_LIT | TRIPLESTR_LIT
          | CHAR_LIT | CUSTOM_NUMERIC_LIT
          | NIL
generalizedLit = GENERALIZED_STR_LIT | GENERALIZED_TRIPLESTR_LIT
identOrLiteral = generalizedLit | symbol | literal
               | par | arrayConstr | setOrTableConstr | tupleConstr
               | castExpr
tupleConstr = '(' optInd (exprColonEqExpr comma?)* optPar ')'
arrayConstr = '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix = '(' (exprColonEqExpr comma?)* ')'
      | '.' optInd symbol ('[:' exprList ']' ( '(' exprColonEqExpr ')' )?)? generalizedLit?
      | DOTLIKEOP optInd symbol generalizedLit?
      | '[' optInd exprColonEqExprList optPar ']'
      | '{' optInd exprColonEqExprList optPar '}'
      | &amp;( '`'|IDENT|literal|'cast'|'addr'|'type') expr (comma expr)* # command syntax
pragma = '{.' optInd (exprColonEqExpr comma?)* optPar ('.}' | '}')
identVis = symbol OPR?  # postfix position
identVisDot = symbol '.' optInd symbol OPR?
identWithPragma = identVis pragma?
identWithPragmaDot = identVisDot pragma?
declColonEquals = identWithPragma (comma identWithPragma)* comma?
                  (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals = IDENT (comma IDENT)* comma?
     (':' optInd typeDesc)? ('=' optInd expr)?)
tupleDecl = 'tuple'
    '[' optInd  (identColonEquals (comma/semicolon)?)*  optPar ']' |
    COMMENT? (IND{&gt;} identColonEquals (IND{=} identColonEquals)*)?
paramList = '(' declColonEquals ^* (comma/semicolon) ')'
paramListArrow = paramList? ('-&gt;' optInd typeDesc)?
paramListColon = paramList? (':' optInd typeDesc)?
doBlock = 'do' paramListArrow pragma? colcom stmt
routineExpr = ('proc' | 'func' | 'iterator') paramListColon pragma? ('=' COMMENT? stmt)?
forStmt = 'for' (identWithPragma ^+ comma) 'in' expr colcom stmt
forExpr = forStmt
expr = (blockExpr
      | ifExpr
      | whenExpr
      | caseStmt
      | forExpr
      | tryExpr)
      / simpleExpr
primary = operatorB primary primarySuffix* |
          tupleDecl | routineExpr | enumDecl
          objectDecl | conceptDecl | ('bind' primary)
          ('var' | 'out' | 'ref' | 'ptr' | 'distinct') primary
        /  prefixOperator* identOrLiteral primarySuffix*
typeDesc = simpleExpr ('not' expr)?
typeDefAux = simpleExpr ('not' expr
                        | postExprBlocks)?
postExprBlocks = ':' stmt? ( IND{=} doBlock
                           | IND{=} 'of' exprList ':' stmt
                           | IND{=} 'elif' expr ':' stmt
                           | IND{=} 'except' exprList ':' stmt
                           | IND{=} 'finally' ':' stmt
                           | IND{=} 'else' ':' stmt )*
exprStmt = simpleExpr
         (( '=' optInd expr colonBody? )
         / ( expr ^+ comma
             postExprBlocks
           ))?
importStmt = 'import' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
exportStmt = 'export' optInd expr
              ((comma expr)*
              / 'except' optInd (expr ^+ comma))
includeStmt = 'include' optInd expr ^+ comma
fromStmt = 'from' expr 'import' optInd expr (comma expr)*
returnStmt = 'return' optInd expr?
raiseStmt = 'raise' optInd expr?
yieldStmt = 'yield' optInd expr?
discardStmt = 'discard' optInd expr?
breakStmt = 'break' optInd expr?
continueStmt = 'continue' optInd expr?
condStmt = expr colcom stmt COMMENT?
           (IND{=} 'elif' expr colcom stmt)*
           (IND{=} 'else' colcom stmt)?
ifStmt = 'if' condStmt
whenStmt = 'when' condStmt
condExpr = expr colcom expr optInd
        ('elif' expr colcom expr optInd)*
         'else' colcom expr
ifExpr = 'if' condExpr
whenExpr = 'when' condExpr
whileStmt = 'while' expr colcom stmt
ofBranch = 'of' exprList colcom stmt
ofBranches = ofBranch (IND{=} ofBranch)*
                      (IND{=} 'elif' expr colcom stmt)*
                      (IND{=} 'else' colcom stmt)?
caseStmt = 'case' expr ':'? COMMENT?
            (IND{&gt;} ofBranches DED
            | IND{=} ofBranches)
tryStmt = 'try' colcom stmt &amp;(IND{=}? 'except'|'finally')
           (IND{=}? 'except' exprList colcom stmt)*
           (IND{=}? 'finally' colcom stmt)?
tryExpr = 'try' colcom stmt &amp;(optInd 'except'|'finally')
           (optInd 'except' exprList colcom stmt)*
           (optInd 'finally' colcom stmt)?
blockStmt = 'block' symbol? colcom stmt
blockExpr = 'block' symbol? colcom stmt
staticStmt = 'static' colcom stmt
deferStmt = 'defer' colcom stmt
asmStmt = 'asm' pragma? (STR_LIT | RSTR_LIT | TRIPLESTR_LIT)
genericParam = symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList = '[' optInd
  genericParam ^* (comma/semicolon) optPar ']'
pattern = '{' stmt '}'
indAndComment = (IND{&gt;} COMMENT)? | COMMENT?
routine = optInd identVis pattern? genericParamList?
  paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt = COMMENT
section(RULE) = COMMENT? RULE / (IND{&gt;} (RULE / COMMENT)^+IND{=} DED)
enumDecl = 'enum' optInd (symbol pragma? optInd ('=' optInd expr COMMENT?)? comma?)+
objectWhen = 'when' expr colcom objectPart COMMENT?
            ('elif' expr colcom objectPart COMMENT?)*
            ('else' colcom objectPart COMMENT?)?
objectBranch = 'of' exprList colcom objectPart
objectBranches = objectBranch (IND{=} objectBranch)*
                      (IND{=} 'elif' expr colcom objectPart)*
                      (IND{=} 'else' colcom objectPart)?
objectCase = 'case' identWithPragma ':' typeDesc ':'? COMMENT?
            (IND{&gt;} objectBranches DED
            | IND{=} objectBranches)
objectPart = IND{&gt;} objectPart^+IND{=} DED
           / objectWhen / objectCase / 'nil' / 'discard' / declColonEquals
objectDecl = 'object' ('of' typeDesc)? COMMENT? objectPart
conceptParam = ('var' | 'out')? symbol
conceptDecl = 'concept' conceptParam ^* ',' (pragma)? ('of' typeDesc ^* ',')?
              &amp;IND{&gt;} stmt
typeDef = identWithPragmaDot genericParamList? '=' optInd typeDefAux
            indAndComment? / identVisDot genericParamList? pragma '=' optInd typeDefAux
            indAndComment?
varTuple = '(' optInd identWithPragma ^+ comma optPar ')' '=' optInd expr
colonBody = colcom stmt postExprBlocks?
variable = (varTuple / identColonEquals) colonBody? indAndComment
constant = (varTuple / identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment
bindStmt = 'bind' optInd qualifiedIdent ^+ comma
mixinStmt = 'mixin' optInd qualifiedIdent ^+ comma
pragmaStmt = pragma (':' COMMENT? stmt)?
simpleStmt = ((returnStmt | raiseStmt | yieldStmt | discardStmt | breakStmt
           | continueStmt | pragmaStmt | importStmt | exportStmt | fromStmt
           | includeStmt | commentStmt) / exprStmt) COMMENT?
complexOrSimpleStmt = (ifStmt | whenStmt | whileStmt
                    | tryStmt | forStmt
                    | blockStmt | staticStmt | deferStmt | asmStmt
                    | 'proc' routine
                    | 'method' routine
                    | 'func' routine
                    | 'iterator' routine
                    | 'macro' routine
                    | 'template' routine
                    | 'converter' routine
                    | 'type' section(typeDef)
                    | 'const' section(constant)
                    | ('let' | 'var' | 'using') section(variable)
                    | bindStmt | mixinStmt)
                    / simpleStmt
stmt = (IND{&gt;} complexOrSimpleStmt^+(IND{=} / ';') DED)
     / simpleStmt ^+ ';'
</pre>

<h1><a class="toc-backref" id="求值顺序" href="#求值顺序">求值顺序</a></h1><p>求值顺序严格从左到右，由内到外，这是大多数其他强类型编程语言的典型做法:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Operator">$</span><span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">arg</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">s</span> <span class="Operator">==</span> <span class="StringLit">&quot;123&quot;</span></pre></p>
<p>赋值也不特殊，左边的表达式在右边的表达式之前被求值:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">proc</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span>
  <span class="Identifier">inc</span> <span class="Identifier">v</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">v</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">someCopy</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">getI</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span></pre></p>
<p>原由：与重载赋值或类似赋值的运算符保持一致，<tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">b</span></span></tt> 可以理解为 <tt class="docutils literal"><span class="pre"><span class="Identifier">performSomeCopy</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 。</p>
<p>然而，&quot;求值顺序&quot; 的概念只有在代码被规范化之后才适用。规范化涉及到模板的扩展和参数的重新排序，这些参数已经被传递给命名参数。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="StringLit">&quot;p&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">5</span>

<span class="Keyword">proc</span> <span class="Identifier">q</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="StringLit">&quot;q&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">3</span>

<span class="Comment"># 由于模板扩展语义，求值顺序是 'b' 在 'a' 之前。</span>
<span class="Keyword">template</span> <span class="Identifier">swapArgs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">a</span>

<span class="Identifier">doAssert</span> <span class="Identifier">swapArgs</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">q</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">q</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">6</span>
<span class="Identifier">doAssert</span> <span class="Identifier">s</span> <span class="Operator">==</span> <span class="StringLit">&quot;qppq&quot;</span>

<span class="Comment"># 求值顺序不受命名参数的影响:</span>
<span class="Keyword">proc</span> <span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Identifier">first</span><span class="Punctuation">,</span> <span class="Identifier">second</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span>

<span class="Comment"># 'p' 在 'q' 之前求值!</span>
<span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Identifier">second</span> <span class="Operator">=</span> <span class="Identifier">q</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">first</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">doAssert</span> <span class="Identifier">s</span> <span class="Operator">==</span> <span class="StringLit">&quot;qppqpq&quot;</span></pre></p>
<p>原由: 这比设想的替代方案容易实现。</p>

<h1><a class="toc-backref" id="常量和常量表达式" href="#常量和常量表达式">常量和常量表达式</a></h1><p><span id="constant_1">constant</span> &quot;常量&quot;是一个与常量表达式值绑定的符号。常量表达式有限制，依赖于以下类别的值和运算，这些值和运算要么内置在语言中，要么在对常量表达式进行语义分析之前被声明和求值。</p>
<ul class="simple"><li>字面值</li>
<li>内置运算符</li>
<li>先前声明的常量和编译期变量</li>
<li>先前声明的宏和模板</li>
<li>先前声明的过程，除了可能修改编译期变量外，没有任何副作用</li>
</ul>
<p>常量表达式可以包含代码块，代码块可以是在编译期内支持的所有Nim特性(详见下面章节)。在其代码块中，可以声明变量，随后读取和更新，或者声明变量并将其传递过程修改。其代码块中的代码，仍须遵守上面列出的关于引用该代码块外的值和运算的限制。</p>
<p>访问和修改编译期变量的能力为常量表达式增加了灵活性，这可能会让了解其他静态类型语言的人感到惊讶。例如，下面的代码在 <strong>编译期</strong> 返回斐波那契数列的起始部分。(这里只是对定义常量灵活性的演示，不是推荐的风格)。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strformat</span>

<span class="Keyword">var</span> <span class="Identifier">fibN</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fibPrev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">fibPrevPrev</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">nextFib</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">fibN</span> <span class="Operator">&lt;</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">fibN</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">fibPrevPrev</span> <span class="Operator">+</span> <span class="Identifier">fibPrev</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">fibN</span><span class="Punctuation">)</span>
  <span class="Identifier">fibPrevPrev</span> <span class="Operator">=</span> <span class="Identifier">fibPrev</span>
  <span class="Identifier">fibPrev</span> <span class="Operator">=</span> <span class="Identifier">result</span>

<span class="Keyword">const</span> <span class="Identifier">f0</span> <span class="Operator">=</span> <span class="Identifier">nextFib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">const</span> <span class="Identifier">f1</span> <span class="Operator">=</span> <span class="Identifier">nextFib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">const</span> <span class="Identifier">displayFib</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">const</span> <span class="Identifier">f2</span> <span class="Operator">=</span> <span class="Identifier">nextFib</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="RawData">fmt&quot;Fibonacci sequence: {f0}, {f1}, {f2}&quot;</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">3.</span><span class="Operator">.</span><span class="DecNumber">12</span><span class="Punctuation">:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="RawData">fmt&quot;, {nextFib()}&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span>

<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">displayFib</span></pre></p>

<h1><a class="toc-backref" id="对编译期执行的限制" href="#对编译期执行的限制">对编译期执行的限制</a></h1><p>编译期执行的Nim代码不能使用以下语言特性:</p>
<ul class="simple"><li>methods 方法</li>
<li>closure iterators 闭包迭代器</li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span></span></tt> 运算符</li>
<li>引用 (指针) 类型</li>
<li>FFI</li>
</ul>
<p>不允许使用 FFI 和/或 <tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span></span></tt> 的包装器。请注意，这也包括标准库中的包装器。</p>
<p>随着时间的推移，可能会取消部分或所有限制。</p>

<h1><a class="toc-backref" id="类型" href="#类型">类型</a></h1><p>Nim是静态类型语言。在语义分析期间，所有的表达式都有一个已知类型。可以声明新的类型，其实质上是定义了一个标识符，用来表示这个自定义类型。</p>
<p>这些是主要的类型分类:</p>
<ul class="simple"><li>序数类型(包括整数、布尔、字符、枚举、枚举子范围)</li>
<li>浮点类型</li>
<li>字符串类型</li>
<li>结构化类型</li>
<li>引用(指针)类型</li>
<li>过程类型</li>
<li>泛型类型</li>
</ul>

<h2><a class="toc-backref" id="类型-序数类型" href="#类型-序数类型">序数类型</a></h2><p>序数类型有以下特征:</p>
<ul class="simple"><li>序数类型是可数的和有序的。因而允许使用如 <tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span></span></tt> 等函数，来操作已定义的序数类型。</li>
<li>序数类型具有最小可使用值，可以通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span><span class="Punctuation">(</span><span class="Keyword">type</span><span class="Punctuation">)</span></span></tt> 获取。尝试从最小值继续减小，会产生panic或静态错误。</li>
<li>序数类型具有最大可使用值，可以通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Keyword">type</span><span class="Punctuation">)</span></span></tt> 获取。尝试从最大值继续增大，会产生panic或静态错误。</li>
</ul>
<p>整数、bool、字符和枚举类型(以及这些类型的子范围)属于序数类型。</p>
<p>如果基类型是序数类型，则distinct类型是序数类型。</p>

<h2><a class="toc-backref" id="类型-预定义整数类型" href="#类型-预定义整数类型">预定义整数类型</a></h2><p>这些整数类型是预定义的:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt></dt>
<dd>常规有符号整数类型，其大小与平台有关，并与指针的大小相同。一般情况下应该使用这种类型。一个没有类型后缀的整数字面量，如果在 <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">int32</span><span class="Punctuation">)</span><span class="Operator">..</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int32</span><span class="Punctuation">)</span></span></tt> 范围内，就属于这种类型，否则该字面量的类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int64</span></span></tt> 。</dd>
<dt><tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>XX</dt>
<dd>这种命名规则，是有符号整数类型附带XX表示位宽(例如：int16是16位宽的整数)。目前支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">int32</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">int64</span></span></tt> ，这些类型的字面值后缀为 'iXX 。</dd>
<dt><tt class="docutils literal"><span class="pre"><span class="Identifier">uint</span></span></tt></dt>
<dd>常规的 <span id="unsigned-integer_1">unsigned integer</span> &quot;无符号整数&quot;类型，它的大小与平台有关，与指针的大小相同，整数字面值后缀为 <tt class="docutils literal"><span class="pre"><span class="CharLit">'u</span></span></tt> 。</dd>
<dt><tt class="docutils literal"><span class="pre"><span class="Identifier">uint</span></span></tt>XX</dt>
<dd>这种命名规则，是无符号整数类型附带XX，表示位宽(例如：uint16是16位宽的无符号整数)，目前支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">uint8</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">uint16</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">uint32</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">uint64</span></span></tt> ，字面值后缀为'uXX'。无符号运算会环绕，从面不会导致溢出或下溢的错误。</dd>
</dl>
<p>除了有符号和无符号整数的常用算术运算符( <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span></span></tt> 等)之外， 还有些运算符可以处理 <em>有符号</em> 整数，但将其参数视为 <em>无符号</em> ，主要用于之后的版本与缺少无符号整数类型的旧版本语言进行兼容。 有符号整数的这些无符号运算约定使用 <tt class="docutils literal"><span class="pre"><span class="Operator">%</span></span></tt> 作为后缀:</p>
<table border="1" class="docutils"><tr><th>运算符</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">+%</span> <span class="Identifier">b</span></span></tt></td><td>无符号整型加法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">-%</span> <span class="Identifier">b</span></span></tt></td><td>无符号整型减法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">*%</span> <span class="Identifier">b</span></span></tt></td><td>无符号整型乘法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">/%</span> <span class="Identifier">b</span></span></tt></td><td>无符号整型除法</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">%%</span> <span class="Identifier">b</span></span></tt></td><td>无符号整型取模</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">&lt;%</span> <span class="Identifier">b</span></span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 与 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">&lt;=%</span> <span class="Identifier">b</span></span></tt></td><td>无符号比较 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 与 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">ze</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt></td><td>用零填充 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 的位，直到它具有 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 类型的宽度</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">toU8</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 视为无符号数值，并将它转成8位无符号整数(但仍是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">toU16</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 视为无符号数值，并将它转成8位无符号整数(但仍是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt> 类型)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">toU32</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 视为无符号数值，并将它转成8位无符号整数(但仍是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int32</span></span></tt> 类型)</td></tr>
</table><p>不同类型整型的表达式中，会执行 <span id="automatic-type-conversion_1">Automatic type conversion</span> &quot;自动类型转换&quot; ，较小的类型转换为较大的类型。</p>
<p><span id="automatic-type-conversion_2">Automatic type conversion</span> &quot;自动类型转换&quot; 将较大的类型转换为较小的类型(比如 <tt class="docutils literal"><span class="pre"><span class="Identifier">int32</span> <span class="Operator">-&gt;</span> <span class="Identifier">int16</span></span></tt> ) ， <span id="widening-type-conversion_1">widening type conversion</span> &quot;扩大类型转换&quot; 将较小的类型转换为较大的类型(比如<tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span> <span class="Operator">-&gt;</span> <span class="Identifier">int32</span></span></tt>) ，Nim中仅有扩大类型转型是 <em>隐式的</em> :</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">myInt16</span> <span class="Operator">=</span> <span class="DecNumber">5</span><span class="Identifier">i16</span>
<span class="Keyword">var</span> <span class="Identifier">myInt</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span>     <span class="Comment"># 为 `int16` 类型</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="Identifier">myInt</span>  <span class="Comment"># 为 `int` 类型</span>
<span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Identifier">i32</span>   <span class="Comment"># 为 `int32` 类型</span></pre></p>
<p>然而，如果字面值适合这个较小类型，并且这样的转换比其他隐式转换更好，那么 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 字面值可以隐式转换为较小的整数类型，因而 <tt class="docutils literal"><span class="pre"><span class="Identifier">myInt16</span> <span class="Operator">+</span> <span class="DecNumber">34</span></span></tt> 结果是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt> 类型。</p>
<p>关于细节查看<a class="reference internal" href="#转换关系">转换关系</a>。</p>

<h2><a class="toc-backref" id="类型-子范围类型" href="#类型-子范围类型">子范围类型</a></h2><p>子范围类型是序数或浮点类型(基类型)的取值范围。要定义子范围类型，必须指定其值的限制，即类型的最低值和最高值。例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Subrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span>
  <span class="Identifier">PositiveFloat</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="Identifier">Inf</span><span class="Punctuation">]</span>
  <span class="Identifier">Positive</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">]</span> <span class="Comment"># 正如 `system` 里定义的一样</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">Subrange</span></span></tt> 是整数的子范围，只能保存0到5的值。<tt class="docutils literal"><span class="pre"><span class="Identifier">PositiveFloat</span></span></tt> 定义了包含所有正浮点数的子范围。 NaN不属于任何浮点类型的子范围。将任何其他值赋值给 <tt class="docutils literal"><span class="pre"><span class="Identifier">Subrange</span></span></tt> 类型产生panic(如果可以在语义分析期间确认，则为静态错误)。 允许将基类型赋值给它的一个子范围类型(反之亦然)。</p>
<p>子范围类型与其基类型具有相同的大小(子范围示例中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> )。</p>

<h2><a class="toc-backref" id="类型-预定义浮点类型" href="#类型-预定义浮点类型">预定义浮点类型</a></h2><p>以下浮点类型是预定义的:</p>
<dl class="docutils"><dt><tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt></dt>
<dd>常规的浮点类型，其大小曾与平台有关，但现在总是被映射为 <tt class="docutils literal"><span class="pre"><span class="Identifier">float64</span></span></tt> 。一般情况下应该使用这个类型。</dd>
<dt><tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt>XX</dt>
<dd>这种命名规则，是浮点类型附带XX位，表示位宽(例如： <tt class="docutils literal"><span class="pre"><span class="Identifier">float64</span></span></tt> 是64位宽的浮点数)。目前支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">float32</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">float64</span></span></tt> ，字面值后缀为 'fXX 。</dd>
</dl>
<p>在具有不同种类的浮点类型的表达式中，会进行自动类型转换，详情见<a class="reference internal" href="#转换关系">转换关系</a>。对于浮点类型进行的算术运算遵循IEEE标准。整数类型不会自动转换为浮点类型，反之亦然。</p>
<p>IEEE标准定义了五种类型的浮点运算异常:</p>
<ul class="simple"><li>无效: 使用数学上无效的操作数运算, 例如 0.0/0.0, sqrt(-1.0), 和log(-37.8).</li>
<li>除以零: 除数为零，且被除数是有限的非零数，例如 1.0 / 0.0 。</li>
<li>溢出: 运算产生的结果超出范围，例如，MAXDOUBLE + 0.0000000000001e308。</li>
<li>下溢: 运算产生的结果太小而无法表示为正常数字，例如，MINDOUBLE * MINDOUBLE。</li>
<li>不精确: 运算产生的结果无法用无限精度表示，例如，输入 2.0 / 3.0，log(1.1) 和 0.1。</li>
</ul>
<p>IEEE异常在执行期被忽略或映射到Nim异常: <span id="floatinvalidopdefect_1">FloatInvalidOpDefect</span> &quot;浮点数无效缺陷&quot; , <span id="floatdivbyzerodefect_1">FloatDivByZeroDefect</span> &quot;浮点数除零缺陷&quot; , <span id="floatoverflowdefect_1">FloatOverflowDefect</span> &quot;浮点数溢出缺陷&quot; , <span id="floatunderflowdefect_1">FloatUnderflowDefect</span> &quot;浮点数下溢缺陷&quot; , 和 <span id="floatinexactdefect_1">FloatInexactDefect</span> &quot;浮点数不精确缺陷&quot; 。 这些异常继承自 <span id="floatingpointdefect_1">FloatingPointDefect</span> &quot;浮点数缺陷&quot; 基类。</p>
<p>Nim提供了编译指示 <span id="nanchecks_1">nanChecks</span> 和 <span id="infchecks_1">infChecks</span> 控制是否忽略IEEE异常或捕获Nim异常:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nanChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">infChecks</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="FloatNumber">1.0</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># 引发 FloatInvalidOpDefect</span>
<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">/</span> <span class="Identifier">b</span> <span class="Comment"># 引发 FloatOverflowDefect</span></pre></p>
<p>在当前的实现中，绝不会引发 <tt class="docutils literal"><span class="pre"><span class="Identifier">FloatDivByZeroError</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">FloatInexactError</span></span></tt> 。 <tt class="docutils literal"><span class="pre"><span class="Identifier">FloatOverflowError</span></span></tt> 取代了 <tt class="docutils literal"><span class="pre"><span class="Identifier">FloatDivByZeroError</span></span></tt> 。 另有 <span id="floatchecks_1">floatChecks</span> 编译指示为 <tt class="docutils literal"><span class="pre"><span class="Identifier">nanChecks</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">infChecks</span></span></tt> 的便捷方式。默认关闭 <tt class="docutils literal"><span class="pre"><span class="Identifier">floatChecks</span></span></tt> 。</p>
<p>只有 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">-</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">/</span></span></tt> 这些运算符会受 <tt class="docutils literal"><span class="pre"><span class="Identifier">floatChecks</span></span></tt> 编译指示影响。</p>
<p>在语义分析期间，应始终使用最大精度来评估浮点数，这表示在常量展开期间，表达式  <tt class="docutils literal"><span class="pre"><span class="FloatNumber">0.09'f32</span> <span class="Operator">+</span> <span class="FloatNumber">0.01'f32</span> <span class="Operator">==</span> <span class="FloatNumber">0.09'f64</span> <span class="Operator">+</span> <span class="FloatNumber">0.01'f64</span></span></tt> 的值为真。</p>

<h2><a class="toc-backref" id="类型-布尔类型" href="#类型-布尔类型">布尔类型</a></h2><p>布尔类型在Nim中命名为 <span id="bool_1">bool</span> ，值为预定义( <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt> )之一。 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 中的状态需为 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 类型.</p>
<p>这种情况成立:<pre>ord(false) == 0 and ord(true) == 1</pre>
</p>
<p>为布尔类型定义了运算符 <tt class="docutils literal"><span class="pre"><span class="Keyword">not</span><span class="Punctuation">,</span> <span class="Keyword">and</span><span class="Punctuation">,</span> <span class="Keyword">or</span><span class="Punctuation">,</span> <span class="Keyword">xor</span><span class="Punctuation">,</span> <span class="Operator">&lt;</span><span class="Punctuation">,</span> <span class="Operator">&lt;=</span><span class="Punctuation">,</span> <span class="Operator">&gt;</span><span class="Punctuation">,</span> <span class="Operator">&gt;=</span><span class="Punctuation">,</span> <span class="Operator">!=</span><span class="Punctuation">,</span> <span class="Operator">==</span></span></tt> 。 <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt> 运算符进行短路求值。例如:</p>
<p><pre class="listing">
<span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果 p == nil， p.name 不被求值</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre></p>
<p>bool类型的大小是一个字节。</p>

<h2><a class="toc-backref" id="类型-字符类型" href="#类型-字符类型">字符类型</a></h2><p>字符类型在Nim中被命名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> 。它的大小为一个字节。因此，它不能表示UTF-8字符，而只能是UTF-8字符的一部分。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">Rune</span></span></tt> 类型声明在<a class="reference external" href="unicode.html">unicode模块</a>中，可以表示任意Unicode字符。</p>

<h2><a class="toc-backref" id="类型-枚举类型" href="#类型-枚举类型">枚举类型</a></h2><p>枚举类型定义了一个其值由指定的值组成的新类型，这些值是有序的。例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span></pre></p>
<p>那么以下是成立的:</p>
<p><pre class="listing">
<span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">north</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">east</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">south</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span>
<span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">west</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">3</span>

<span class="Comment"># 也允许:</span>
<span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">Direction</span><span class="Operator">.</span><span class="Identifier">west</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p>由此可知，north &lt; east &lt; south &lt; west。比较运算符可以与枚举类型一起使用。枚举值也可以使用它所在的枚举类型来限定，如 <tt class="docutils literal"><span class="pre"><span class="Identifier">north</span></span></tt> 可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">Direction</span><span class="Operator">.</span><span class="Identifier">nort</span></span></tt> 来限定。</p>
<p>为了更好地与其他编程语言连接，可以显式为枚举类型字段分配序数值，但是，序数值必须升序排列。未明确给出序数值的字段被赋予前一个字段 +1 的值。</p>
<p>显式有序枚举可以有 <em>间隔</em> :</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">TokenType</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="DecNumber">89</span> <span class="Comment"># 可以有间隔</span></pre></p>
<p>但是，它不再是序数，因此不可能将这些枚举用作数组类型的索引。 过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">pred</span></span></tt> 对于它们不可用。</p>
<p>编译器支持内置的字符串化运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 用于枚举。字符串化的效果是，显式控制要使用的字符串:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;my value A&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
    <span class="Identifier">valueB</span> <span class="Operator">=</span> <span class="StringLit">&quot;value B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valueC</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">,</span>
    <span class="Identifier">valueD</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre></p>
<p>从示例中可以看出，可以通过使用元组指定字段的序数值以及字符串值，也可以只指定其中一个。</p>
<p>枚举可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">pure</span></span></tt> 编译指示进行标记，以便将其字段添加到特定模块特定的隐藏作用域，只在最终尝试时进行查询。 只有没有歧义的符号才会添加到此作用域。但总是可以通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">value</span></span></tt> 类型限定来访问:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>
  
  <span class="Identifier">OtherEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueX</span><span class="Punctuation">,</span> <span class="Identifier">valueY</span><span class="Punctuation">,</span> <span class="Identifier">valueZ</span><span class="Punctuation">,</span> <span class="Identifier">amb</span>


<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># MyEnum.valueA</span>
<span class="Identifier">echo</span> <span class="Identifier">amb</span>    <span class="Comment"># 错误: 不确定它是MyEnum.amb还是OtherEnum.amb</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">amb</span> <span class="Comment"># OK.</span></pre></p>
<p>枚举值的名称是可重载的，就像例程。如果枚举 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">U</span></span></tt> 都有一个名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 的成员，那么标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 要在 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">foo</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">U</span><span class="Operator">.</span><span class="Identifier">foo</span></span></tt> 之间二选一。在重载解析过程中， <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 的最终类型由上下文决定。如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 的类型不明确，将产生静态错误。</p>
<p><pre class="listing">

<span class="Keyword">type</span>
  <span class="Identifier">E1</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">value1</span><span class="Punctuation">,</span>
    <span class="Identifier">value2</span>
  <span class="Identifier">E2</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">value1</span><span class="Punctuation">,</span>
    <span class="Identifier">value2</span> <span class="Operator">=</span> <span class="DecNumber">4</span>

<span class="Keyword">const</span>
  <span class="Identifier">Lookuptable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">E1</span><span class="Operator">.</span><span class="Identifier">value1</span><span class="Punctuation">:</span> <span class="StringLit">&quot;1&quot;</span><span class="Punctuation">,</span>
    <span class="Comment"># 不需要再修饰value2，已经知道是E1.value2。</span>
    <span class="Identifier">value2</span><span class="Punctuation">:</span> <span class="StringLit">&quot;2&quot;</span>
  <span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">E1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 在 'case' 语句中消除歧义。</span>
  <span class="Keyword">case</span> <span class="Identifier">e</span>
  <span class="Keyword">of</span> <span class="Identifier">value1</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>
  <span class="Keyword">of</span> <span class="Identifier">value2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>

<span class="Identifier">p</span> <span class="Identifier">value2</span></pre></p>
<p>对于用枚举实现位域，请查看<a class="reference internal" href="#集合类型-位域">位域</a>部分。</p>

<h2><a class="toc-backref" id="类型-字符串类型" href="#类型-字符串类型">字符串类型</a></h2><p>所有字符串字面值都是 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 类型。Nim中的字符串与字符序列非常相似。但是，Nim中的字符串都是以零结尾，并且具有长度字段。 可以用内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> 过程检索长度，长度并不计算末尾的零。</p>
<p>除非先将字符串转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 类型，否则无法访问末尾的零。末尾零可以保证在 O(1) 完成转换，而无需另行分配。</p>
<p>字符串的赋值运算符始终复制字符串。 <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> 运算符拼接字符串。</p>
<p>大多数原生Nim类型支持使用特殊的 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 过程转换为字符串。</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="DecNumber">3</span> <span class="Comment"># 为 `int` 调用 `$`</span></pre></p>
<p>每当用户创建特定的对象时，该过程实现提供了 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 表示。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># `$` 始终返回字符串</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; 已经 &quot;</span> <span class="Operator">&amp;</span>
          <span class="Operator">$</span><span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">&amp;</span> <span class="Comment"># 需要在p.age前添加`$`，因为它是整数类型，而我们要将其转换成字符串</span>
          <span class="StringLit">&quot;岁了。&quot;</span></pre></p>
<p>虽然也可以使用 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span><span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span></span></tt> ，但 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 操作符不会对字符串做任何事。请注意，不能依赖 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 到 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 像 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> 过程一样自动转换。</p>
<p>字符串按字典顺序进行比较，所有比较运算符都可用。字符串可以像数组一样索引(下限为0)。与数组不同的是，字符串可用于case语句:</p>
<p><pre class="listing">
<span class="Keyword">case</span> <span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-v&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optVerbose</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;-h&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;-?&quot;</span><span class="Punctuation">:</span> <span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">options</span><span class="Punctuation">,</span> <span class="Identifier">optHelp</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;非法的命令行选项</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span></pre></p>
<p>按照约定，所有字符串都是UTF-8格式，但这不是强制的要求。例如，从二进制文件读取字符串时，得到的将是字节序列。索引运算 <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 表示 <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span></span></tt> 的第i个<em>char</em>，而不是第i个 <em>unichar</em> 。在<a class="reference external" href="unicode.html">unicode模块</a>的迭代器 <tt class="docutils literal"><span class="pre"><span class="Identifier">runes</span></span></tt> 可用来迭代所有unicode字符。</p>

<h2><a class="toc-backref" id="类型-cstring类型" href="#类型-cstring类型">cstring类型</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 类型意思是 <tt class="docutils literal"><span class="pre"><span class="Identifier">compatible</span> <span class="Identifier">string</span></span></tt> &quot;兼容字符串&quot;，是编译后端字符串的原生表示。对于C后端， <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 类型表示一个指向末尾为零的char数组的指针，该数组与ANSI C中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span><span class="Operator">*</span></span></tt> 类型兼容。其主要目的在于与C轻松互通。索引操作 <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 表示 s 的第i个 <em>char</em> ;但是没有检查 cstring 的边界，导致索引操作并不安全。</p>
<p>为方便起见，Nim中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 可以隐式转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 。如果将Nim字符串传递给C风格的可变参数过程，它也会隐式转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Punctuation">,</span>
                                  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;这会%s工作&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;像预期一样&quot;</span><span class="Punctuation">)</span></pre></p>
<p>即使转换是隐式的，它也不是 <em>安全的</em> : 垃圾收集器不认为 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 是根，并且可能收集底层内存。因此，隐式转换将在Nim编译器的未来版本中删除。某些习语，例如将 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 字符串转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 是安全的，并且仍将被允许。</p>
<p>为cstring定义的 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 过程能够返回string。因此，从cstring获得nim的string可以这样:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello!&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">cstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">str</span>
<span class="Keyword">var</span> <span class="Identifier">newstr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">cstr</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 字面值不应被修改。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="RawData">cstring&quot;literals&quot;</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'A'</span> <span class="Comment"># 这是错的！！！</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 来自常规内存(而不是只读内存)，则可被修改:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;123456&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="CharLit">'u'</span> <span class="Comment"># 这是可以的</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 值像字符串一样，也可用于case语句。</p>

<h2><a class="toc-backref" id="类型-结构化类型" href="#类型-结构化类型">结构化类型</a></h2><p>结构化类型的变量可以同时保存多个值。 结构化类型可以嵌套到无限级别。数组、序列、元组、对象和集合属于结构化类型。</p>

<h2><a class="toc-backref" id="类型-数组和序列类型" href="#类型-数组和序列类型">数组和序列类型</a></h2><p>数组是同类型的，即数组中的每个元素都类型相同。数组总是具有指定为常量表达式的固定长度(开放数组除外)。它们可以按任意序数类型索引。若参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span></span></tt> 是 <em>开放数组</em> ，那么它的索引为由0到 len(A)- 1 的整数。数组表达式可以由数组构造器 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 构造。数组表达式的元素类型是从第一个元素的类型推断出来的。所有其他元素都需要隐式转换为此类型。</p>
<p>可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">size</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 构造数组类型，也可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">lo</span><span class="Operator">..</span><span class="Identifier">hi</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 设置数组的起点，而不是默认的0。</p>
<p>序列类似于数组，但有动态长度，其长度可能在运行时期间发生变化(如字符串)。序列为可增长的数组实现，在添加项目时分配内存块。序列 <tt class="docutils literal"><span class="pre"><span class="Identifier">S</span></span></tt> 的索引为从0到 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">S</span><span class="Punctuation">)</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 的整数，并检查其边界。序列可以在序列运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">@</span></span></tt> 的帮助下，结合数组构造器 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 一起构造。为序列分配空间的另一种方法是调用内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">newSeq</span></span></tt> 过程。</p>
<p>序列可以传递给 <em>开放数组</em> 类型的参数。</p>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 索引为0到5的数组</span>
  <span class="Identifier">IntSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 一个整数序列</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">IntSeq</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>  <span class="Comment"># [] 是数组构造器</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment">#  @ 会将数组转换成序列</span>

<span class="Keyword">let</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="FloatNumber">1.0</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Comment"># z的类型是 array[0..3, float]</span></pre></p>
<p>数组或序列的下限可以用内置的过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 获取，上限用 <tt class="docutils literal"><span class="pre"><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 获取。 长度可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 获取。序列或开放数组的 <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 总是返回0，因为这是第一个有效索引。可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 过程或 <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> 运算符将元素追加到序列中，并使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 过程删除(并获取)序列的最后一个元素。</p>
<p>符号 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 可用于访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的第i个元素。</p>
<p>数组始终进行边界检查(静态或运行时)。可以通过编译指示禁用这些检查，或调用编译器时，使用 <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">boundChecks</span><span class="Punctuation">:</span><span class="Identifier">off</span></span></tt> 命令行开关。</p>
<p>数组构造器可以具有可读的显式索引:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valB</span><span class="Punctuation">:</span> <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span>
  <span class="Punctuation">]</span></pre></p>
<p>如果省略索引，则使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span><span class="Punctuation">(</span><span class="Identifier">lastIndex</span><span class="Punctuation">)</span></span></tt> 作为索引值:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Values</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valA</span><span class="Punctuation">,</span> <span class="Identifier">valB</span><span class="Punctuation">,</span> <span class="Identifier">valC</span><span class="Punctuation">,</span> <span class="Identifier">valD</span><span class="Punctuation">,</span> <span class="Identifier">valE</span>

<span class="Keyword">const</span>
  <span class="Identifier">lookupTable</span> <span class="Operator">=</span> <span class="Punctuation">[</span>
    <span class="Identifier">valA</span><span class="Punctuation">:</span> <span class="StringLit">&quot;A&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;B&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">valC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;C&quot;</span><span class="Punctuation">,</span>
    <span class="StringLit">&quot;D&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;e&quot;</span>
  <span class="Punctuation">]</span></pre></p>

<h2><a class="toc-backref" id="类型-开放数组" href="#类型-开放数组">开放数组</a></h2><p>通常，固定大小的数组不太灵活，程序应该能够处理不同大小的数组。 <span id="openarray_1">openarray</span> &quot;开放数组&quot; 类型只能用于参数。开放数组总是从位置0开始用 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 索引。也可用 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">low</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">high</span></span></tt> 操作。具有兼容基类型的任何数组都可以传递给开放数组的形参，不关乎索引类型。除了数组之外，还可以将序列传递给开放数组参数。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">openarray</span></span></tt> 类型不能嵌套: 不支持多维开放数组，因为这种需求很少且不高效。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># array[]</span>
<span class="Identifier">testOpenArray</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># seq[]</span></pre></p>

<h2><a class="toc-backref" id="类型-可变参数" href="#类型-可变参数">可变参数</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 参数是一个开放数组参数，它允许将可变数量的参数传递给过程。编译器隐式地将参数列表转换为数组:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># 转换成:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>仅当 <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 参数是最后一个参数时，才会执行此转换。在这种情况下也可以执行类型转换:<pre>```nim
proc myWriteln(f: File, a: varargs[string, `$`]) =
  for s in items(a):
    write(f, s)
  write(f, &quot;\n&quot;)

myWriteln(stdout, 123, &quot;abc&quot;, 4.0)
# 转换成:
myWriteln(stdout, [$123, $&quot;abc&quot;, $4.0])
```</pre>
</p>
<p>在这个例子中， <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 应用于传递给参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 的任意参数。 (注意 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 对字符串是一个空操作。)</p>
<p>请注意，传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 形参的显式数组构造器不会隐式地构造另一个隐式数组:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">takeV</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">takeV</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># takeV的T是&quot;int&quot;, 不是&quot;int数组&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">]</span></span></tt> 被特别对待: 它匹配任意类型参数的变量列表，但 <em>始终</em> 构造一个隐式数组。这是必需的，只有这样，内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> 过程才能够执行预期的操作:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">echo</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">...</span><span class="Punctuation">}</span>

<span class="Identifier">echo</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Comment"># 输出 &quot;@[1, 2, 3]&quot; 而不是 &quot;123&quot;</span></pre></p>

<h2><a class="toc-backref" id="类型-未检查数组" href="#类型-未检查数组">未检查数组</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">UncheckedArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 类型是一种特殊的 <tt class="docutils literal"><span class="pre"><span class="Identifier">array</span></span></tt> &quot;数组&quot;，编译器不检查它的边界。这对于实现定制灵活大小的数组通常很有用。另外，未检查数组可以这样转换为不确定大小的C数组:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">UncheckedArray</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span></pre></p>
<p>生成的C代码大致是这样的:</p>
<p><pre class="listing">
<span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre></p>
<p>未检查数组的基本类型可能不包含任何GC内存，但目前尚未检查。</p>
<p><strong>未来方向</strong>: 应该在未检查的数组中允许GC内存，并且应该有一个关于GC如何确定数组的运行时大小的显式注解。</p>

<h2><a class="toc-backref" id="类型-元组和对象类型" href="#类型-元组和对象类型">元组和对象类型</a></h2><p>元组或对象类型的变量是异构存储容器。元组或对象定义了一个类型的各类 <em>字段</em> 。元组还定义了字段的 <em>顺序</em> 。元组是有很少抽象可能性的异构存储类型。 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 可用于构造元组。构造函数中字段的顺序必须与元组定义的顺序相匹配。如果它们以相同的顺序指定相同类型的相同字段，则不同的元组类型 <em>等效</em> 。字段的 <em>名称</em> 也必须相同。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># 表示人的类型:</span>
                                         <span class="Comment"># 由名字和年龄组成。</span>
<span class="Keyword">var</span> <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Peter&quot;</span>
<span class="Comment"># 一样，但可读性不太好</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="StringLit">&quot;Peter&quot;</span>
<span class="Identifier">assert</span> <span class="Identifier">Person</span> <span class="Keyword">is</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span> <span class="Identifier">Person</span> <span class="Keyword">isnot</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">other</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># `other` 是不同的标识符</span></pre></p>
<p>可以使用括号和尾随逗号，构造具有一个未命名字段的元组:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">echoUnaryTuple</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">echoUnaryTuple</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="Punctuation">)</span></pre></p>
<p>事实上，每个元组结构都允许使用尾随逗号。</p>
<p>字段将会对齐，以此获得最佳性能。对齐与C编译器的方式兼容。</p>
<p>为了与 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 声明保持一致， <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 部分中的元组也可以用缩进而不是 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 来定义:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>   <span class="Comment"># 代表人的类型</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>   <span class="Comment"># 人的名字</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">Natural</span>   <span class="Comment"># 和年龄</span></pre></p>
<p>对象提供了许多元组没有的特性。对象提供继承和隐藏其他模块字段的能力。启用继承的对象在运行时具有相关类型的信息，可以使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 运算符来确定对象的类型。<tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 运算符类似于 Java 中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">instanceof</span></span></tt> 运算符。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>   <span class="Comment"># *表示可以从其他模块访问 `name`</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 没有*表示该字段已隐藏</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># 学生是人</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># 有个id字段</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span>  <span class="Comment"># 是真</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Person</span><span class="Punctuation">)</span>   <span class="Comment"># 也是真</span></pre></p>
<p>对模块外部可见的对象字段必须用 <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt> 标记。与元组相反，不同的对象类型永远不会 <em>等价</em> 。没有祖先的对象是隐式的 <tt class="docutils literal"><span class="pre"><span class="Identifier">final</span></span></tt> ，因此没有隐藏的类型字段。可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">inheritable</span></span></tt> 编译指示来引入除 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">RootObj</span></span></tt> 之外的新根对象。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># final 对象的例子</span>
    <span class="Identifier">name</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># 错误: 继承只能用于非final对象</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>对于元组和对象的赋值操作，将拷贝每个组件。 重写这种拷贝行为的方法描述在<a class="reference internal" href="#过程-类型绑定操作符">这里</a>。</p>

<h2><a class="toc-backref" id="类型-对象构造" href="#类型-对象构造">对象构造</a></h2><p>对象也可以使用 <span id="object-construction-expression_1">object construction expression</span> &quot;对象构建表达式&quot; 创建, 即以下语法 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span><span class="Punctuation">(</span><span class="Identifier">fieldA</span><span class="Punctuation">:</span> <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">fieldB</span><span class="Punctuation">:</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt> 其中 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 类型或 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Keyword">object</span></span></tt> 类型:</p>
<p><pre class="listing">
 <span class="Keyword">type</span>
   <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">object</span>
     <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
     <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
   <span class="Identifier">PStudent</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">Student</span>
 <span class="Keyword">var</span> <span class="Identifier">a1</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>
 <span class="Keyword">var</span> <span class="Identifier">a2</span> <span class="Operator">=</span> <span class="Identifier">PStudent</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>
 <span class="Comment"># 这样也可以直接构造:</span>
 <span class="Keyword">var</span> <span class="Identifier">a3</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">Student</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>
 <span class="Comment"># 不是所有字段都必须被提到，而且这些字段可以是乱序的:</span>
 <span class="Keyword">var</span> <span class="Identifier">a4</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">)</span></pre></p>
<p>请注意，与元组不同，对象需要字段名称及其值。对于 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Keyword">object</span></span></tt> 类型， <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">new</span></span></tt> 是隐式调用的。</p>

<h2><a class="toc-backref" id="类型-对象变体" href="#类型-对象变体">对象变体</a></h2><p>在需要简单变体类型的某些情况下，对象层次结构通常有点臃肿。对象变体是通过枚举类型标记和区分，以便运行时更加灵活，可参照在其他语言中能找到的如 <em>sum类型</em> 和 <em>代数数据类型(ADTs)</em> 的概念。</p>
<p>一个例子:</p>
<p><pre class="listing">
<span class="Comment"># 这是一个如何在Nim中建模抽象语法树的示例</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>   <span class="Comment"># 不同的节点类型</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># 带有整数值的叶节点</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># 带有浮点值的叶节点</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># 带有字符串值的叶节点</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># 加法</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># 减法</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># if语句</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># `kind` 字段是鉴别字段</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Comment"># 创建一个新case对象:</span>
<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkIf</span><span class="Punctuation">,</span> <span class="Identifier">condition</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">)</span>
<span class="Comment"># 访问 `n.thenPart` 是有效的，因为 `nkIf` 分支是活动的</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">thenPart</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">2.0</span><span class="Punctuation">)</span>

<span class="Comment"># 以下语句引发了一个 `FieldError` 异常，因为n.kind的值不合适且 `nkString` 分支未激活:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span>

<span class="Comment"># 无效:会更改活动对象分支:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkInt</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 有效:不更改活动对象分支:</span>
<span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span></pre></p>
<p>从示例中可以看出，对象层次结构的优点是，不需要在不同对象类型之间进行转换。但是，访问无效对象字段会引发异常。</p>
<p>在对象声明中的 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句和标准 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句语法一致: <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句的分支也是如此。</p>
<p>在示例中， <tt class="docutils literal"><span class="pre"><span class="Identifier">kind</span></span></tt> 字段称为 <span id="discriminator_1">discriminator</span> &quot;鉴别字段&quot; ，为安全起见，不能对其进行地址限制，并且对其赋值进行限制: 新值不得导致活动对象分支发生变化。 此外，在对象构造期间指定特定分支的字段时，必须将相应的鉴别字段值指定为常量表达式。</p>
<p>与改变活动的对象分支不同，可以将内存中的旧对象换成一个全新的对象。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
                          <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkInt</span><span class="Punctuation">,</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># 改变节点的内容</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">NodeObj</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkString</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre></p>
<p>从版本0.20开始 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">reset</span></span></tt> 不能再用于支持对象分支的更改，因为这始终不是完全内存安全的。</p>
<p>作为一项特殊规则，鉴别字段类型也可以使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句来限制。如果 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句分支中的鉴别字段变量的可能值是所选对象分支的鉴别字段值的子集，则认为是有效的初始化。此分析仅适用于序数类型的不可变判别符，并忽略 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 分支。对于具有 <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span></span></tt> 类型的鉴别器值，编译器会检查鉴别器值的整个可能值范围是否对所选对象分支有效。</p>
<p>一个小例子:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">unknownKind</span> <span class="Operator">=</span> <span class="Identifier">nkSub</span>

<span class="Comment"># 无效:不安全的初始化，因为类型字段不是静态已知的:</span>
<span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">unknownKind</span>
<span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
  <span class="Comment"># 有效:此分支的可能值是nkAdd / nkSub对象分支的子集:</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKind</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;ignoring: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">unknownKind</span>

<span class="Comment"># 同样有效, 因为 unknownKindBounded 只包含 nkAdd 或 nkSub</span>
<span class="Keyword">let</span> <span class="Identifier">unknownKindBounded</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="Identifier">nkAdd</span><span class="Operator">..</span><span class="Identifier">nkSub</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">unknownKind</span><span class="Punctuation">)</span>
<span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">unknownKindBounded</span><span class="Punctuation">,</span> <span class="Identifier">leftOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="类型-cast-uncheckedassign" href="#类型-cast-uncheckedassign">cast uncheckedAssign</a></h2><p>case对象的一些限制可以通过 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">uncheckedAssign</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 禁用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">TokenKind</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">strLit</span><span class="Punctuation">,</span> <span class="Identifier">intLit</span>
  <span class="Identifier">Token</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">TokenKind</span>
    <span class="Keyword">of</span> <span class="Identifier">strLit</span><span class="Punctuation">:</span>
      <span class="Identifier">s</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">intLit</span><span class="Punctuation">:</span>
      <span class="Identifier">i</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">int64</span>

<span class="Keyword">proc</span> <span class="Identifier">passToVar</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">TokenKind</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">Token</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">strLit</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">uncheckedAssign</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Comment"># 在 'cast' 块中允许将 't.kind' 传递给 'var T' 参数:</span>
  <span class="Identifier">passToVar</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">)</span>
  
  <span class="Comment"># 在 'cast' 块中允许设置字段 's' ,即便构造的 'kind' 字段有未知的值</span>
  <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">Token</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span>
  
  <span class="Comment"># 在 'cast' 块中允许直接分配 't.kind' 字段</span>
  <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">=</span> <span class="Identifier">intLit</span></pre></p>

<h2><a class="toc-backref" id="类型-集合类型" href="#类型-集合类型">集合类型</a></h2>集合类型是数学概念集合的模型。集合的基础类型只能是具有一定大小的序数类型，即:<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">uint8</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">byte</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">uint16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">enum</span></span></tt></li>
</ul>
<p>或等价物。对于有符号的整数，集合的基础类型被定义为 <tt class="docutils literal"><span class="pre"><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">MaxSetElements</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 的范围，其中 <tt class="docutils literal"><span class="pre"><span class="Identifier">MaxSetElements</span></span></tt> 目前总是 2^16 。</p>
<p>原因是集合被实现为高性能的bit vector。 试图用太大类型来声明集合将导致一个错误:</p>
<p><pre class="listing">
  
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># 错误: 集合太大，使用 `std/sets` 处理超过 2^16 元素的序数类型</span>
</pre></p>
<p><strong>注意:</strong> Nim还提供了<a class="reference external" href="set.html">hash sets</a>(你需要用 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">sets</span></span></tt> 导入)，它没有这样的限制。</p>
<p>集合可以通过集合构造器来构造: <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">}</span></span></tt> 是空集。空集的类型与任何具体的集合类型兼容。 构造器也可以用来包含元素(和元素范围)。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 这构建了一个包含从'a' 到 'z' 的字母和从 '0' 到 '9' 的数字的集合。</span></pre></p>
<p>集合支持以下操作。</p>
<table border="1" class="docutils"><tr><th>运算</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">+</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的并集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">*</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的交集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">-</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的差集(A不包含B的元素)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">==</span> <span class="Identifier">B</span></span></tt></td><td>集合相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;=</span> <span class="Identifier">B</span></span></tt></td><td>子集关系(A是B的子集或等于B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;</span> <span class="Identifier">B</span></span></tt></td><td>严格子集关系(A是B的真子集)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">in</span> <span class="Identifier">A</span></span></tt></td><td>集合成员关系(A包含元素e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">notin</span> <span class="Identifier">A</span></span></tt></td><td>A不包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">contains</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></span></tt></td><td>A包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">card</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">)</span></span></tt></td><td>A的基数(A中元素的数量)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>相同于 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">+</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">excl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>相同于 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">-</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="集合类型-位域" href="#集合类型-位域">位域</a></h3><p>集合经常被用来为过程的 <em>标记</em> 定义类型。 这是比定义整数常量更利落的解决方案(而且类型安全)，因为整数常量必须被 <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt> &quot;或&quot;在一起。</p>
<p>enum、set和cast可以像下面这样一起使用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre></p>
<p>要注意set是怎样将枚举值转换为2的幂值。</p>
<p>如果在C中使用枚举和集合，请使用distinct cint。</p>
<p>关于与C语言的互操作性，参阅<a class="reference external" href="manual.html#implementation-specific-pragmas-bitsize-pragma">bitsize 编译指示</a>。 </p>

<h2><a class="toc-backref" id="类型-引用和指针类型" href="#类型-引用和指针类型">引用和指针类型</a></h2><p>引用(类似于其他编程语言中的指针)是引入多对一关系的一种方式。这意味着不同的引用可以指向并修改内存中的相同位置(也称为 <span id="aliasing_1">aliasing</span> &quot;别名&quot;)。</p>
<p>Nim区分 <span id="traced_1">traced</span> &quot;追踪&quot;、<span id="untraced_1">untraced</span> &quot;未追踪&quot; 引用。未追踪引用也叫 <em>指针</em> 。追踪引用指向垃圾回收堆中的对象，未追踪引用指向手动分配对象或内存中其它位置的对象。因此，未追踪引用是 <em>不安全</em> 的。 然而对于某些访问硬件的低级操作，未追踪引用是不可避免的。</p>
<p>使用 <strong>ref</strong> 关键字声明追踪引用，使用 <strong>ptr</strong> 关键字声明未追踪引用。通常， <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">T</span></span></tt> 可以隐式转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">pointer</span></span></tt> 类型。</p>
<p>空的下标 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 表示法可以用来取代引用， <tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 过程返回一个对象的地址。地址始终是未追踪的引用。因此， <tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 的使用是 <em>不安全的</em> 功能。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> (访问元组和对象字段运算符)和 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> (数组/字符串/序列索引运算符)运算符对引用类型执行隐式解引用操作:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="DecNumber">9</span>
<span class="Comment"># 不必写n[].data; 非常不推荐 n[].data！</span></pre></p>
<p>可以对例程调用的第一个参数进行自动去引用，但这是一个实验性功能，描述在<a class="reference external" href="manual_experimental.html#automatic-dereferencing">这里</a>。</p>
<p>为了简化结构类型检查，递归元组无效:</p>
<p><pre class="listing">
<span class="Comment"># 无效递归</span>
<span class="Keyword">type</span> <span class="Identifier">MyTuple</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">MyTuple</span><span class="Punctuation">]</span></pre></p>
<p>同样， <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">T</span></span></tt> 是无效类型。</p>
<p>作为语法扩展，如果在类型部分中通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Keyword">object</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Keyword">object</span></span></tt> 符号声明，则 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 类型可以是匿名的。当一个对象只能获得引用语义时，这个特性很有用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>要分配一个新的追踪对象，必须使用内置的过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">new</span></span></tt> 。可以使用过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">dealloc</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">realloc</span></span></tt> 来处理未追踪的内存。更多信息，查看<a class="reference external" href="system.html">系统</a>模块文档。</p>

<h2><a class="toc-backref" id="类型-空-nil" href="#类型-空-nil">空(Nil)</a></h2><p>如果一个引用什么都不指向，那么它的值为 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> 。 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> 是所有 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt> 类型的默认值。<tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> 值也可以像任何其他字面值一样使用。例如，它可以用在像 <tt class="docutils literal"><span class="pre"><span class="Identifier">my</span> <span class="Keyword">Ref</span> <span class="Operator">=</span> <span class="Keyword">nil</span></span></tt> 这样的赋值中。</p>
<p>解引用 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> 是一个不可恢复的运行时错误(而不是panic)。</p>
<p>成功的解引用操作 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 意味着 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 不是 nil。可以利用它来优化代码，例如:</p>
<p><pre class="listing">
<span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Keyword">if</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
  <span class="Comment"># 如果p是nil, 那么 `p[]` 会导致错误</span>
  <span class="Comment"># 所以我们知道这里`p`永远不会是nil</span>
  <span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>那么上述代码可以变成:</p>
<p><pre class="listing">
<span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="DecNumber">3</span>
<span class="Identifier">action</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p><em>注意</em>: 这与 C 用于解引用 NULL 指针的 &quot;未定义行为&quot; 不具有可比性。</p>

<h2><a class="toc-backref" id="类型-混合gc内存和-nimptr" href="#类型-混合gc内存和-nimptr">混合GC内存和 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt></a></h2><p>特别要注意的是，如果一个未被追踪的对象包含被追踪的对象，例如包含追踪的引用，字符串，或序列。为了正确释放所有对象， 在释放未被追踪的内存之前，需要手动调用内置过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">reset</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Comment"># 在堆上为Data分配内存:</span>
<span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">Data</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc0</span><span class="Punctuation">(</span><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Comment"># 在垃圾回收(GC)堆上创建一个新的字符串:</span>
<span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>

<span class="Comment"># 告知GC不再需要这个字符串:</span>
<span class="Identifier">reset</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Comment"># 释放内存:</span>
<span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">d</span><span class="Punctuation">)</span></pre></p>
<p>如果不调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">reset</span></span></tt> ，就绝不会释放分配给 <tt class="docutils literal"><span class="pre"><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span></span></tt> 字符串的内存。这个例子从程序底层来说，表现出两个重要的特性: <tt class="docutils literal"><span class="pre"><span class="Identifier">sizeof</span></span></tt> 过程返回一个类型或值的字节大小。 <tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span></span></tt> 操作符可以避开类型系统: 编译器强制将 <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc0</span></span></tt> (会返回一个未定义类型的指针)的结果认定为 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">Data</span></span></tt> 类型。只有在不可避免的情况下才需要进行转换，因为它破坏了类型安全，未知的bug可能导致崩溃。</p>
<p><strong>注意</strong>: 当把垃圾收集的数据和非管理的内存混合在一起时，我们需要了解这样的低级细节。这个例子之所以有效，是因为 <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc0</span></span></tt> 将内存初始化为零，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc</span></span></tt> 不会 。 <tt class="docutils literal"><span class="pre"><span class="Identifier">d</span><span class="Operator">.</span><span class="Identifier">s</span></span></tt> 被初始化为二进制的零，因而可以处理字符串赋值。</p>

<h2><a class="toc-backref" id="类型-过程类型" href="#类型-过程类型">过程类型</a></h2><p>过程类型是指向过程的内部指针。过程类型变量允许赋值 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt> 。</p>
<p>示例:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printItem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Identifier">forEach</span><span class="Punctuation">(</span><span class="Identifier">printItem</span><span class="Punctuation">)</span>  <span class="Comment"># 将不会编译这个，因为调用约定不同</span></pre></p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">OnMouseMove</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">onMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 有默认的调用约定</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseX</span><span class="Punctuation">,</span> <span class="StringLit">&quot; y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">mouseY</span>

<span class="Keyword">proc</span> <span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">mouseMoveEvent</span><span class="Punctuation">:</span> <span class="Identifier">OnMouseMove</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 'onMouseMove' 有默认的调用约定 可以兼容 'closure':</span>
<span class="Identifier">setOnMouseMove</span><span class="Punctuation">(</span><span class="Identifier">onMouseMove</span><span class="Punctuation">)</span></pre></p>
<p>过程类型的一个底层细节问题是，过程的调用约定会影响类型的兼容性: 过程类型只有在调用约定相同的情况下才兼容。有个延伸的特例，调用约定为 <tt class="docutils literal"><span class="pre"><span class="Identifier">nimcall</span></span></tt> 的过程可以被传递给期望调用约定为 <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> 的过程参数。</p>
<p>Nim支持下列 <span id="calling-conventions_1">calling conventions</span> &quot;调用约定&quot;:</p>
<dl class="docutils"><dt><span id="nimcall_1">nimcall</span></dt>
<dd>是Nim <strong>proc</strong> 使用的默认约定。它与 <tt class="docutils literal"><span class="pre"><span class="Identifier">fastcall</span></span></tt> 相同，但只适用于支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">fastcall</span></span></tt> 的C编译器。</dd>
<dt><span id="closure_1">closure</span></dt>
<dd>是 <strong>程序类型</strong> 没有任意编译指示注解的默认调用约定，该过程有一个隐藏参数( <em>environment</em> &quot;环境&quot;)。具有 <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> 调用约定的过程变体占用两个机器字。一个是过程的指针，另一个是指向隐藏参数环境的指针。</dd>
<dt><span id="stdcall_1">stdcall</span></dt>
<dd>这是由微软指定的标准调用惯例，生成的C过程将用 <tt class="docutils literal"><span class="pre"><span class="Identifier">__stdcall</span></span></tt> 关键字声明。</dd>
<dt><span id="cdecl_1">cdecl</span></dt>
<dd>其意味着一个过程应使用与C编译器相同的约定。在Windows中，将用 <tt class="docutils literal"><span class="pre"><span class="Identifier">__cdecl</span></span></tt> 关键字声明生成的C过程。</dd>
<dt><span id="safecall_1">safecall</span></dt>
<dd>这是由微软指定的安全调用约定，将用 <tt class="docutils literal"><span class="pre"><span class="Identifier">__safecall</span></span></tt> 关键字声明生成的C程序。 <em>安全</em> 这个词是指所有的硬件寄存器都应被push到硬件堆栈中。</dd>
<dt><span id="inline_1">inline</span></dt>
<dd>内联约定表示调用者不应该调用过程，而是直接内联其代码。需注意，Nim自身并不内联，而是留给C编译器，它将生成 <tt class="docutils literal"><span class="pre"><span class="Identifier">__inline</span></span></tt> 过程，这只是给编译器的提示，编译器则可能忽略，也可能内联那些没有 <tt class="docutils literal"><span class="pre"><span class="Identifier">inline</span></span></tt> 的过程。</dd>
<dt><span id="fastcall_1">fastcall</span></dt>
<dd>对于不同的C编译器其含义不同，有一种是表示C语言中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">__fastcall</span></span></tt> 。</dd>
<dt><span id="thiscall_1">thiscall</span></dt>
<dd>这是微软指定的调用约定，应用于x86架构上C++类的成员函数。</dd>
<dt><span id="syscall_1">syscall</span></dt>
<dd>其与C语言中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">__syscall</span></span></tt> 相同，用于中断。</dd>
<dt><span id="noconv_1">noconv</span></dt>
<dd>其生成的C代码将不会去明确调用约定，将使用C编译器自身的默认调用约定。这是有必要的，因为Nim过程的默认调用约定是 <tt class="docutils literal"><span class="pre"><span class="Identifier">fastcall</span></span></tt> 以提高速度。</dd>
</dl>
<p>大多数调用约定只存在于32位Windows平台。</p>
<p>默认的调用约定是 <tt class="docutils literal"><span class="pre"><span class="Identifier">nimcall</span></span></tt> ，除非它是一个内部过程(一个过程中的过程)。对于一个内部过程，将分析它是否访问其环境，如果它访问了环境，就采用 <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> 调用约定，否则就采用 <tt class="docutils literal"><span class="pre"><span class="Identifier">nimcall</span></span></tt> 调用约定。</p>

<h2><a class="toc-backref" id="类型-distinct类型" href="#类型-distinct类型">Distinct类型</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">distinct</span></span></tt> 类型是源于 <span id="base-type_1">base type</span> &quot;基类&quot;的新类型，一个重要的特性是，它和它的基类型之间 <strong>不</strong> 是子类型关系。但允许显式将distinct类型转换到它的基类型，反之亦然。请参阅 <tt class="docutils literal"><span class="pre"><span class="Identifier">distinctBase</span></span></tt> 以获得反向操作相关的信息。</p>
<p>如果基类型是序数类型，则distinct类型是序数类型。</p>

<h3><a class="toc-backref" id="distinct类型-模拟货币" href="#distinct类型-模拟货币">模拟货币</a></h3><p>distinct类型可用于模拟不同的物理 <span id="units_1">units</span> &quot;单位&quot;，例如，数字基本类型。以下为模拟货币的示例。</p>
<p>在货币计算中不应混用不同的货币。Distinct类型是一个模拟不同货币的理想工具:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Dollar</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>
  <span class="Identifier">Euro</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span>
  <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Euro</span>

<span class="Identifier">echo</span> <span class="Identifier">d</span> <span class="Operator">+</span> <span class="DecNumber">12</span>
<span class="Comment"># 错误: 一个无单位的数字不可以与 `Dollar` 相加</span></pre></p>
<p>可惜, 不允许 <tt class="docutils literal"><span class="pre"><span class="Identifier">d</span> <span class="Operator">+</span> <span class="FloatNumber">12.</span><span class="Identifier">Dollar</span></span></tt> ，因为 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> 已被 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> (以及其他)定义，而非 <tt class="docutils literal"><span class="pre"><span class="Identifier">Dollat</span></span></tt> 。 所以用于 <tt class="docutils literal"><span class="pre"><span class="Identifier">Dollar</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> 需要被这样定义:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>将一美元乘以一美元是没有意义的，但是可以乘以一个没有单位的数字，除法也一样:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">y</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Dollar</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">*</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">...</span></pre></p>
<p>这很快就会变得乏味。这些实现很细微而作用不明显，编译器不应该生成所有这些代码，而稍后又优化掉 —— 美元的 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> 应该产生与整数的 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> 相同的二进制代码。编译指示 <span id="borrow_1">borrow</span> &quot;借用&quot;旨在解决这个问题； 原则上，它会生成上述内容简单实现:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Dollar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">borrow</span></span></tt> 编译指示会让编译器使用，与处理distinct类型的基类型过程相同的实现，因此不会生成任何代码。</p>
<p>但是，<tt class="docutils literal"><span class="pre"><span class="Identifier">Euro</span></span></tt> 货币似乎需要重复这些样式的代码，这个可以用<a class="reference internal" href="#模板">模板</a>来解决。</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  
  <span class="Comment"># 一元操作符:</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">-</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">div</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Keyword">mod</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">base</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typ</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">&lt;=</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typ</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">typ</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">base</span>
  <span class="Identifier">additive</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>
  <span class="Identifier">multiplicative</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">base</span><span class="Punctuation">)</span>
  <span class="Identifier">comparable</span><span class="Punctuation">(</span><span class="Identifier">typ</span><span class="Punctuation">)</span>

<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Dollar</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">defineCurrency</span><span class="Punctuation">(</span><span class="Identifier">Euro</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span></pre></p>
<p>borrow编译指示也可用于distinct类型注解，以提升某些内置操作:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">Bar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>

<span class="Keyword">var</span> <span class="Identifier">bb</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Bar</span>
<span class="Identifier">new</span> <span class="Identifier">bb</span>
<span class="Comment"># 字段访问有效</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">90</span>
<span class="Identifier">bb</span><span class="Operator">.</span><span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span></pre></p>
<p>目前只有点访问器可以通过这个方式借用。</p>

<h3><a class="toc-backref" id="distinct类型-避免sql注入攻击" href="#distinct类型-避免sql注入攻击">避免SQL注入攻击</a></h3><p>从Nim传递到SQL数据库的SQL语句可能转化为字符串。但是，使用字符串模板并填写值很容易受到著名的 <span id="sql-injection-attack_1">SQL injection attack</span> &quot;SQL注入攻击&quot; :</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 糟糕的安全漏洞，但是编译器不关心</span></pre></p>
<p>这可以通过区分包含 SQL 的字符串和不包含 SQL 的字符串来避免。Distinct类型提供了一种引入与 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 不兼容的新字符串类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">SQL</span></span></tt> 的方法:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">SQL</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">query</span><span class="Punctuation">(</span><span class="Identifier">db</span><span class="Punctuation">:</span> <span class="Identifier">DbHandle</span><span class="Punctuation">,</span> <span class="Identifier">statement</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span>
  <span class="Identifier">username</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span> <span class="Operator">%</span> <span class="Identifier">username</span><span class="Punctuation">)</span>
<span class="Comment"># 静态错误: `query` 期望一个SQL字符串</span></pre></p>
<p>抽象类型一个重要的属性是，抽象类型与它们的子类型之间没有父子关系。允许显示将 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 类型转换到 <tt class="docutils literal"><span class="pre"><span class="Identifier">SQL</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Punctuation">[</span><span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 正确地为SQL语句引用字符串</span>
  <span class="Keyword">return</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span><span class="Punctuation">,</span> <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">SQL</span> <span class="Operator">=</span>
  <span class="Comment"># 引用每个参数:</span>
  <span class="Keyword">let</span> <span class="Identifier">v</span> <span class="Operator">=</span> <span class="Identifier">values</span><span class="Operator">.</span><span class="Identifier">mapIt</span><span class="Punctuation">(</span><span class="Identifier">properQuote</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># 我们需要一个临时类型用到类型转换 :-(</span>
  <span class="Keyword">type</span> <span class="Identifier">StrSeq</span> <span class="Operator">=</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>
  <span class="Comment"># 调用 strutils.`%`:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">frmt</span><span class="Punctuation">)</span> <span class="Operator">%</span> <span class="Identifier">StrSeq</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Identifier">db</span><span class="Operator">.</span><span class="Identifier">query</span><span class="Punctuation">(</span><span class="StringLit">&quot;SELECT FROM users WHERE name = '$1'&quot;</span><span class="Operator">.</span><span class="Identifier">SQL</span> <span class="Operator">%</span> <span class="Punctuation">[</span><span class="Identifier">username</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>现在我们有了针对SQL注入攻击的编译期检查。由于 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span><span class="Operator">.</span><span class="Identifier">SQL</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">SQL</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span></span></tt> ，所以不需要新的语法来实现简洁的 <tt class="docutils literal"><span class="pre"><span class="Identifier">SQL</span></span></tt> 字符串字面值。假设 <tt class="docutils literal"><span class="pre"><span class="Identifier">SQL</span></span></tt> 类型与 <a class="reference external" href="db_sqlite.html">db_sqlite</a> 等类似，已经作为 <a class="reference external" href="db_common.html#SqlQuery">SqlQuery type</a> 实际存在与库中。</p>

<h2><a class="toc-backref" id="类型-auto类型" href="#类型-auto类型">Auto类型</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">auto</span></span></tt> 类型只能用作返回类型和参数。对于返回类型，它会使编译器从例程主体推断类型:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">returnsInt</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span> <span class="DecNumber">1984</span></pre></p>
<p>对于参数，它当前创建隐式泛型例程:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">auto</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<p>与下面的代码一致:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">[</span><span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">T2</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">T1</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T2</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<p>但是，语言的后续版本可能会将其更改为&quot;从主体推断参数类型&quot;。 从而上面的 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span></span></tt> 将会被拒绝，因为无法从一个空的 <tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt> 语句中推断出参数的类型。</p>

<h1><a class="toc-backref" id="类型关系" href="#类型关系">类型关系</a></h1><p>以下部分定义描述了编译器完成类型检查所需要的几种类型关系。</p>

<h2><a class="toc-backref" id="类型关系-类型相等性" href="#类型关系-类型相等性">类型相等性</a></h2><p>Nim 对大多数类型使用结构类型相等。仅对对象、枚举和distinct类型以及泛型类型使用名称相等。</p>

<h2><a class="toc-backref" id="类型关系-subtype关系" href="#类型关系-subtype关系">Subtype关系</a></h2><p>如果对象 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 将是 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> 的子类型。</p>
<p>子类型关系被延伸到类型 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">prt</span></span></tt> 。如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">B</span></span></tt> 的子类型， <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">B</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 类型那么:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">A</span></span></tt>是<tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">B</span></span></tt>的子类型</li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">A</span></span></tt>是<tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">B</span></span></tt>的子类型</li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">A</span></span></tt>是<tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">B</span></span></tt>的子类型。</li>
</ul>
<p><strong>注意</strong>: 从子类型到父类型的赋值，需要上述指针注解之一，以防止 &quot;对象切割&quot; 。</p>

<h2><a class="toc-backref" id="类型关系-交换关系" href="#类型关系-交换关系">交换关系</a></h2><p>如果以下算法返回 true，则类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> <strong>隐式</strong> 可转换为类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntLiteral</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int8</span><span class="Punctuation">,</span> <span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">uint</span><span class="Punctuation">,</span> <span class="Identifier">uint8</span><span class="Punctuation">,</span> <span class="Identifier">uint16</span><span class="Punctuation">,</span>
                 <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">case</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">kind</span>
  <span class="Keyword">of</span> <span class="Identifier">int</span><span class="Punctuation">:</span>     <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int8</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int16</span><span class="Punctuation">,</span> <span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int16</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int32</span><span class="Punctuation">,</span> <span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">int32</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">int64</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint</span><span class="Punctuation">:</span>    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint8</span><span class="Punctuation">:</span>   <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint16</span><span class="Punctuation">,</span> <span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint16</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint32</span><span class="Punctuation">,</span> <span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">uint32</span><span class="Punctuation">:</span>  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">uint64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float32</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float64</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">float64</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float32</span><span class="Punctuation">}</span>
  <span class="Keyword">of</span> <span class="Identifier">seq</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
  <span class="Keyword">of</span> <span class="Identifier">array</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">openArray</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span> <span class="Operator">==</span> <span class="Identifier">char</span> <span class="Keyword">and</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">indexType</span><span class="Operator">.</span><span class="Identifier">rangeA</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Identifier">cstring</span><span class="Punctuation">,</span> <span class="Keyword">ptr</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">pointer</span>
  <span class="Keyword">of</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Identifier">cstring</span>
  <span class="Keyword">of</span> <span class="Keyword">proc</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">compatibleParametersAndEffects</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></pre></p>
<p>我们使用判断 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 表示 &quot;类型相等&quot; 属性，使用判断 <tt class="docutils literal"><span class="pre"><span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 表示 &quot;子类型关系&quot;。<tt class="docutils literal"><span class="pre"><span class="Identifier">compatibleParametersAndEffects</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 当前未指定。</p>
<p>Nim 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span></span></tt> 类型构造器也执行隐式转换。</p>
<p>Let <tt class="docutils literal"><span class="pre"><span class="Identifier">a0</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">b0</span></span></tt>为类型<tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt>。</p>
<p>让 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="Identifier">a0</span><span class="Operator">..</span><span class="Identifier">b0</span><span class="Punctuation">]</span></span></tt> 为实参类型， <tt class="docutils literal"><span class="pre"><span class="Identifier">F</span></span></tt> 为形参类型。如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">a0</span> <span class="Operator">&gt;=</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">F</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">b0</span> <span class="Operator">&lt;=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">F</span><span class="Punctuation">)</span></span></tt> 并且 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">F</span></span></tt> 都是有符号整数或两者都是无符号整数，则存在从 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span></span></tt> 到 <tt class="docutils literal"><span class="pre"><span class="Identifier">F</span></span></tt> 隐式转换。</p>
<p>如果下列算法返回true，则类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是显示转换为类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">isOrdinal</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="Identifier">float</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">,</span> <span class="Identifier">float64</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">isExplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">PType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">if</span> <span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Keyword">distinct</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="Keyword">distinct</span> <span class="Keyword">and</span> <span class="Identifier">typeEquals</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">baseType</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Keyword">and</span> <span class="Identifier">isIntegralType</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
  <span class="Keyword">if</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Keyword">or</span> <span class="Identifier">isSubtype</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span></pre></p>
<p>可转换关系可以通过用户定义的类型 <span id="converter_1">converter</span> &quot;转换器&quot;放宽。</p>
<p><pre class="listing">
<span class="Keyword">converter</span> <span class="Identifier">toInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">chr</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="CharLit">'a'</span>

<span class="Comment"># 隐式转换变化在这里发生</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span>
<span class="Comment"># 也可以使用显式形式</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Operator">.</span><span class="Identifier">toInt</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># =&gt; 97</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是左值，并且 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeEqualsOrDistinct</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span></span></tt> 成立，则类型转换 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt> 是左值。</p>

<h2><a class="toc-backref" id="类型关系-赋值兼容" href="#类型关系-赋值兼容">赋值兼容</a></h2><p>一个表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> 可以被赋值给一个表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">l</span><span class="Operator">-</span><span class="Identifier">value</span></span></tt> 并且保持 <tt class="docutils literal"><span class="pre"><span class="Identifier">isImplicitlyConvertible</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">typ</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">typ</span><span class="Punctuation">)</span></span></tt> 。</p>

<h1><a class="toc-backref" id="重载解决方案" href="#重载解决方案">重载解决方案</a></h1><p>在调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> 中，选择最匹配的例程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 。如果多个例程匹配相同，则在语义分析期间报告歧义。</p>
<p>args 中的每个 arg 都需要匹配。一个实参可以匹配多个不同的类别。假设 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是形参类型，<tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是实参类型。</p>
<ol class="simple"><li>完全匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是同一类型。</li>
<li>字面值匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是值 <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span></span></tt> 的整数字面值， <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是有符号或无符号整数类型， <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span></span></tt> 在 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 的范围内。 或者: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是值 <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span></span></tt> 的浮点字面值， <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是浮点类型， <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span></span></tt> 在 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 的范围内。</li>
<li>泛型匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是泛型类型和 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 匹配，例如 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 而 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是泛型(受约束的)参数类型(如在 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span> <span class="Identifier">T</span><span class="Punctuation">:</span><span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">char</span><span class="Punctuation">]</span></span></tt> )。</li>
<li>子范围或子类型匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 与 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 完全匹配。 或者: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 的子类型。</li>
<li>整数转换匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 可以转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> ， <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 是某些整数或浮点类型。</li>
<li>转换匹配: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 可转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> ，可能通过用户定义的 <tt class="docutils literal"><span class="pre"><span class="Keyword">converter</span></span></tt> 。</li>
</ol>
<p>这些匹配类别有优先级: 精确匹配比字面值匹配更好，比泛型匹配更好，等等。 在下面的代码中，<tt class="docutils literal"><span class="pre"><span class="Identifier">count</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">)</span></span></tt> 计算例程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 匹配类别 <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> 的匹配次数。</p>
<p>如果以下算法返回 true，则例程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 比例程 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 匹配得更好:<pre>for each matching category m in [&quot;exact match&quot;, &quot;literal match&quot;,
                                &quot;generic match&quot;, &quot;subtype match&quot;,
                                &quot;integral match&quot;, &quot;conversion match&quot;]:
  if count(p, m) &gt; count(q, m): return true
  elif count(p, m) == count(q, m):
    discard &quot;continue with next category m&quot;
  else:
    return false
return &quot;ambiguous&quot;</pre>
</p>
<p>一些例子:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int16&quot;</span>

<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int16</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># &quot;int16&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">takesInt</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># &quot;T&quot;</span></pre></p>
<p>如果这个算法返回 &quot;ambiguous&quot; &quot;歧义&quot;，则执行进一步消除歧义: 如果参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 通过子类型关系同时匹配 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的参数类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">g</span></span></tt>，则考虑继承深度:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">A</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">B</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">A</span>
  <span class="Identifier">C</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">B</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;A&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;B&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">C</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Comment"># 没有歧义, 调用 'B' ，而不是 'A' ，因为 B 是 A 的子类型</span>
<span class="Comment"># 但反之亦然:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;A B&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">obj2</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;B A&quot;</span>

<span class="Comment"># 但是这个有歧义:</span>
<span class="Identifier">pp</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre></p>
<p>类似，对于泛型匹配，最特化的泛型类型(仍然匹配)是首选:</p>
<p><pre class="listing">
 <span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref ref T&quot;</span>
 <span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;ref T&quot;</span>
 <span class="Keyword">proc</span> <span class="Identifier">gen</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;T&quot;</span>
 
 <span class="Keyword">var</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">int</span>
 <span class="Identifier">gen</span><span class="Punctuation">(</span><span class="Identifier">ri</span><span class="Punctuation">)</span> <span class="Comment"># &quot;ref T&quot;</span></pre></p>

<h2><a class="toc-backref" id="重载解决方案-基于-var-t-的重载" href="#重载解决方案-基于-var-t-的重载">基于 'var T' 的重载</a></h2><p>如果形参 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span></span></tt> 类型，并且进行普通类型检查，参数会被检查为 <span id="lminusvalue_1">l-value</span> &quot;左值&quot; 。<tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span></span></tt> 比 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 更好匹配。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配一个非可变整型</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">x</span>
<span class="Keyword">proc</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 匹配一个整形变量</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">10</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># 一个x的可变版本</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的非可变版本</span>
  <span class="Identifier">echo</span> <span class="Identifier">sayHi</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">)</span> <span class="Comment"># 匹配sayHi的可变版本</span>

<span class="Identifier">sayHello</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 3</span>
            <span class="Comment"># 13</span></pre></p>

<h2><a class="toc-backref" id="重载解决方案-untyped惰性类型解析" href="#重载解决方案-untyped惰性类型解析">untyped惰性类型解析</a></h2><p><strong>注意</strong>: <span id="unresolved_1">unresolved</span> &quot;未解析&quot;表达式是没有标识符的表达式，不执行查找和类型检查。</p>
<p>因为没有声明为 <tt class="docutils literal"><span class="pre"><span class="Identifier">immediate</span></span></tt> 的模板和宏会参与重载解析，因此必须有一种方法将未解析的表达式传递给模板或宏。 这就是元类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 的任务:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 类型的参数总是匹配任意参数(只要有任意参数传递给它)。</p>
<p>但须小心，因为其他重载可能会触发参数解析:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">rem</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">rem</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 未声明的标识符: 'unresolvedExpression'</span>
<span class="Identifier">rem</span> <span class="Identifier">unresolvedExpression</span><span class="Punctuation">(</span><span class="Identifier">undeclaredIdentifier</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span></span></tt> 是唯一在这个意义上惰性的元类型，其他元类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 是非惰性的。</p>

<h2><a class="toc-backref" id="重载解决方案-可变参数匹配" href="#重载解决方案-可变参数匹配">可变参数匹配</a></h2><p>参阅 <a class="reference internal" href="#Varargs">Varargs</a>。</p>

<h2><a class="toc-backref" id="重载解决方案-迭代器" href="#重载解决方案-迭代器">迭代器</a></h2><p>yielding类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 的迭代器可以通过类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> (用于未解析的表达式)或类型类 <tt class="docutils literal"><span class="pre"><span class="Identifier">iterable</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">iterable</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> (在类型检查和重载解析之后)的参数传递给模板或宏。</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">iota</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">i</span>

<span class="Keyword">template</span> <span class="Identifier">toSeq2</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">iterable</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ret</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>
  <span class="Identifier">assert</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">typeof</span> <span class="Keyword">is</span> <span class="Identifier">T</span>
  <span class="Keyword">for</span> <span class="Identifier">ai</span> <span class="Keyword">in</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">ret</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">ai</span>
  <span class="Identifier">ret</span>

<span class="Identifier">assert</span> <span class="Identifier">iota</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toSeq2</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span>
<span class="Identifier">assert</span> <span class="Identifier">toSeq2</span><span class="Punctuation">(</span><span class="FloatNumber">5.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">]</span>
<span class="Identifier">assert</span> <span class="Keyword">not</span> <span class="Identifier">compiles</span><span class="Punctuation">(</span><span class="Identifier">toSeq2</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># seq[int] is not an iterable</span>
<span class="Identifier">assert</span> <span class="Identifier">toSeq2</span><span class="Punctuation">(</span><span class="Identifier">items</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Comment"># but items(@[1,2]) is</span></pre></p>

<h1><a class="toc-backref" id="重载歧义消除" href="#重载歧义消除">重载歧义消除</a></h1><p>对于例程调用，会进行 &quot;重载解析&quot; 。有一种较弱的重载解析形式，称为 <em>overload disambiguation</em> <em>重载歧义消除</em> ，当重载符号在有额外类型信息的情况下被使用时，会执行。假设 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 是一个重载符号。则上下文是:</p>
<ul class="simple"><li>当 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 的相应形式参数是 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 类型时，在函数调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">,</span> <span class="Identifier">p</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt> 中。 如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 本身被重载，则必须考虑 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的每种解释的笛卡尔积。</li>
<li>在一个对象构造函数中 <tt class="docutils literal"><span class="pre"><span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">,</span> <span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">p</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt> 当 <tt class="docutils literal"><span class="pre"><span class="Identifier">field</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 类型。类似的规则也适用于 array/set/tuple 的构造器。</li>
<li>有这样的声明 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">p</span></span></tt> 当 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 类型。</li>
</ul>
<p>通常情况下，有歧义的匹配会产生编译错误。</p>

<h2><a class="toc-backref" id="重载歧义消除-命名参数重载" href="#重载歧义消除-命名参数重载">命名参数重载</a></h2><p>如果形参的名称不同，则可以分别调用具有相同类型签名的例程。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Using x: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Using y: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>

<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># Using x: 2</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Comment"># Using y: 2</span></pre></p>
<p>在这种情况下不提供参数名称会导致歧义错误。</p>

<h1><a class="toc-backref" id="语句和表达式" href="#语句和表达式">语句和表达式</a></h1><p>Nim 使用通用的&quot;语句/表达式&quot;范式: 与表达式相比，语句不产生值。 但是，有些表达式是语句。</p>
<p>语句分成 <span id="simple-statements_1">simple statements</span> &quot;简单语句&quot; 和 <span id="complex-statements_1">complex statements</span> &quot;复杂语句&quot; 。简单语句是不能包含其他语句的语句，如赋值、调用或 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句；复杂语句包含其他语句。为了避免 <span id="dangling-else-problem_1">dangling else problem</span> &quot;不确定性问题&quot;，复杂语句必须缩进, 细节可以查看语法一节。</p>

<h2><a class="toc-backref" id="语句和表达式-语句列表表达式" href="#语句和表达式-语句列表表达式">语句列表表达式</a></h2><p>语句也可以出现 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">stmt1</span><span class="Punctuation">;</span> <span class="Identifier">stmt2</span><span class="Punctuation">;</span> <span class="Operator">...</span><span class="Punctuation">;</span> <span class="Identifier">ex</span><span class="Punctuation">)</span></span></tt> 这样的形式。这称为语句列表表达式或 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">;</span><span class="Punctuation">)</span></span></tt> 。 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">stmt1</span><span class="Punctuation">;</span> <span class="Identifier">stmt2</span><span class="Punctuation">;</span> <span class="Operator">...</span><span class="Punctuation">;</span> <span class="Identifier">ex</span><span class="Punctuation">)</span></span></tt> 的类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">ex</span></span></tt> 类型。其他语句必须是 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 类型。(可以使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt> 来生成 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 类型。) <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">;</span><span class="Punctuation">)</span></span></tt> 不会引入新的作用域。</p>

<h2><a class="toc-backref" id="语句和表达式-discard语句" href="#语句和表达式-discard语句">Discard语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">discard</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 丢弃 `p` 的返回值</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt> 语句评估其表达式的副作用并将表达式的结果值丢弃，其应在已知忽略此值不会导致问题时使用。</p>
<p>忽略过程的返回值而不使用丢弃语句将是静态错误。</p>
<p>如果调用的 proc/iterator 已使用 <span id="discardable_1">discardable</span> &quot;可丢弃&quot;编译指示声明，则可以隐式忽略返回值:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># 当前有效</span></pre></p>
<p>但是可丢弃编译指示不适用于模板，因为模板会替换掉 AST。 例如:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">discardable</span> <span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">example</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;https://nim-lang.org&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">example</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>此模板将解析为字符串字面值 &quot;<a class="reference external" href="https://nim-lang.org">https://nim-lang.org</a>&quot; ，但由于 {.discardable.} 不适用于字面值，编译器会出错。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt> 语句常用于空语句中:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-void下上文" href="#语句和表达式-void下上文">Void下上文</a></h2><p>在语句列表中，除了最后一个表达式之外，每个表达式类型需要为 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 。除了这个规则，对内置 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 标识符的赋值也会为后续的表达式触发强制的 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 上下文:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">invalid</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="StringLit">&quot;invalid&quot;</span>  <span class="Comment"># 错误: 类型 `string` 的值必须被抛弃</span></pre></p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">valid</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">317</span>
  <span class="StringLit">&quot;valid&quot;</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-var语句" href="#语句和表达式-var语句">Var语句</a></h2><p>Var 语句声明新的局部和全局变量并初始化它们。逗号分隔的变量列表可用于指定相同类型的变量:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>如果给定了初始化器，则可以省略类型: 变量的类型与初始化表达式的类型相同。如果没有初始化表达式，则始终使用默认值初始化变量。默认值取决于类型，并且在二进制中始终为零。</p>
<table border="1" class="docutils"><tr><th>类型</th><th>默认值</th></tr>
<tr><td>any integer type</td><td>0</td></tr>
<tr><td>any float</td><td>0.0</td></tr>
<tr><td>char</td><td>'\0'</td></tr>
<tr><td>bool</td><td>false</td></tr>
<tr><td>ref or pointer type</td><td>nil</td></tr>
<tr><td>procedural type</td><td>nil</td></tr>
<tr><td>sequence</td><td><tt class="docutils literal"><span class="pre"><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt></td></tr>
<tr><td>string</td><td><tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">]</span></span></tt></td><td>(default(A), default(B), ...) (analogous for objects)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">..</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span></span></tt></td><td><tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Identifier">default</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">]</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">range</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt></td><td>default(T); 这可能会超出有效范围</td></tr>
<tr><td>T = enum</td><td><tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span></span></tt>; 这可能是一个无效值</td></tr>
</table><p>出于优化原因，可以使用 <span id="noinit_1">noinit</span> &quot;无初始化&quot;编译指示来避免隐式初始化:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">1023</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span></pre></p>
<p>如果proc使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">noinit</span></span></tt> 编译指示，这指的是其隐式 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 变量:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">returnUndefinedValue</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noinit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<p><span id="requiresinit_1">requiresInit</span> &quot;需初始化&quot;类型编译指示也可以防止隐式初始化。编译器需要对对象及其所有字段进行显式初始化。但是，它会进行 <span id="control-flow-analysis_1">control flow analysis</span> &quot;控制流分析&quot; 以验证变量已被初始化并且不依赖于语法属性:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyObject</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 以下是有效的:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
  <span class="Keyword">if</span> <span class="Identifier">someCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 使用 x</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">requiresInit</span></span></tt> 编译指示也可以应用于 <tt class="docutils literal"><span class="pre"><span class="Keyword">distinct</span></span></tt> 类型。</p>
<p>给出以下distinct类型定义:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  
  <span class="Identifier">DistinctFoo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Punctuation">,</span> <span class="Identifier">borrow</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">Foo</span>
  <span class="Identifier">DistinctString</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">string</span></pre></p>
<p>下列代码块将会编译失败:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">DistinctFoo</span>
<span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;test&quot;</span>
<span class="Identifier">doAssert</span> <span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">==</span> <span class="StringLit">&quot;test&quot;</span></pre></p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">DistinctString</span>
<span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;test&quot;</span>
<span class="Identifier">doAssert</span> <span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;test&quot;</span></pre></p>
<p>但这些将会编译成功:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">DistinctFoo</span><span class="Punctuation">(</span><span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="StringLit">&quot;test&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">doAssert</span> <span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">==</span> <span class="StringLit">&quot;test&quot;</span></pre></p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">DistinctString</span><span class="Punctuation">(</span><span class="StringLit">&quot;test&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">doAssert</span> <span class="Identifier">string</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;test&quot;</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-let语句" href="#语句和表达式-let语句">Let语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 语句声明了新的局部和全局 <span id="single-assignment_1">single assignment</span> &quot;唯一赋值&quot;变量并将值绑定到它们。语法与 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 语句的语法相同，只是关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 被关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 替换。let变量不是左值，因此不能传递给 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 参数也不能获取他们的地址。不能为它们分配新值。</p>
<p>对于 let 变量，可以使用与普通变量相同的编译指示。</p>
<p>由于 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 语句在创建后是不可变的，因此它们需要在声明时定义值。唯一的例外是如果应用了 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示(或任意其他 <tt class="docutils literal"><span class="pre"><span class="Identifier">importX</span></span></tt> 编译指示)，在这种情况下，值应该来自本地代码，通常是 C/C++ <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 。</p>

<h2><a class="toc-backref" id="语句和表达式-元组解包" href="#语句和表达式-元组解包">元组解包</a></h2><p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 语句中可以执行元组解包。特定标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">_</span></span></tt> 可用于忽略元组的某些部分:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">returnsTuple</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-常量域" href="#语句和表达式-常量域">常量域</a></h2><p>const部分声明的常量的值是常量表达式:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Punctuation">[</span><span class="Identifier">strutils</span><span class="Punctuation">]</span>
<span class="Keyword">const</span>
  <span class="Identifier">roundPi</span> <span class="Operator">=</span> <span class="FloatNumber">3.1415</span>
  <span class="Identifier">constEval</span> <span class="Operator">=</span> <span class="Identifier">contains</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span> <span class="Comment"># 在编译时计算</span></pre></p>
<p>一旦声明，常量的符号就可以用作常量表达式。</p>
<p>详情参阅<a class="reference internal" href="#常量和常量表达式">常量和常量表达式</a>。</p>

<h2><a class="toc-backref" id="语句和表达式-静态语句slash表达式" href="#语句和表达式-静态语句slash表达式">静态语句/表达式</a></h2><p>静态语句/表达式明确要求编译期执行。甚至在静态块中也允许一些具有副作用的代码:</p>
<p><pre class="listing">
<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;echo at compile time&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">static</span></span></tt> 也可以像例程一样使用。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">getNum</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">a</span>

<span class="Comment"># 以下，在编译期调用 &quot;echo getNum(123)&quot;</span>
<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">getNum</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span>

<span class="Comment"># 下面的调用在编译期计算 &quot;getNum(123)&quot; ，但其结果在运行时使用。</span>
<span class="Identifier">echo</span> <span class="Keyword">static</span><span class="Punctuation">(</span><span class="Identifier">getNum</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>对于哪些Nim代码可以在编译期执行，是有限制的，详情参阅<a class="reference internal" href="#编译期执行限制">编译期执行限制</a>。如果编译器不能在编译期执行该块，将是一个静态错误。</p>

<h2><a class="toc-backref" id="语句和表达式-if语句" href="#语句和表达式-if语句">If语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>

<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;Andreas&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;What a nice name!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Don't you have a name?&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Boring name...&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句是在控制流中创建分支的简单方法: 计算关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 后的表达式，如果为真，则执行 <tt class="docutils literal"><span class="pre"><span class="Punctuation">:</span></span></tt> 后的相应语句。否则，计算 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 之后的表达式(如果有 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 分支)。如果所有条件都失败，则执行 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 部分。 如果没有 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 部分，则继续执行下一条语句。</p>
<p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句中，新的作用域在 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 关键字之后立即开始，并在相应的 <em>那个</em> 块之后结束。 出于呈现的目的，在以下示例中，作用域被包含在 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">|</span> <span class="Operator">|</span><span class="Punctuation">}</span></span></tt> 中:</p>
<p><pre class="listing">
<span class="Keyword">if</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;(\w+)=\w+&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;key &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="StringLit">&quot; value &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">elif</span> <span class="Punctuation">{</span><span class="Operator">|</span> <span class="Punctuation">(</span><span class="Keyword">let</span> <span class="Identifier">m</span> <span class="Operator">=</span> <span class="Identifier">input</span> <span class="Operator">=~</span> <span class="RawData">re&quot;&quot;</span><span class="Punctuation">;</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">isMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;new m in this scope&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Operator">|</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;m not declared here&quot;</span>  <span class="Operator">|</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-case-语句" href="#语句和表达式-case-语句">Case 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">line</span> <span class="Operator">=</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">line</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">line</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;empty&quot;</span> <span class="Comment"># optional, must come after `of` branches</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span> <span class="Comment"># ditto</span>

<span class="Comment"># 允许分支缩进;</span>
<span class="Comment"># 在选择表达式之后的冒号是可选:</span>
<span class="Keyword">case</span> <span class="Identifier">readline</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;delete-everything&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;restart-computer&quot;</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;permission denied&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;go-for-a-walk&quot;</span><span class="Punctuation">:</span>     <span class="Identifier">echo</span> <span class="StringLit">&quot;please yourself&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>                   <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown command&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句类似于 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句, 它表示一种多分支选择。 关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 后面的表达式进行求值, 如果其值在 <em>slicelist</em> 列表中, 则执行 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 关键字之后相应语句。 如果其值不在已给定的 <em>slicelist</em> 中, 那么所执行的 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 、 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 语句部分与 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句相同, <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 的处理就像 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">if</span></span></tt> 。 如果没有 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 部分，并且 <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> 未能持有所有可能的值,则在 <em>slicelist</em> 会发生静态错误。 但这仅适用于序数类型的表达式。 <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> 的 &quot;所有可能的值&quot; 由 <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> 的类型决定，为了防止静态错误应该使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></span></tt>。</p>
<p>在case语句中，只允许使用序数类型、浮点数、字符串和cstring作为值。</p>
<p>对于非序数类型, 不可能列出每个可能的值，所以总是需要 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 部分。 此规则 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 类型是例外，目前，它不需要在后面添加 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 分支， 但在未来版本中不确定。</p>
<p>因为在语义分析期间检查case语句的穷尽性，所以每个 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 分支中的值必须是常量表达式。 此限制可以让编译器生成更高性能的代码。</p>
<p>一种特殊的语义扩展是, case语句 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 分支中的表达式可以为集合或数组构造器， 然后将集合或数组扩展为其元素的列表:</p>
<p><pre class="listing">
<span class="Keyword">const</span>
  <span class="Identifier">SymChars</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="Identifier">SymChars</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span>

<span class="Comment"># 等价于:</span>
<span class="Keyword">proc</span> <span class="Identifier">classify</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">of</span> <span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">,</span> <span class="CharLit">'\x80'</span><span class="Operator">..</span><span class="CharLit">'\xFF'</span><span class="Punctuation">,</span> <span class="CharLit">'_'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;an identifier&quot;</span>
  <span class="Keyword">of</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;a number&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;other&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句不会产生左值, 所以下面的示例无效:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">get_x</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 无效</span>
  <span class="Keyword">case</span> <span class="Identifier">true</span>
  <span class="Keyword">of</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">var</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
<span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">get_x</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;asd&quot;</span><span class="Punctuation">)</span></pre></p>
<p>这可以通过显式使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 来修复:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">get_x</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">case</span> <span class="Identifier">true</span>
  <span class="Keyword">of</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">x</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-when-语句" href="#语句和表达式-when-语句">When 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 16 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 32 bit system!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on a 64 bit system!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;cannot happen!&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句几乎与 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句相同, 但有一些例外:</p>
<ul class="simple"><li>每个条件 ( <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> ) 必须是一个类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 的常量表达式。</li>
<li>语句不产生新作用域。</li>
<li>计算为true的表达式所属语句将由编译器翻译，而只检查每个条件的语义，不检查其他语句语义!</li>
</ul>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句启用了条件编译技术。一种特殊的语法扩展是，可以在 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 定义中使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 结构。</p>

<h2><a class="toc-backref" id="语句和表达式-when-nimvm-语句" href="#语句和表达式-when-nimvm-语句">When nimvm 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">nimvm</span></span></tt> 是一个特殊标识符, 可用 <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span> <span class="Identifier">nimvm</span></span></tt> 语句表达式来判断路径，编译时或可执行文件之间执行。</p>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">when</span> <span class="Identifier">nimvm</span><span class="Punctuation">:</span>
    <span class="Comment"># 编译时采用此分支.</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Comment"># 可执行文件中采用此分支.</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">const</span> <span class="Identifier">ctValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">rtValue</span> <span class="Operator">=</span> <span class="Identifier">someProcThatMayRunInCompileTime</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">ctValue</span> <span class="Operator">==</span> <span class="Identifier">true</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">rtValue</span> <span class="Operator">==</span> <span class="Identifier">false</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">when</span> <span class="Identifier">nimvm</span></span></tt> 语句必须满足以下要求:</p>
<ul class="simple"><li>表达式必须是 <tt class="docutils literal"><span class="pre"><span class="Identifier">nimvm</span></span></tt> ，不允许使用的复杂表达式。</li>
<li>不得含有 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 分支。</li>
<li>必须含有 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 分支。</li>
<li>分支中的代码不能影响 <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span> <span class="Identifier">nimvm</span></span></tt> 语句之后代码的语义，比如不能定义后续代码中使用的标识符。</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-return-语句" href="#语句和表达式-return-语句">Return 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">return</span> <span class="DecNumber">40</span> <span class="Operator">+</span> <span class="DecNumber">2</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句将结束当前执行的过程，并只允许在过程中使用。如果这里是一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> , 将是语法糖:</p>
<p><pre class="listing">
<span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">expr</span>
<span class="Keyword">return</span> <span class="Identifier">result</span></pre></p>
<p>如果proc有返回类型，不带表达式的 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span> <span class="Identifier">result</span></span></tt> 的简短表示. 编译器自动声明的变量 <span id="result_1">result</span> 始终是过程的返回值。与所有变量一样, <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 会初始化为(二进制)0:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">returnZero</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 隐式返回0</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-yield-语句" href="#语句和表达式-yield-语句">Yield 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre></p>
<p>在迭代器中使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句代替 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句。它只在迭代器中有效。执行将被返回到调用该迭代器的for循环的主体。Yield并不会结束迭代过程，当下一次迭代开始，执行会被传回迭代器。更多信息请参阅关于迭代器的章节(<a class="reference internal" href="#迭代器和for语句">迭代器和for语句</a>)。</p>

<h2><a class="toc-backref" id="语句和表达式-block-语句" href="#语句和表达式-block-语句">Block 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">false</span>
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
      <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="DecNumber">7</span><span class="Punctuation">:</span>
        <span class="Identifier">found</span> <span class="Operator">=</span> <span class="Identifier">true</span>
        <span class="Keyword">break</span> <span class="Identifier">myblock</span> <span class="Comment"># 跳出两个for循环块</span>
<span class="Identifier">echo</span> <span class="Identifier">found</span></pre></p>
<p>block语句是一种将语句分组到命名的 <tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> 的方法。在block语句内，允许用 <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句立即跳出。 <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句可以包含围绕的block的名称, 以指定要跳出的层级。</p>

<h2><a class="toc-backref" id="语句和表达式-break-语句" href="#语句和表达式-break-语句">Break 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">break</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句用于立即跳出block块。如果给出 <tt class="docutils literal"><span class="pre"><span class="Identifier">symbol</span></span></tt> &quot;标识符&quot;, 是指定要跳出的闭合的block的名称。如果未给出，则跳出最里面的block。</p>

<h2><a class="toc-backref" id="语句和表达式-while-语句" href="#语句和表达式-while-语句">While 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your password:&quot;</span>
<span class="Keyword">var</span> <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">pw</span> <span class="Operator">!=</span> <span class="StringLit">&quot;12345&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Wrong password! Next try:&quot;</span>
  <span class="Identifier">pw</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> 语句执行时直到 <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> 计算结果为false。无尽的循环不会报告错误。 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> 语句会打开一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">implicit</span> <span class="Keyword">block</span></span></tt> &quot;隐式块&quot;，因而可以用 <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句跳出。</p>

<h2><a class="toc-backref" id="语句和表达式-continue-语句" href="#语句和表达式-continue-语句">Continue 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">continue</span></span></tt> 语句会使循环结构进行下一次迭代，其只允许在循环中使用。continue语句是嵌套block的语法糖:</p>
<p><pre class="listing">
<span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Identifier">stmt1</span>
  <span class="Keyword">continue</span>
  <span class="Identifier">stmt2</span></pre></p>
<p>等价于:</p>
<p><pre class="listing">
<span class="Keyword">while</span> <span class="Identifier">expr1</span><span class="Punctuation">:</span>
  <span class="Keyword">block</span> <span class="Identifier">myBlockName</span><span class="Punctuation">:</span>
    <span class="Identifier">stmt1</span>
    <span class="Keyword">break</span> <span class="Identifier">myBlockName</span>
    <span class="Identifier">stmt2</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-汇编语句" href="#语句和表达式-汇编语句">汇编语句</a></h2><p>不安全的 <tt class="docutils literal"><span class="pre"><span class="Keyword">asm</span></span></tt> 语句支持将汇编代码直接嵌入到Nim代码中。在汇编代码中引用Nim的标识符需要包含在特定字符中，该字符可以在语句的编译指示中指定。默认特定字符是 <tt class="docutils literal"><span class="pre"><span class="CharLit">'`'</span></span></tt> :</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># a 在 eax 中, b 在 edx 中</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
      mov eax, `a`
      add eax, `b`
      jno theEnd
      call `raiseOverflow`
    theEnd:
  &quot;&quot;&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>如果使用GNU汇编器，则会自动插入引号和换行符:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    addl %%ecx, %%eax
    jno 1
    call `raiseOverflow`
    1:
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre></p>
<p>替代:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">addInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">asm</span> <span class="LongStringLit">&quot;&quot;&quot;
    &quot;addl %%ecx, %%eax\n&quot;
    &quot;jno 1\n&quot;
    &quot;call `raiseOverflow`\n&quot;
    &quot;1: \n&quot;
    :&quot;=a&quot;(`result`)
    :&quot;a&quot;(`a`), &quot;c&quot;(`b`)
  &quot;&quot;&quot;</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-using语句" href="#语句和表达式-using语句">Using语句</a></h2><p>在模块中反复使用相同的参数名称和类型时，<tt class="docutils literal"><span class="pre"><span class="Keyword">using</span></span></tt> 语句提供了语法上的便利，而不必:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span><span class="Punctuation">;</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span></pre></p>
<p>你可以告知编译器一个名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">c</span></span></tt> 的参数默认类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">Context</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>的默认类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">Node</span></span></tt> :</p>
<p><pre class="listing">
<span class="Keyword">using</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Context</span>
  <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
  <span class="Identifier">counter</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">,</span> <span class="Identifier">counter</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">mixedMode</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 'c' 被推断为 'Context' 类型</span>
  <span class="Comment"># 'n' 被推断为 'Node' 类型</span>
  <span class="Comment"># 'x' 和 'y' 是 'int' 类型。</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">using</span></span></tt> 部分使用缩进的分组语法，与 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 部分相同。</p>
<p>注意, <tt class="docutils literal"><span class="pre"><span class="Keyword">using</span></span></tt> 在 <tt class="docutils literal"><span class="pre"><span class="Keyword">template</span></span></tt> 不适用，因为untyped模板参数默认是 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">untyped</span></span></tt> 类型。</p>
<p>使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">using</span></span></tt> 声明和显式类型的参数混合时，它们之间需要分号。</p>

<h2><a class="toc-backref" id="语句和表达式-if-表达式" href="#语句和表达式-if-表达式">If 表达式</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 表达式与if语句非常相似，但它是一个表达式。这个特性类似于其他语言中的 <em>三元操作符</em> 。 示例:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="DecNumber">9</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="DecNumber">10</span></pre></p>
<p>if表达式总是会产生一个值，所以必需有 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 部分。也可以使用<tt class="docutils literal"><span class="pre"><span class="Keyword">Elif</span></span></tt> 部分。</p>

<h2><a class="toc-backref" id="语句和表达式-when表达式" href="#语句和表达式-when表达式">When表达式</a></h2><p>和 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 表达式相似，与 <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句对应。</p>

<h2><a class="toc-backref" id="语句和表达式-case表达式" href="#语句和表达式-case表达式">Case表达式</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 表达式与case语句非常相似:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">favoriteFood</span> <span class="Operator">=</span> <span class="Keyword">case</span> <span class="Identifier">animal</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;dog&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;bones&quot;</span>
  <span class="Keyword">of</span> <span class="StringLit">&quot;cat&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;mice&quot;</span>
  <span class="Keyword">elif</span> <span class="Identifier">animal</span><span class="Operator">.</span><span class="RawData">endsWith&quot;whale&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;plankton&quot;</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm not sure what to serve, but everybody loves ice cream&quot;</span>
    <span class="StringLit">&quot;ice cream&quot;</span></pre></p>
<p>如上例所示，case表达式也可以引入副作用。当分支给出多个语句时，Nim将使用最后一个表达式作为结果值。</p>

<h2><a class="toc-backref" id="语句和表达式-block表达式" href="#语句和表达式-block表达式">Block表达式</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> 表达式几乎和block语句相同，但它是一个表达式，它使用block的最后一个表达式作为值。它类似于语句列表表达式，但语句列表表达式不会创建新的block作用域。</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">fib</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">:</span>
    <span class="Identifier">fib</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">+</span> <span class="Identifier">fib</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
  <span class="Identifier">fib</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-表构造器" href="#语句和表达式-表构造器">表构造器</a></h2><p>表构造器是数组构造器的语法糖:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">:</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">}</span>

<span class="Comment"># 等同于:</span>
<span class="Punctuation">[</span><span class="Punctuation">(</span><span class="StringLit">&quot;key1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value1&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key2&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="StringLit">&quot;key3&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value2&quot;</span><span class="Punctuation">)</span><span class="Punctuation">]</span></pre></p>
<p>空表可以写成 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">:</span><span class="Punctuation">}</span></span></tt> (对比 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">}</span></span></tt> 空集合)，这是另一种写为空数组构造器 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 的方法。这种略微不同寻常的书写表的方式有很多优点:</p>
<ul class="simple"><li>保留了(键, 值)对的顺序, 因此更容易支持有序的字典，例如 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">val</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">newOrderedTable</span></span></tt> 。</li>
<li>表字面值可以放入 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 部分，编译器可以更容易地将它放入可执行文件的数据部分，就像数组一样，生成的数据部分占用更少的内存。</li>
<li>每个表的实现在语法上一样。</li>
<li>除了这个最低限度的语法糖, 语言核心不需要关心表。</li>
</ul>

<h2><a class="toc-backref" id="语句和表达式-类型转换" href="#语句和表达式-类型转换">类型转换</a></h2><p>从语法上来说， <em>类型转换</em> 类似于过程调用，只是用一个类型名替换了过程名。类型转换总是安全的，将类型转换失败会导致异常(如果不能静态确定)。</p>
<p>普通的procs通常比Nim中的类型转换更友好: 例如, <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">toString</span></span></tt> 运算符, 而 <tt class="docutils literal"><span class="pre"><span class="Identifier">toFloat</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">toInt</span></span></tt> 可从浮点数转换为整数,反之亦然。</p>
<p>类型转换也可用于消除重载例程的歧义:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;int&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;string&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">procVar</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">)</span>
<span class="Identifier">procVar</span><span class="Punctuation">(</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">)</span></pre></p>
<p>由于对无符号数的操作会环绕，且不会检查，因而到无符号整数的类型转换以及无符号整数之间的类型转换也会这样。 这样做的原因是，当算法从C移植到Nim时，可以更好地与C语言进行互操作。</p>
<p>例外: 将检查在编译时转换为无符号类型的值, 以使 <tt class="docutils literal"><span class="pre"><span class="Identifier">byte</span><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></span></tt> 之类代码无法编译。</p>
<p><strong>注意</strong>: 历史版本中不检查运算，有时会检查转换，但从1.0.4语言版本实现开始，转换 <em>总是未检查</em> 。</p>

<h2><a class="toc-backref" id="语句和表达式-类型强转" href="#语句和表达式-类型强转">类型强转</a></h2><p><em>类型强转</em> 是一种粗暴的机制，对于表达式按位模式解释，就好像它就是另一种类型。类型强转仅用于低层编程，并且本质上是不安全的。</p>
<p><pre class="listing">
<span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>强制转换的目标类型必须是具体类型，例如，非具体的类型类目标将是无效的:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">Foo</span> <span class="Operator">=</span> <span class="Identifier">int</span> <span class="Keyword">or</span> <span class="Identifier">float</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">Foo</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Comment"># Error: 不能转换为非具体类型: 'Foo'</span></pre></p>
<p>类型强转不应与 <em>类型转换</em> 混淆, 如前所述，与类型转换不同，类型强转不能更改被转换数据的底层位模式(除了目标类型的大小可能与源类型不同之外)。强制转换类似于其他语言中的 <em>类型双关</em> 或c++的 <tt class="docutils literal"><span class="pre"><span class="Identifier">reinterpret_cast</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">bit_cast</span></span></tt> 特性。</p>

<h2><a class="toc-backref" id="语句和表达式-addr操作符" href="#语句和表达式-addr操作符">addr操作符</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 运算符返回左值的地址。如果地址的类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt>, 则 <tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 运算符结果的类型为 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">T</span></span></tt> 。地址总是一个未追踪引用的值。获取驻留在堆栈上的对象的地址是 <strong>不安全的</strong> , 因为指针可能比堆栈中的对象存在更久, 因此可以引用不存在的对象。我们得到变量的地址，是为了更容易与其他编译语言互操作(如C)，也可以做到检索 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 变量、参数或 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环变量的地址:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">t1</span> <span class="Operator">=</span> <span class="StringLit">&quot;Hello&quot;</span>
<span class="Keyword">var</span>
  <span class="Identifier">t2</span> <span class="Operator">=</span> <span class="Identifier">t1</span>
  <span class="Identifier">t3</span> <span class="Punctuation">:</span> <span class="Identifier">pointer</span> <span class="Operator">=</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t2</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; ref 0x7fff6b71b670 --&gt; 0x10bb81050&quot;Hello&quot;</span>
<span class="Identifier">echo</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">ptr</span> <span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t3</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Punctuation">]</span>
<span class="Comment"># --&gt; Hello</span>
<span class="Comment"># 下面这行代码也可以使用</span>
<span class="Identifier">echo</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">t1</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="语句和表达式-unsafeaddr操作符" href="#语句和表达式-unsafeaddr操作符">unsafeAddr操作符</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">unsafeAddr</span></span></tt> 操作符是 <tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 操作符已弃用的别名:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">myArray</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>
<span class="Identifier">foreignProcThatTakesAnAddr</span><span class="Punctuation">(</span><span class="Identifier">unsafeAddr</span> <span class="Identifier">myArray</span><span class="Punctuation">)</span></pre></p>

<h1><a class="toc-backref" id="过程" href="#过程">过程</a></h1><p>大多数编程语言中称之为 <tt class="docutils literal"><span class="pre"><span class="Identifier">methods</span></span></tt>:idx &quot;方法&quot;或 <tt class="docutils literal"><span class="pre"><span class="Identifier">functions</span></span></tt>:idx &quot;函数&quot;，在Nim中则称为 <tt class="docutils literal"><span class="pre"><span class="Identifier">procedures</span></span></tt>:idx &quot;过程&quot;。过程声明由标识符、零个或多个形参、返回值类型和代码块组成，形参声明为由逗号或分号分隔的标识符列表。形参由 <tt class="docutils literal"><span class="pre"><span class="Punctuation">:</span> <span class="Identifier">typename</span></span></tt> 给出一个类型。该类型适用于紧接其之前的所有参数，直到参数列表的开头的分号分隔符或已经键入的参数。 分号可使类型和后续标识符的分隔更加清晰。</p>
<p><pre class="listing">
<span class="Comment"># 只使用逗号</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 使用分号进行显式的区分</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 会失败: a是无类型的, 因为 ';' 为停止类型传播</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>可以使用默认值声明参数，如果调用者没有为参数提供值，则使用该默认值，每次调用函数时，都会重新计算该值。</p>
<p><pre class="listing">
<span class="Comment"># b是可选的, 默认值为47。</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">47</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>正如逗号从右到左传播类型，直到遇到第一个参数或分号，默认值也会从其声明的参数开始传播。</p>
<p><pre class="listing">
<span class="Comment"># a和b都是可选的，默认值为47。</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">47</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>参数可以声明为可变的，过程允许通过类型修饰符 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 来修饰参数。</p>
<p><pre class="listing">
<span class="Comment"># 通过第二个参数 &quot;返回&quot; 一个值给调用者</span>
<span class="Comment"># 请注意, 该函数实际没有使用真实的返回值(即void)</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">inp</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">outp</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">outp</span> <span class="Operator">=</span> <span class="Identifier">inp</span> <span class="Operator">+</span> <span class="DecNumber">47</span></pre></p>
<p>如果proc声明没有过程体, 则是 <span id="forward_1">forward</span> &quot;前置&quot;声明。如果proc返回一个值，那么过程体可以访问一个名为 <span id="result_2">result</span> 的隐式变量。过程可能会重载，重载解析算法会确定哪个proc是参数的最佳匹配。 示例:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Operator">=</span> <span class="Comment"># toLower 字符</span>
  <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Punctuation">{</span><span class="CharLit">'A'</span><span class="Operator">..</span><span class="CharLit">'Z'</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">chr</span><span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Punctuation">(</span><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="Identifier">ord</span><span class="Punctuation">(</span><span class="CharLit">'A'</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">c</span>

<span class="Keyword">proc</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Comment"># 字符串 toLower</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newString</span><span class="Punctuation">(</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">toLower</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Comment"># 为字符调用toLower;不递归!</span></pre></p>
<p>调用过程可以通过多种方式完成:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">char</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Comment"># 带位置参数的调用                   # 参数绑定:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span>       <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=true)</span>
<span class="Comment"># 使用命名参数和位置参数调用:</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abd&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span><span class="Punctuation">)</span>         <span class="Comment"># (x=0, y=1, s=&quot;abd&quot;, c='\t', b=false)</span>
<span class="Comment"># 带命名参数的调用(顺序无关):</span>
<span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">=</span><span class="CharLit">'\t'</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">=</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Operator">=</span><span class="DecNumber">0</span><span class="Punctuation">)</span>              <span class="Comment"># (x=0, y=1, s=&quot;&quot;, c='\t', b=false)</span>
<span class="Comment"># 作为命令语句调用:不需要():</span>
<span class="Identifier">callme</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="CharLit">'\t'</span>              <span class="Comment"># (x=0, y=1, s=&quot;abc&quot;, c='\t', b=false)</span></pre></p>
<p>过程可以递归地调用自身。</p>
<p><span id="operators_1">Operators</span> &quot;操作符&quot;是将特定运算符作为标识符的过程:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Comment"># 将整数转换为字符串;这是一个前缀操作符。</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">intToStr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>具有一个参数的操作符是前缀操作符，有两个参数的运算符是中缀操作符。(但是, 解析器将这些与操作符在表达式中的位置区分开来。) 无法声明后缀运算符，所有后缀运算符都是内置的，由语法明确指出。</p>
<p>任何操作符都可以像普通的proc一样用 `opr` 表示法调用。(因此操作符可以有两个以上的参数):</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 乘 和 加</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">*</span> <span class="Identifier">b</span> <span class="Operator">+</span> <span class="Identifier">c</span>

<span class="Identifier">assert</span> <span class="Punctuation">`</span><span class="Operator">*+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="过程-导出标记" href="#过程-导出标记">导出标记</a></h2><p>如果声明的标识符有 <span id="asterisk_1">asterisk</span> &quot;星号&quot;标记，表示从当前模块导出:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">exportedEcho</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">s</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStringOfCap</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">a</span>

<span class="Keyword">var</span> <span class="Identifier">exportedVar</span><span class="Operator">*:</span> <span class="Identifier">int</span>
<span class="Keyword">const</span> <span class="Identifier">exportedConst</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">78</span>
<span class="Keyword">type</span>
  <span class="Identifier">ExportedType</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">exportedField</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre></p>

<h2><a class="toc-backref" id="过程-方法调用语法" href="#过程-方法调用语法">方法调用语法</a></h2><p>对于面向对象的编程，可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">.</span><span class="Identifier">methodName</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> 语法，取代 <tt class="docutils literal"><span class="pre"><span class="Identifier">methodName</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">,</span> <span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> 。 如果没有多余的参数，则可以省略括号: <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">.</span><span class="Identifier">len</span></span></tt> (取代 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">)</span></span></tt> )。</p>
<p>此方法调用语法不限于对象，可用于为过程提供任意类型的第一个参数:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Comment"># 等同于 echo len &quot;abc&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpper</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 等同于 writeLine(stdout, &quot;Hallo&quot;)</span></pre></p>
<p>另一种看待方法调用语法的方式是，它是提供缺失的后缀表示法。</p>
<p>方法调用语法与显式泛型实例化冲突: <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 不能写为 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 因为 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 总是被解析为 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span><span class="Punctuation">)</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 。</p>
<p>另请参阅: <a class="reference internal" href="#方法调用语法限制">方法调用语法限制</a>。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">:</span> <span class="Punctuation">]</span></span></tt> 符号是为了缓解这个问题: <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">:</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 由解析器重写为 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Punctuation">:</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span></span></tt> 被重写为 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span></span></tt> . 注意 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">:</span> <span class="Punctuation">]</span></span></tt> 没有AST表示, 直接在解析步骤中进行重写。</p>

<h2><a class="toc-backref" id="过程-属性" href="#过程-属性">属性</a></h2><p>Nim不需要 <em>get-properties</em> : 使用 <em>方法调用语法</em> 调用的普通get-procedure达到相同目的。但set值是不同的; 因而需要一个特殊的setter语法:</p>
<p><pre class="listing">
<span class="Comment">#  asocket 模块</span>
<span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">host</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># cannot be accessed from the outside of the module</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## hostAddr的setter.</span>
  <span class="Comment">## 它访问 'host' 字段并且不是对 `host =` 的递归调用, 如果内置的点访问方法可用, 则首选点访问:</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">##hostAddr的getter</span>
  <span class="Comment">## This accesses the 'host' field and is not a recursive call to</span>
  <span class="Comment">## 它访问 'host' 字段并且不是对 `host` 的递归调用, 如果内置的点访问方法可用, 则首选点访问:</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">asocket</span>
<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre></p>
<p>定义为 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span><span class="Operator">=</span></span></tt> 的proc(后面跟 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> )被称为 <span id="setter_1">setter</span> 。 可以通过常见的反引号表示法显式调用setter:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">;</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span>

<span class="Punctuation">`</span><span class="Identifier">f</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">myObject</span><span class="Punctuation">,</span> <span class="StringLit">&quot;value&quot;</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">f</span><span class="Operator">=</span></span></tt> 可以在 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">value</span></span></tt> 模式中隐式调用，当且仅当 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的类型没有名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 的字段或 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 在当前模块中不可见时。 此规则确保对象字段和访问器可以有相同的名字。在模块内 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">f</span></span></tt> 总是被解释为字段访问，在模块外则被解释为访问器过程调用。</p>

<h2><a class="toc-backref" id="过程-命令调用语法" href="#过程-命令调用语法">命令调用语法</a></h2><p>如果调用在语法上是一个语句，则可以在没有 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 的情况下调用例程。此命令调用语法也适用于表达式。但之后只能有一个参数。这种限制意味着 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span> <span class="Identifier">f</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">f</span> <span class="DecNumber">2</span></span></tt> 被解析为 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span></span></tt> 而不是 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></span></tt> 。 在这种情况下, 方法调用语法可以用来提供更多的参数。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">singlearg</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">20</span><span class="Operator">*</span><span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">singlearg</span> <span class="DecNumber">2</span>  <span class="Comment"># 打印 &quot;1 40&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">fail</span> <span class="Operator">=</span> <span class="Identifier">optarg</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>   <span class="Comment"># 错误。命令调用的参数太多</span>
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">optarg</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span><span class="Punctuation">)</span>     <span class="Comment"># 传统过程调用2个参数</span>
<span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">optarg</span> <span class="Identifier">optarg</span> <span class="DecNumber">8</span>       <span class="Comment"># 与上面相同, 没有括号</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Identifier">y</span></pre></p>
<p>命令调用的语法也不能有复杂的表达式作为参数。例如：<a class="reference internal" href="#过程-匿名过程">匿名过程</a>、<tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt>。没有参数的函数调用仍然需要 () 来区分调用和函数本身优先类的值。</p>

<h2><a class="toc-backref" id="过程-闭包" href="#过程-闭包">闭包</a></h2><p>过程可以出现在模块的顶层，也可以出现在其他作用域中，在这种情况下，称为嵌套过程。 嵌套过程可以从其封闭的作用域访问局部变量，这就变成了一个闭包。 任何捕获的变量都存储在闭包(它的环境)隐藏附加参数中，并且通过闭包及其封闭作用域的引用来访问它们(即, 对它们进行的任意修改在两个地方都是可见的)。 如果编译器确定这是安全的，则会在堆或栈上分配闭包环境。</p>

<h3><a class="toc-backref" id="闭包-在循环中创建闭包" href="#闭包-在循环中创建闭包">在循环中创建闭包</a></h3><p>由于闭包通过引用来捕获局部变量，这种行为往往在循环体内部并不友好。参阅 <a class="reference external" href="system.html#closureScope.t,untyped">closureScope</a> 和 <a class="reference external" href="sugar.html#capture.m,varargs[typed],untyped">capture</a> 来了解如何改变这种行为。</p>

<h2><a class="toc-backref" id="过程-匿名过程" href="#过程-匿名过程">匿名过程</a></h2><p>未命名过程可以用lambda表达式传递给其他过程:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Kyiv&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>过程表达式既可以嵌套在过程中，也可以在上层可执行代码中。<a class="reference external" href="sugar.html">sugar</a> 模块包含 <tt class="docutils literal"><span class="pre"><span class="Operator">=&gt;</span></span></tt> 宏，它为匿名过程提供了更简洁的语法，类似于JavaScript、c#等语言中的lambda。</p>

<h2><a class="toc-backref" id="过程-do-标记" href="#过程-do-标记">Do 标记</a></h2><p>作为一种特殊的简洁表示法， <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 关键字可以用来将匿名过程传递给过程:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="StringLit">&quot;Frankfurt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Tokyo&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Kyiv&quot;</span><span class="Punctuation">]</span>

<span class="Identifier">sort</span><span class="Punctuation">(</span><span class="Identifier">cities</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">int</span><span class="Punctuation">:</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>

<span class="Comment"># 使用方法加命令语法减少括号:</span>
<span class="Identifier">cities</span> <span class="Operator">=</span> <span class="Identifier">cities</span><span class="Operator">.</span><span class="Identifier">map</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">string</span><span class="Punctuation">:</span>
  <span class="StringLit">&quot;City of &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">x</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 写在包含常规过程参数的圆括号之后。 由 <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 块表示的过程表达式，将作为最后一个参数附加到例程调用。 在使用命令语法的调用中， <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 块将绑定到前面紧靠的表达式，而不是命令调用。</p>
<p>带参数列表或编译指示列表的 <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 对应于匿名的 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> ,但是不带参数或编译指示中的 <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 被视为常规语句列表。 这允许宏接收缩进语句列表作为内联调用的参数，以及Nim例程语法的直接镜像。</p>
<p><pre class="listing">
<span class="Comment"># 将语句列表传递给内联宏:</span>
<span class="Identifier">macroResults</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Punctuation">`</span><span class="Identifier">ex</span><span class="Punctuation">`</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Punctuation">`</span><span class="Identifier">info</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: Check failed: &quot;</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Identifier">expString</span><span class="Punctuation">`</span>

<span class="Comment"># 处理宏中的例程定义:</span>
<span class="Identifier">rpc</span><span class="Punctuation">(</span><span class="Identifier">router</span><span class="Punctuation">,</span> <span class="StringLit">&quot;add&quot;</span><span class="Punctuation">)</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">int</span><span class="Punctuation">:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span></pre></p>

<h2><a class="toc-backref" id="过程-函数" href="#过程-函数">函数</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> 关键字是引入 <tt class="docutils literal"><span class="pre"><span class="Identifier">noSideEffect</span></span></tt> 过程的快捷方式。</p>
<p><pre class="listing">
<span class="Keyword">func</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>是它的简写:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">binarySearch</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">elem</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffect</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="过程-例程" href="#过程-例程">例程</a></h2><p>例程是一类标识符: <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">method</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">macro</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">template</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">converter</span></span></tt> 。</p>

<h2><a class="toc-backref" id="过程-类型绑定操作符" href="#过程-类型绑定操作符">类型绑定操作符</a></h2><p>类型绑定操作符是名称以 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> 开头的 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> ，但不是运算符(即只是包含符号而矣，如 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt>)。它们与以 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> 结尾的setter无关(参阅<a class="reference internal" href="#过程-属性">属性</a>)。为类型声明的类型绑定操作符，不论是否在作用域中(包括是否私有)，都将应用于该类型。</p>
<p><pre class="listing">
<span class="Comment"># foo.nim:</span>
<span class="Keyword">var</span> <span class="Identifier">witness</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">type</span> <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Identifier">initFoo</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">witness</span><span class="Operator">.</span><span class="Identifier">inc</span> <span class="Comment"># type bound operator</span>

<span class="Comment"># main.nim:</span>
<span class="Keyword">import</span> <span class="Identifier">foo</span>
<span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">initFoo</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
  <span class="Identifier">doAssert</span> <span class="Identifier">witness</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">doAssert</span> <span class="Identifier">witness</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">initFoo</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
  <span class="Identifier">doAssert</span> <span class="Identifier">witness</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Comment"># can be called explicitly, even without being in scope</span>
  <span class="Identifier">doAssert</span> <span class="Identifier">witness</span> <span class="Operator">==</span> <span class="DecNumber">2</span>
<span class="Comment"># 在退出作用域时仍然会被调用</span>
<span class="Identifier">doAssert</span> <span class="Identifier">witness</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p>类型绑定操作符: <tt class="docutils literal"><span class="pre"><span class="Operator">=</span><span class="Identifier">destroy</span> <span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">copy</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Operator">=</span><span class="Identifier">sink</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Operator">=</span><span class="Identifier">trace</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Operator">=</span><span class="Identifier">deepcopy</span></span></tt> 。</p>
<p>这些操作被 <em>overridden</em> &quot;重写&quot;, 而不是 <em>overloaded</em> &quot;重载&quot;。这意味着实现会自动提升为结构化类型。 例如，如果类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 有一个重写的赋值运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> ,这个操作符也可用于类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 的赋值。</p>
<p>由于这些操作被绑定到一个类型，为了实现的简单性，它们必须绑定到一个名义上的类型; 这意味着一个被重写的 <tt class="docutils literal"><span class="pre"><span class="Identifier">deepCopy</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">T</span></span></tt> 是真正绑定到 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 而不是 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">T</span></span></tt> 。 这也意味着，不能同时重写 <tt class="docutils literal"><span class="pre"><span class="Identifier">deepCopy</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span> <span class="Identifier">T</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">T</span></span></tt> ，相反，必须为一种指针类型使用distinct或object辅助类型。</p>
<p>想了解关于这些过程的更多细节，参阅<a class="reference external" href="destructors.html#lifetimeminustracking-hooks">生命期追踪钩子</a>。</p>

<h2><a class="toc-backref" id="过程-nonoverloadable-内置命令" href="#过程-nonoverloadable-内置命令">Nonoverloadable 内置命令</a></h2><p>从实现简单性考虑(不需要专门的语义检查)，下面的内置过程不能重载:<pre>declared, defined, definedInScope, compiles, sizeof,
is, shallowCopy, getAst, astToStr, spawn, procCall</pre>
</p>
<p>因此，它们更像是关键字，而不是普通标识符，但与关键字不同的是， 重定义可能会 <span id="shadow_1">shadow</span> &quot;隐藏&quot;<a class="reference external" href="system.html">system</a>模块中的定义。 这个列表中的下列内容不应该使用点表示法 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">f</span></span></tt> 。 因为在 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 之前不能进行类型检查:<pre>declared, defined, definedInScope, compiles, getAst, astToStr</pre>
</p>

<h2><a class="toc-backref" id="过程-var-参数" href="#过程-var-参数">Var 参数</a></h2><p>参数的类型可以使用 var 关键字作为前缀:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p>在示例中, <tt class="docutils literal"><span class="pre"><span class="Identifier">res</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">remainder</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">parameters</span></span></tt> 。可以通过过程修改Var形参，且调用者可以拿到更改。 传递给var形参的实参必须是左值。Var形参的实现为隐藏指针。上面的例子相当于:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>
  <span class="Identifier">remainder</span><span class="Punctuation">[</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Keyword">addr</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p>在示例中，var形参或指针用来提供两个返回值。这可以通过返回一个元组这种更简洁的方式来完成:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">res</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">remainder</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p>可以使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">tuple</span> <span class="Identifier">unpacking</span></span></tt> 来访问元组的字段:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># tuple unpacking</span>
<span class="Identifier">assert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">y</span> <span class="Operator">==</span> <span class="DecNumber">3</span></pre></p>
<p><strong>注意</strong>: 对于高效的参数传递来说， <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 形参不是必需的。 因为非var形参不能修改，所以编译器在认为可以加快执行速度的情况下，会更自由地通过引用传递参数。</p>

<h2><a class="toc-backref" id="过程-var-返回类型" href="#过程-var-返回类型">Var 返回类型</a></h2><p>过程、转换器或者迭代器可以返回 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 类型，表示返回的是一个左值，调用者可以修改它:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span>

<span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="DecNumber">6</span>
<span class="Identifier">assert</span> <span class="Identifier">g</span> <span class="Operator">==</span> <span class="DecNumber">6</span></pre></p>
<p>如果隐式创建的指向某地址的指针，有可能在其生命周期之外继续访问它，那么编译器会报告静态错误:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">writeAccessToG</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">g</span> <span class="Comment"># 错误!</span></pre></p>
<p>当迭代器返回元组时，元组的元素也可以是 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 类型:</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">mpairs</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>在标准库中，所有返回 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 类型的例程，都遵循以 <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> 为前缀的命名规范。</p>
<p>通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span></span></tt> 返回的内存是安全的，这由简单的借用规则来保证: 如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 未指向堆的地址(即在 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">X</span></span></tt> 中， <tt class="docutils literal"><span class="pre"><span class="Identifier">X</span></span></tt> 涉及到 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 访问)，那么它必须来自例程的第一个参数。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">forward</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Comment"># 可以, 来自第一个参数。</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">param</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># 我们知道 'forward' 提供了一个从其第一个参数 'x' 得出的地址的视图</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">forward</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 错误: 地址来自 `x` ，</span>
                      <span class="Comment"># 其不是p的第一个参数，</span>
                      <span class="Comment"># 并且存活在栈上。</span></pre></p>
<p>换句话说， <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 所指向的生命周期与第一个参数的生命周期相关联，这就足以验证调用位置的内存安全。 </p>

<h3><a class="toc-backref" id="var-返回类型-未来的方向" href="#var-返回类型-未来的方向">未来的方向</a></h3><p>新版本的 Nim 借用规则将更加准确，比如使用这样的语法:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">other</span><span class="Punctuation">:</span> <span class="Identifier">Y</span><span class="Punctuation">;</span> <span class="Identifier">container</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">X</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Keyword">from</span> <span class="Identifier">container</span></pre></p>
<p>这里的 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Keyword">from</span> <span class="Identifier">contaner</span></span></tt> 显式指定了返回值的地址必须源自第二个参数(本例的 'container')。 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span> <span class="Keyword">from</span> <span class="Identifier">p</span></span></tt> 语句指定了类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">varTy</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">]</span></span></tt>，与 <tt class="docutils literal"><span class="pre"><span class="Identifier">varTy</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">]</span></span></tt> 类型不兼容。</p>

<h2><a class="toc-backref" id="过程-具名返回值优化-nrvo" href="#过程-具名返回值优化-nrvo">具名返回值优化 (NRVO)</a></h2><p><strong>注意</strong>: 本节文档仅描述当前的实现。这部分语言规范将会有变动。 详情请查看链接 <a class="reference external" href="https://github.com/nim-lang/RFCs/issues/230">https://github.com/nim-lang/RFCs/issues/230</a> 。</p>
<p>在例程内部返回值以特殊的 <span id="result_3">result</span> 变量出现。这为实现与 C++ 的 &quot;具名返回值优化&quot; (<span id="nrvo_1">NRVO</span>) 类似的机制创造了条件。 NRVO 指的是 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 内对 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 的操作会直接影响 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span><span class="Operator">/</span><span class="Keyword">var</span> <span class="Identifier">dest</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> (定义 <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span></span></tt>) 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> (给 <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span></span></tt> 赋值) 中的目标 <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span></span></tt> 。 这是通过将 <tt class="docutils literal"><span class="pre"><span class="Identifier">dest</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> 重写为 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="CharLit">'(args, dest)</span></span></tt> 来实现的，其中 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="CharLit">'</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的变体，它返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 并且接收一个与 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 对应的可变参数。</p>
<p>不太正式的示例:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BigT</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Comment"># 上面这段代码大致上会被解释为以下代码</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BigT</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">;</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>假设 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的返回值类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt>。 当 <tt class="docutils literal"><span class="pre"><span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">&gt;=</span> <span class="Identifier">N</span></span></tt> (<tt class="docutils literal"><span class="pre"><span class="Identifier">N</span></span></tt> 依赖于具体实现) 时，编译器就会使用 NRVO。 换句话说，NRVO 适用于 &quot;较大&quot; 的结构体。</p>
<p>即使 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 可能抛出异常，依然会使用 NRVO。这会带来的显著的不同行为:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">BigT</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">16</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">raiseAt</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BigT</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">==</span> <span class="Identifier">raiseAt</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">ValueError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;interception&quot;</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">i</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">BigT</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">doAssert</span> <span class="Identifier">x</span> <span class="Operator">==</span> <span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">]</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>编译器能够检测这些情况并发出警告，但是这个行为默认是关闭的。通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">warning</span><span class="Punctuation">[</span><span class="Identifier">ObservableStores</span><span class="Punctuation">]</span></span></tt> 以及 <tt class="docutils literal"><span class="pre"><span class="Identifier">push</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">pop</span></span></tt> 编译指示可以为一段代码打开这个警告。以上面的代码为例：</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">warning</span><span class="Punctuation">[</span><span class="Identifier">ObservableStores</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="过程-重载下标运算符" href="#过程-重载下标运算符">重载下标运算符</a></h2><p>数组/开放数组/序列的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 下标运算符可以被重载。</p>

<h1><a class="toc-backref" id="方法" href="#方法">方法</a></h1><p>过程总是静态派发，而方法则使用动态派发。为了将动态派发应用在对象上，对象必须是引用类型。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## 表达式的抽象基类</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 一定要重写这个基方法</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">CatchableError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;未重写基方法&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">return</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Comment"># 注意: 这里依赖于动态绑定</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">b</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>在这个例子中，构造函数 <tt class="docutils literal"><span class="pre"><span class="Identifier">newLit</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">newPlus</span></span></tt> 都是过程，因为它们都使用静态绑定，但是 <tt class="docutils literal"><span class="pre"><span class="Identifier">eval</span></span></tt> 是方法因为需要动态绑定。</p>
<p>正如这个例子所示，基方法必须使用 <span id="base_1">base</span> 编译指示修饰。<tt class="docutils literal"><span class="pre"><span class="Identifier">base</span></span></tt> 编译指示对于开发者来说也是一种提醒: 这个基方法 <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> 是推断方法 <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> 所能产生的所有效果的一个基础。</p>
<p><strong>注意</strong>: 目前还不支持方法的编译期执行。</p>
<p><strong>注意</strong>: 从 Nim 0.20 开始，泛型方法已被弃用。</p>

<h2><a class="toc-backref" id="方法-多重方法-multiminusmethods" href="#方法-多重方法-multiminusmethods">多重方法 (Multi-methods)</a></h2><p><strong>Note</strong> 从 Nim 0.20 开始，要启用多重方法，开发者必须在编译时显式添加 <tt class="docutils literal"><span class="pre option">--multimethods:on</span></tt> 参数。</p>
<p>在多重方法中，所有对象类型的参数都会用于方法派发:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Punctuation">,</span> <span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">new</span> <span class="Identifier">a</span>
<span class="Identifier">new</span> <span class="Identifier">b</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># 输出: 2</span></pre></p>

<h2><a class="toc-backref" id="方法-通过-procall-防止动态方法解析" href="#方法-通过-procall-防止动态方法解析">通过 proCall 防止动态方法解析</a></h2><p>通过调用内置的 <span id="systemdotproccall_1">system.procCall</span> 可以防止动态方法解析。 某种程度上它与传统面向对象语言提供的 <span id="super_1">super</span> 关键字类似。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;base&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 调用基方法:</span>
  <span class="Identifier">procCall</span> <span class="Identifier">m</span><span class="Punctuation">(</span><span class="Identifier">Thing</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span></pre></p>

<h1><a class="toc-backref" id="迭代器与-for-循环语句" href="#迭代器与-for-循环语句">迭代器与 for 循环语句</a></h1><p><tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt>:idx 语句是一种迭代容器中元素的抽象机制。它依赖于 <span id="iterator_1">iterator</span> &quot;迭代器&quot;来实现。与 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> 语句类似，<tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 语句也开启了一个 <span id="implicit-block_1">implicit block</span> &quot;隐式代码块&quot;，也就可以使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环声明了迭代变量 - 它们的生命周期持续到循环体的结束。迭代变量的类型根据迭代器的返回值类型推断。</p>
<p>迭代器与过程类似，不过迭代器只能在 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环的上下文中调用。迭代器提供了一种遍历抽象类型的方法。 迭代器里的 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句对于 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环的执行至关重要。当程序执行到 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句时，数据会绑定 到 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环变量，同时控制权也移交到循环体并继续执行。迭代器的局部变量和执行状态在多次调用期间会自动保存。 例如:</p>
<p><pre class="listing">
<span class="Comment"># system 模块中存在如下定义</span>
<span class="Keyword">iterator</span> <span class="Identifier">items</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">char</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">ch</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello world&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># `ch` 是迭代器变量</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span></pre></p>
<p>编译器会生成如下代码，就像是开发者写的一样:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">ch</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Identifier">echo</span> <span class="Identifier">ch</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span></pre></p>
<p>如果迭代器的 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句产生的是元组，那么可以有多个循环变量，个数等于元组的元素数。 第 i 次循环变量的类型就是元组第 i 个元素的类型。换句话说，循环上下文支持隐式元组拆包。</p>

<h2><a class="toc-backref" id="迭代器与-for-循环语句-隐式-itemsslashpairs-调用" href="#迭代器与-for-循环语句-隐式-itemsslashpairs-调用">隐式 items/pairs 调用</a></h2><p>如果循环表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 不是迭代器并且 for 循环只有一个循环变量，则循环表达式会被重写为 <tt class="docutils literal"><span class="pre"><span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span></span></tt>； 即隐式调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt> 迭代器:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span></pre></p>
<p>如果循环恰好有两个循环变量，则隐式调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">pairs</span></span></tt> 迭代器。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">pairs</span></span></tt> 标识符的符号查找在编译器重写之后执行，所以 <tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">pairs</span></span></tt> 的所有重载都能生效。</p>

<h2><a class="toc-backref" id="迭代器与-for-循环语句-一等迭代器" href="#迭代器与-for-循环语句-一等迭代器">一等迭代器</a></h2><p>Nim 中有两种迭代器: <em>inline</em> (内联)和 <em>closure</em> (闭包)迭代器。 <span id="inline-iterator_1">inline iterator</span> &quot;内联迭代器&quot; 总是被编译器内联优化， 这种抽象也就不会带来任何额外开销(零成本抽象)，但代码体积可能大大增加。</p>
<p>请警惕: 在使用内联迭代器时，循环体会被内联进循环中所有的 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句里，所以理想情况是合理地重构迭代器代码使它只包含一条 yield 语句，以免代码体积膨胀。</p>
<p>内联迭代器是二等公民；它们只能作为参数传递给其他内联代码工具，如模板、宏和其他内联迭代器。</p>
<p>相反，<span id="closure-iterator_1">closure iterator</span> &quot;闭包迭代器&quot; 可以更自由地传递:</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">count0</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">yield</span> <span class="DecNumber">0</span>

<span class="Keyword">iterator</span> <span class="Identifier">count2</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span>
  <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">iter</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">iter</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="Identifier">x</span>

<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count0</span><span class="Punctuation">)</span>
<span class="Identifier">invoke</span><span class="Punctuation">(</span><span class="Identifier">count2</span><span class="Punctuation">)</span></pre></p>
<p>闭包迭代器和内联迭代器都有一些限制:</p>
<ol class="simple"><li>目前，闭包迭代器不能在编译期执行。</li>
<li>闭包迭代器可使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句结束循环，但内联迭代器(虽然基本没什么用)不允许使用。</li>
<li>内联迭代器不能递归。</li>
<li>内联迭代器与闭包迭代器都没有特殊的 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 变量。</li>
<li>JS 后端不支持闭包迭代器。</li>
</ol>
<p>如果既不用 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 也不用 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 显式标记迭代器，则默认为内联迭代器。但是将来的版本可能会改动。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span></span></tt> 类型总是约定隐式使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> 调用规范；下面的例子展示了如何使用迭代器实现一个 <span id="collaborative-tasking_1">collaborative tasking</span> &quot;协作任务&quot;系统:</p>
<p><pre class="listing">
<span class="Comment"># simple tasking:</span>
<span class="Keyword">type</span>
  <span class="Identifier">Task</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">a1</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: C&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a1: D&quot;</span>

<span class="Keyword">iterator</span> <span class="Identifier">a2</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: A&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: B&quot;</span>
  <span class="Keyword">yield</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;a2: C&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">Task</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ticker</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">ticker</span> <span class="Keyword">mod</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span>
    <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span>
    <span class="Identifier">x</span><span class="Punctuation">(</span><span class="Identifier">ticker</span><span class="Punctuation">)</span>
    <span class="Identifier">inc</span> <span class="Identifier">ticker</span>

<span class="Identifier">runTasks</span><span class="Punctuation">(</span><span class="Identifier">a1</span><span class="Punctuation">,</span> <span class="Identifier">a2</span><span class="Punctuation">)</span></pre></p>
<p>可以使用内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">finished</span></span></tt> 判断迭代器是否结束；如果迭代器已经结束，再次调用也不会抛出异常。</p>
<p>请注意 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">finished</span></span></tt> 容易用错，因为它只在迭代器最后一次循环完成后的下一次迭代才返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">x</span>
    <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># 实例化迭代器</span>
<span class="Keyword">while</span> <span class="Keyword">not</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>

<span class="Comment"># 输出</span>
<span class="DecNumber">1</span>
<span class="DecNumber">2</span>
<span class="DecNumber">3</span>
<span class="DecNumber">0</span></pre></p>
<p>所以这段代码应该这么写:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">mycount</span> <span class="Comment"># 实现化迭代器</span>
<span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">value</span> <span class="Operator">=</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">if</span> <span class="Identifier">finished</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">break</span> <span class="Comment"># 丢弃这次的返回值!</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span></pre></p>
<p>为了便于理解，可以这样认为，迭代器实际上返回了键值对 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">value</span><span class="Punctuation">,</span> <span class="Identifier">done</span><span class="Punctuation">)</span></span></tt>，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">finished</span></span></tt> 的作用就是访问隐藏的 <tt class="docutils literal"><span class="pre"><span class="Identifier">done</span></span></tt> 字段。</p>
<p>闭包迭代器是 <em>可恢复函数</em> ，因此每次调用必须提供参数。如果需要绕过这个限制，可以通过工厂过程构造闭包迭代器，并在构造的时候捕获参数:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span>
    <span class="Keyword">while</span> <span class="Identifier">x</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">x</span>
      <span class="Identifier">inc</span> <span class="Identifier">x</span>

<span class="Keyword">let</span> <span class="Identifier">foo</span> <span class="Operator">=</span> <span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre></p>
<p>借助 for 循环宏可以把这个函数调用变得像是在使用内联迭代器:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>
<span class="Keyword">macro</span> <span class="Identifier">toItr</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">ForLoopStmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">let</span> <span class="Identifier">call</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Comment"># 把 foo 拿从 toItr(foo) 里出来</span>
  <span class="Keyword">let</span> <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Keyword">block</span><span class="Punctuation">:</span>
      <span class="Keyword">let</span> <span class="Identifier">itr</span> <span class="Operator">=</span> <span class="Punctuation">`</span><span class="Identifier">call</span><span class="Punctuation">`</span>
      <span class="Keyword">for</span> <span class="Punctuation">`</span><span class="Identifier">expr</span><span class="Punctuation">`</span> <span class="Keyword">in</span> <span class="Identifier">itr</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
          <span class="Punctuation">`</span><span class="Identifier">body</span><span class="Punctuation">`</span>

<span class="Keyword">for</span> <span class="Identifier">f</span> <span class="Keyword">in</span> <span class="Identifier">toItr</span><span class="Punctuation">(</span><span class="Identifier">mycount</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># 使用上文的 `proc mycount`</span>
  <span class="Identifier">echo</span> <span class="Identifier">f</span></pre></p>
<p>因为闭包迭代器需要以完整的函数调用机制作为支撑，所以代价比调用内联迭代器更高。像这样在使用闭包迭代器的地方用宏装饰一下，或许是一种有益的提醒。</p>
<p>工厂过程 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 同普通的过程一样也可以递归。利用上面的宏可让这种过程的递归看起来像是递归迭代器在递归。比如:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">recCountDown</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">iterator</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span>
      <span class="Keyword">for</span> <span class="Identifier">e</span> <span class="Keyword">in</span> <span class="Identifier">toItr</span><span class="Punctuation">(</span><span class="Identifier">recCountDown</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
        <span class="Keyword">yield</span> <span class="Identifier">e</span>

<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">toItr</span><span class="Punctuation">(</span><span class="Identifier">recCountDown</span><span class="Punctuation">(</span><span class="DecNumber">6</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># 输出: 6 5 4 3 2 1</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre></p>
<p>另请参阅<a class="reference internal" href="#iterable">iterable</a>，将迭代器传递给模板和宏。</p>

<h1><a class="toc-backref" id="转换器" href="#转换器">转换器</a></h1><p>转换器和普通过程相似，但它增强了&quot;隐式转换&quot;类型的关系，参阅<a class="reference internal" href="#转换关系">转换关系</a>:</p>
<p><pre class="listing">
<span class="Comment"># 前方代码风格不好: Nim 不是 C。</span>
<span class="Keyword">converter</span> <span class="Identifier">toBool</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="DecNumber">0</span>

<span class="Keyword">if</span> <span class="DecNumber">4</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;compiles&quot;</span></pre></p>
<p>开发者可以显式调用转换器以提高代码的可读性。 请注意编译不支持隐式转换器的链式调用: 假设存在 A 类型到 B 类型和 B 类型到 C 类型的转换器，Nim 不提供从 A 转换为 C 类型的隐式转换。</p>

<h1><a class="toc-backref" id="type-段" href="#type-段">Type 段</a></h1><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Comment"># 展示相互递归类型的例子</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>  <span class="Comment"># 由垃圾收集器管理的对象(ref)</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># 左子树和右子树</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># 叶子包含对 Sym 的引用</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># 符号</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># 符号的名称</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># 符号声明的行数</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>       <span class="Comment"># 符号的抽象语法树</span></pre></p>
<p>类型段由 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 关键字开启。它包含多个类型定义。类型定义是给类型绑定一个名称。类型定义可以是递归的甚至是相互递归的。相互递归类型只能在同一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 段中出现。 像 <tt class="docutils literal"><span class="pre"><span class="Identifier">objects</span></span></tt> 或者 <tt class="docutils literal"><span class="pre"><span class="Identifier">enums</span></span></tt> 这样的名义类型仅能在 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 段中定义。</p>

<h1><a class="toc-backref" id="异常处理" href="#异常处理">异常处理</a></h1>
<h2><a class="toc-backref" id="异常处理-try-语句" href="#异常处理-try-语句">Try 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Comment"># 从文本文件的前两行中读取数字</span>
<span class="Comment"># 并尝试把数字加起来</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;两数之和: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowDefect</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;溢出!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">,</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;捕获多个异常!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;未知异常!&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 之后的语句顺序执行，直到有异常 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 抛出。如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 的异常类型能够匹配 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 子句列出的异常类型，则执行对应的代码。 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 子句之后的代码被称为 <span id="exception-handlers_1">exception handlers</span> &quot;异常处理程序&quot;。</p>
<p>如果程序抛出了未列出的异常，则执行空的 <span id="except_1">except</span> 子句，类似于 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句的 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 子句。</p>
<p>如果存在 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 子句，那么 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt>:idx 子句总会在异常处理程序之后得以执行。</p>
<p>异常处理程序会 <em>吃掉</em> 异常。然而异常处理程序也可能抛出新的异常。如果没有处理这个异常，则会通过调用栈传递出去。这种情况往往意味着，所在过程剩下的那些不属于 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 子句的代码不被执行。</p>

<h2><a class="toc-backref" id="异常处理-try-表达式" href="#异常处理-try-表达式">Try 表达式</a></h2><p>try 也可以用作表达式；<tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 分支的类型与 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 分支相兼容，而 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 分支的类型必须是 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span>
        <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span>
        <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hi&quot;</span></pre></p>
<p>为了防止写出令人迷惑的代码，解析时做了限制: 如果 <tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 语句在 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span></span></tt> 之后，则必须写成一行:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="StringLit">&quot;133a&quot;</span><span class="Punctuation">)</span> <span class="Keyword">except</span><span class="Punctuation">:</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="异常处理-except-子句" href="#异常处理-except-子句">Except 子句</a></h2><p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 子句中，可使用下面的语法访问当前抛出的异常:</p>
<p><pre class="listing">
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span> <span class="Keyword">as</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
  <span class="Comment"># 现在可以使用 &quot;e&quot;</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I/O error: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span></pre></p>
<p>或者使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">getCurrentException</span></span></tt> 获取当前抛出的异常。</p>
<p><pre class="listing">
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 现在可以使用 &quot;e&quot;</span></pre></p>
<p>注意，<tt class="docutils literal"><span class="pre"><span class="Identifier">getCurrentException</span></span></tt> 总是返回 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span> <span class="Identifier">Exception</span></span></tt> 类型。如果需要使用具体类型(比如上面例子中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">IOError</span></span></tt>)的变量，则需要显式转换:</p>
<p><pre class="listing">
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">ref</span> <span class="Identifier">IOError</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># 现在 &quot;e&quot; 是具体的异常类型了</span></pre></p>
<p>但是这种需求很少见。最常见的使用场景是从 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 中提取错误信息，使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">getCurrentExceptionMsg</span></span></tt> 已经足够了:</p>
<p><pre class="listing">
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Comment"># ...</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="异常处理-自定义异常" href="#异常处理-自定义异常">自定义异常</a></h2><p>可以创建自定义异常。自定义异常是一种自定义类型:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">LoadError</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Exception</span></pre></p>
<p>自定义异常的名称建议以 <tt class="docutils literal"><span class="pre"><span class="Identifier">Error</span></span></tt> 结尾。</p>
<p>自定义异常可以像其他异常一样抛出，例如:</p>
<p><pre class="listing">
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">LoadError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Failed to load data&quot;</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="异常处理-defer-语句" href="#异常处理-defer-语句">Defer 语句</a></h2><p>使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">defer</span></span></tt> 语句代替 <tt class="docutils literal"><span class="pre"><span class="Keyword">try</span> <span class="Keyword">finally</span></span></tt> 语句可以避免代码的复杂嵌套，从作用域的角度看也更加灵活。下面给了例子。</p>
<p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">defer</span></span></tt> 之后的任意语句，都认为处在当前块的隐式try块中:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
  <span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span></pre></p>
<p>重写为:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;def&quot;</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre></p>
<p>当 <tt class="docutils literal"><span class="pre"><span class="Keyword">defer</span></span></tt> 位于模板/宏的最外层作用域时，它的作用域将延伸到调用模板/宏的那个代码块中:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">safeOpenDefer</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">path</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
  <span class="Keyword">defer</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>

<span class="Keyword">template</span> <span class="Identifier">safeOpenFinally</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">path</span><span class="Punctuation">,</span> <span class="Identifier">body</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Identifier">body</span> <span class="Comment"># 若不使用 `defer` ，`body` 必须指定为参数</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>

<span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Identifier">safeOpenDefer</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;/tmp/z01.txt&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Identifier">safeOpenFinally</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;/tmp/z01.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 增加一级词法作用域</span>
<span class="Keyword">block</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="StringLit">&quot;/tmp/z01.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">f</span><span class="Operator">.</span><span class="Identifier">write</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># 增加一级词法作用域</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span> <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre></p>
<p>Nim 不允许在最顶层使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">defer</span></span></tt> 语句，因为不确定这样的语句涉及哪些内容。</p>

<h2><a class="toc-backref" id="异常处理-raise-语句" href="#异常处理-raise-语句">Raise 语句</a></h2><p>例如:</p>
<p><pre class="listing">
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO 失败&quot;</span><span class="Punctuation">)</span></pre></p>
<p>除了数组索引，内存分配等内置操作之外， <tt class="docutils literal"><span class="pre"><span class="Keyword">raise</span></span></tt> 语句是抛出异常的唯一方法。</p>
<p>如果没有给出异常的名称，则 <span id="reminusraised_1">re-raised</span> &quot;重新抛出&quot; 当前异常。如果当前没有异常可以重新抛出，则会抛出 <span id="reraisedefect_1">ReraiseDefect</span> 异常。这遵循 <tt class="docutils literal"><span class="pre"><span class="Keyword">raise</span></span></tt> 语句 <em>总是</em> 抛出异常的规则。</p>

<h2><a class="toc-backref" id="异常处理-异常的层级" href="#异常处理-异常的层级">异常的层级</a></h2><p>异常树被定义在<a class="reference external" href="system.html">system</a>模块中。每个异常都继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Exception</span></span></tt> 。表示程序错误的异常继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Defect</span></span></tt> (它是<tt class="docutils literal"><span class="pre"><span class="Identifier">Exception</span></span></tt>的子类型)，因为它们可以被映射到终止整个进程的操作中，因此将不能捕捉。如果恐慌变为异常，则这些异常继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">Defect</span></span></tt> 。</p>
<p>表示可捕获的其它运行时错误的异常从 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">CatchableError</span></span></tt>(它是 <tt class="docutils literal"><span class="pre"><span class="Identifier">Exception</span></span></tt> 的子类) 继承。</p>

<h2><a class="toc-backref" id="异常处理-导入的异常" href="#异常处理-导入的异常">导入的异常</a></h2><p>导入的 C++ 异常也可以抛出和捕获。使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 导入的类型可以抛出和捕获。异常通过值抛出，通过引用捕获。 例子如下:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">CStdException</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::exception&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;exception&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">inheritable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Comment">## 异常不继承自 `RootObj`, 所以我们使用 `inheritable` 关键字</span>
  <span class="Identifier">CRuntimeError</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::runtime_error&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdexcept&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">CStdException</span>
    <span class="Comment">## `CRuntimeError` 没有默认构造器 =&gt; `requiresInit`</span>
<span class="Keyword">proc</span> <span class="Identifier">what</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">CStdException</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;((char *)#.what())&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">initRuntimeError</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">CRuntimeError</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::runtime_error(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">constructor</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">initStdException</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">CStdException</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::exception()&quot;</span><span class="Punctuation">,</span> <span class="Identifier">constructor</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">fn</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">initRuntimeError</span><span class="Punctuation">(</span><span class="StringLit">&quot;foo&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">doAssert</span> <span class="Operator">$</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">what</span> <span class="Operator">==</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="Keyword">var</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">initRuntimeError</span><span class="Punctuation">(</span><span class="StringLit">&quot;foo2&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">CStdException</span> <span class="Keyword">as</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
    <span class="Identifier">doAssert</span> <span class="Identifier">e</span> <span class="Keyword">is</span> <span class="Identifier">CStdException</span>
    <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">what</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">doAssert</span> <span class="Operator">$</span><span class="Identifier">b</span> <span class="Operator">==</span> <span class="StringLit">&quot;foo2&quot;</span>
  
  <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">initStdException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">CStdException</span><span class="Punctuation">:</span> <span class="Keyword">discard</span>
  
  <span class="Keyword">try</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">initRuntimeError</span><span class="Punctuation">(</span><span class="StringLit">&quot;foo3&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">CRuntimeError</span> <span class="Keyword">as</span> <span class="Identifier">e</span><span class="Punctuation">:</span>
    <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">what</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">CStdException</span><span class="Punctuation">:</span>
    <span class="Identifier">doAssert</span> <span class="Identifier">false</span>
  <span class="Identifier">doAssert</span> <span class="Operator">$</span><span class="Identifier">b</span> <span class="Operator">==</span> <span class="StringLit">&quot;foo3&quot;</span>

<span class="Identifier">fn</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p><strong>注意</strong> <tt class="docutils literal"><span class="pre"><span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 不能用于从 C++ 导入的异常。开发者需要使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span> <span class="Identifier">ImportedException</span> <span class="Keyword">as</span> <span class="Identifier">x</span><span class="Punctuation">:</span></span></tt> 语句并且依靠对象 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 本身的功能获取异常的具体信息。</p>

<h1><a class="toc-backref" id="effect-系统" href="#effect-系统">Effect 系统</a></h1><p><strong>注意</strong>: Nim 1.6 版本编译器改动了 effect 追踪的规则。本小节介绍了通过 <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">experimental</span><span class="Punctuation">:</span><span class="Identifier">strictEffects</span></span></tt> 选项启用的新规则。</p>

<h2><a class="toc-backref" id="effect-系统-异常追踪" href="#effect-系统-异常追踪">异常追踪</a></h2><p>Nim 支持异常追踪。 <span id="raises_1">raises</span> 编译指示可以显式定义过程/迭代器/方法/转换器所允许抛出的异常。编译期会加以验证:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">OSError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre></p>
<p>空的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表(<tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt>)表示不允许抛出异常:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Identifier">unsafeCall</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表也可以附加到过程类型上。这会影响类型兼容性:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Callback</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span>
  <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Callback</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">p</span> <span class="Comment"># type error</span></pre></p>
<p>对于例程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 来说，编译器使用推断规则来判断可能引发的异常的集合; 算法在 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的调用图上运行:</p>
<ol class="simple"><li>对过程类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 的每个间接调用都假定产生 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Exception</span></span></tt> (所有异常的基类)，即任意异常都有可能，除非 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 拥有显式的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表。 不过，如果是以 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></span></tt> 的形式调用并且 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span></span></tt> 是当前分析的例程的参数，而且并被标记 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">effectsOf</span><span class="Punctuation">:</span> <span class="Identifier">f</span></span></tt>，那么忽略它。 乐观地假定这类调用没有 effect。 第二条规则对这种情况有所补充。</li>
<li>当某过程类型的表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 是作为过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的标记为 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">effectsOf</span></span></tt> 的参数传入的，对 <tt class="docutils literal"><span class="pre"><span class="Identifier">e</span></span></tt> 的调用会被视为间接调用，它的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表会加入到 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表。</li>
<li>所有对方法体未知(因为声明前置)的过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 的调用都会被看作抛出 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Exception</span></span></tt> 除非 <tt class="docutils literal"><span class="pre"><span class="Identifier">q</span></span></tt> 显式定义了 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表。 <tt class="docutils literal"><span class="pre"><span class="Identifier">importc</span></span></tt> 导入的过程，若没有显式声明 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表，则默认视为 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt>。</li>
<li>方法 <tt class="docutils literal"><span class="pre"><span class="Identifier">m</span></span></tt> 每一次调用都假定会抛出 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Exception</span></span></tt>，除非显式声明了 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表。</li>
<li>对于其他的调用，Nim 可以分析推断出确切的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表。</li>
<li>推断 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表时，Nim 会考虑它里面的 <tt class="docutils literal"><span class="pre"><span class="Keyword">raise</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 语句。</li>
</ol>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 异常追踪机制不追踪继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Defect</span></span></tt> 的异常。这样更能跟内置运算符保持一致。 下面的代码是合法的:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">mydiv</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span> <span class="Comment"># 会抛出 DivByZeroDefect 异常</span></pre></p>
<p>同理，下面的代码也是合法的:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">mydiv</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">DivByZeroDefect</span><span class="Punctuation">,</span> <span class="StringLit">&quot;除数为 0&quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span></pre></p>
<p>这是因为 <tt class="docutils literal"><span class="pre"><span class="Identifier">DivByZeroDefect</span></span></tt> 继承自 <tt class="docutils literal"><span class="pre"><span class="Identifier">Defect</span></span></tt>，再加上 <tt class="docutils literal"><span class="pre option">--panics:on</span></tt> 选项 Defect 异常就变成了不可修复性错误。(自从 Nim 1.4 开始)</p>

<h2><a class="toc-backref" id="effect-系统-effectsof-编译指示" href="#effect-系统-effectsof-编译指示">EffectsOf 编译指示</a></h2><p>异常追踪推断规则(见之前的小节)的第一条与第二条确保可以获得下面的预期效果:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">我们不抛异常但是回调可能抛</span><span class="Punctuation">(</span><span class="Identifier">callback</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">effectsOf</span><span class="Punctuation">:</span> <span class="Identifier">callback</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">callback</span><span class="Punctuation">(</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">抛异常</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">use</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 编译失败! 会抛出 IOError 错误!</span>
  <span class="Identifier">我们不抛异常但是回调可能抛</span><span class="Punctuation">(</span><span class="Identifier">抛异常</span><span class="Punctuation">)</span></pre></p>
<p>如这个例子所示， <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></span></tt> 类型的参数可以标记为 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">effectsOf</span></span></tt> 。这样的参数带来了 effect 多态: 过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">我们不抛异常但是回调可能抛</span></span></tt> 可以抛出 <tt class="docutils literal"><span class="pre"><span class="Identifier">callback</span></span></tt> 所抛出的异常。</p>
<p>所以在很多情况下，回调并不会导致编译器在 effect 分析中过于保守:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">warningAsError</span><span class="Punctuation">[</span><span class="Identifier">Effect</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;strictEffects&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">import</span> <span class="Identifier">algorithm</span>

<span class="Keyword">type</span>
  <span class="Identifier">MyInt</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">toSort</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">MyInt</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">MyInt</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="Identifier">MyInt</span> <span class="DecNumber">3</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">cmpN</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">MyInt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">harmless</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">toSort</span><span class="Operator">.</span><span class="Identifier">sort</span> <span class="Identifier">cmpN</span>

<span class="Keyword">proc</span> <span class="Identifier">cmpE</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">MyInt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">Exception</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">harmful</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 不会通过编译， `sort` 现在会抛出异常</span>
  <span class="Identifier">toSort</span><span class="Operator">.</span><span class="Identifier">sort</span> <span class="Identifier">cmpE</span></pre></p>

<h2><a class="toc-backref" id="effect-系统-标签追踪" href="#effect-系统-标签追踪">标签追踪</a></h2><p>异常追踪是 <span id="effect-system_1">effect system</span> &quot;Effect 系统&quot;的一部分。抛出异常是一个 <em>effect</em> 。当然可以定义其他 effect 。自定义 effect 是一种给例程打 <em>标签</em> 并做检查的方法:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## 输入/输出 effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">no_effects_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 编译器禁止这么做:</span>
  <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>标签必须是类型名称。同 <tt class="docutils literal"><span class="pre"><span class="Identifier">raises</span></span></tt> 列表一样，<tt class="docutils literal"><span class="pre"><span class="Identifier">tags</span></span></tt> 列表也可以附加到过程类型上。这会影响类型的兼容性。</p>
<p>标签追踪的推断规则与异常追踪的推断规则类型类似。</p>
<p>有一种禁止某些 effect 出现的方法:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">IO</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment">## input/output effect</span>
<span class="Keyword">proc</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">echoLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">no_IO_please</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">forbids</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IO</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># 这是可以的，因为它没有定义任何标签:</span>
  <span class="Identifier">echoLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 编译器会阻止这种情况:</span>
  <span class="Keyword">let</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">forbids</span></span></tt> 编译指示定义了一个被禁止的 effect 的列表 —— 如果任何语句具有这些 effect，则编译会失败。 带有 effect 禁止列表的过程类型是不带这种列表的过程类型的子类型:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">MyEffect</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">type</span> <span class="Identifier">ProcType1</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">forbids</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">MyEffect</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">type</span> <span class="Identifier">ProcType2</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span>

<span class="Keyword">proc</span> <span class="Identifier">caller1</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">ProcType1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">caller2</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">ProcType2</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">effectful</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">tags</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">MyEffect</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">i</span>
<span class="Keyword">proc</span> <span class="Identifier">effectless</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">forbids</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">MyEffect</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">i</span>

<span class="Keyword">proc</span> <span class="Identifier">toBeCalled1</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span> <span class="Identifier">effectful</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toBeCalled2</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">void</span> <span class="Operator">=</span> <span class="Identifier">effectless</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Comment">## 这将会失败，因为toBeCalled1使用了ProcType1所禁止的MyEffect:</span>
<span class="Identifier">caller1</span><span class="Punctuation">(</span><span class="Identifier">toBeCalled1</span><span class="Punctuation">)</span>
<span class="Comment">## 这是可以的，因为toBeCalled2和ProcType1有相同的限制:</span>
<span class="Identifier">caller1</span><span class="Punctuation">(</span><span class="Identifier">toBeCalled2</span><span class="Punctuation">)</span>
<span class="Comment">## 这些都是可以的，因为ProcType2没有副作用限制:</span>
<span class="Identifier">caller2</span><span class="Punctuation">(</span><span class="Identifier">toBeCalled1</span><span class="Punctuation">)</span>
<span class="Identifier">caller2</span><span class="Punctuation">(</span><span class="Identifier">toBeCalled2</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">ProcType2</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">ProcType1</span></span></tt> 的子类型。与 <tt class="docutils literal"><span class="pre"><span class="Identifier">tags</span></span></tt> 编译指示所不同的是，父上下文将:调用具有禁用副作用的其他函数的函数;不继承禁用副作用列表。</p>

<h2><a class="toc-backref" id="effect-系统-副作用" href="#effect-系统-副作用">副作用</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">noSideEffect</span></span></tt> 编译指示用于标记过程和迭代器，说明它们只能通过参数产生副作用。这意味着这个过程或迭代器只能修改参数所涉及的地址，而且返回值只依赖于参数。假如该过程或迭代器的参数中都不是 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt>、 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt>、 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 类型，则不会修改外部内容。</p>
<p>换句话说，如果一个例程既不访问本地线程变量或全局变量，也不调用其他带副作用的例程，则该例程是无副作用的。</p>
<p>如果给予一个过程或迭代器无副作用标记，而编译器却无法验证，将引发静态错误。</p>
<p>作为一个特殊的语义规则，内置的<a class="reference external" href="system.html#debugEcho,varargs[typed,]">debugEcho</a>忽略副作用，这样它就可以用于调试标记为 <tt class="docutils literal"><span class="pre"><span class="Identifier">noSideEffect</span></span></tt> 的例程。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> 是无副作用过程的语法糖:</p>
<p><pre class="listing">
<span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">noSideEffect</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示可覆盖编译器的副作用分析:</p>
<p><pre class="listing">
<span class="Keyword">func</span> <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">noSideEffect</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;test&quot;</span></pre></p>
<p><strong>副作用通常可被推断出来，与异常追踪的推断类似。</strong></p>

<h2><a class="toc-backref" id="effect-系统-gc-安全的作用" href="#effect-系统-gc-安全的作用">GC 安全的作用</a></h2><p>当过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 不访问任何使用了 GC 内存的全局变量( <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 、<tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt> 、<tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 或一个闭包)时 —— 无论是直接访问还是通过调用不是 GC 安全的过程进行间接访问 —— 我们就称 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 是 <span id="gc-safe_1">GC safe</span> &quot;GC 安全&quot; 的。</p>
<p><strong>是否 GC 安全通常可被推断出来，与异常追踪的推断类似。</strong></p>
<p><span id="gcsafe_1">gcsafe</span> 注解可把过程标记为 GC 安全的，否则将由编译器推断是否是 GC 安全的。值得注意的是， <tt class="docutils literal"><span class="pre"><span class="Identifier">noSideEffect</span></span></tt> 暗含着 <tt class="docutils literal"><span class="pre"><span class="Identifier">gcsafe</span></span></tt> 。</p>
<p>从 C 语言库导入的例程将总是被看作 <tt class="docutils literal"><span class="pre"><span class="Identifier">gcsafe</span></span></tt>。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">gcsafe</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示块可覆盖编译器的 GC 安全分析:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">someGlobal</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string here&quot;</span>
  <span class="Identifier">perThread</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">proc</span> <span class="Identifier">setPerThread</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Keyword">cast</span><span class="Punctuation">(</span><span class="Identifier">gcsafe</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">deepCopy</span><span class="Punctuation">(</span><span class="Identifier">perThread</span><span class="Punctuation">,</span> <span class="Identifier">someGlobal</span><span class="Punctuation">)</span></pre></p>
<p>另请参阅:</p>
<ul class="simple"><li><a class="reference external" href="mm.html">共享堆内存管理</a>.</li>
</ul>

<h2><a class="toc-backref" id="effect-系统-effects-编译指示" href="#effect-系统-effects-编译指示">Effects 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">effects</span></span></tt> 编译指示用于协助程序员进行作用分析。这条语句可以使编译器输出直到 <tt class="docutils literal"><span class="pre"><span class="Identifier">effects</span></span></tt> 处所有推断出的作用:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">what</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">what</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;IO&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;OS&quot;</span><span class="Punctuation">)</span></pre></p>
<p>编译器输出一条消息，提示可能抛出 <tt class="docutils literal"><span class="pre"><span class="Identifier">IOError</span></span></tt>。<tt class="docutils literal"><span class="pre"><span class="Identifier">OSError</span></span></tt> 不会出现在提示里，因为 <tt class="docutils literal"><span class="pre"><span class="Identifier">effects</span></span></tt> 编译指示所在的分支不会抛出这个异常。</p>

<h1><a class="toc-backref" id="泛型" href="#泛型">泛型</a></h1><p>泛型是 Nim 通过 <span id="type-parameters_1">type parameters</span> &quot;类型参数&quot; 把过程、迭代器或类型参数化的方法。在不同的上下文里，用方括号引入类型参数，或者实例化泛型过程、迭代器及类型。</p>
<p>以下例子展示了如何构建一个泛型二叉树:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Comment"># 二叉树是具有</span>
                              <span class="Comment"># 泛型参数 `T` 的泛型类型。</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>     <span class="Comment"># 左右子树;可能是nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                   <span class="Comment"># 存储在节点中的数据</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># 节点的构造函数</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">le</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">data</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 向树中插入一个节点</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># 使用泛型的 `cmp` 过程，比较数据项;</span>
      <span class="Comment"># 这适用于任意具有 `==` 和 `&lt;` 运算符的类型</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 便捷过程:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 二叉树预遍历。</span>
  <span class="Comment"># 使用显式堆栈。</span>
  <span class="Comment"># (这比递归迭代器工厂更有效).</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># 将右子树push到堆栈上</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># 并跟踪左子树</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># 用 `string` 实例化二叉树</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 实例化 `newNode` 和 `add`</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># 实例化 `add` 过程</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre></p>
<p>这里的 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 称为 <span id="generic-type-parameter_1">generic type parameter</span> &quot;泛型类型参数&quot;，或者 <span id="type-variable_1">type variable</span> &quot;类型变量&quot;。</p>

<h2><a class="toc-backref" id="泛型-is-运算符" href="#泛型-is-运算符">Is 运算符</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">is</span></span></tt> 运算符用来在语义分析期间检查类型的等价性。在泛型代码中利用这个运算符编写类型相关的代码:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">keys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">]</span>
    <span class="Identifier">values</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Value</span><span class="Punctuation">]</span>
    <span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">Key</span> <span class="Keyword">is</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Comment"># 对于字符串类型做优化: 用空值代表已删除</span>
      <span class="Identifier">deletedKeys</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span></pre></p>

<h2><a class="toc-backref" id="泛型-类型类" href="#泛型-类型类">类型类</a></h2><p>类型类是特殊的伪类型，可在重载解析或使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">is</span></span></tt> 运算符时针对性地匹配某些类型。Nim 支持以下内置类型类:</p>
<table border="1" class="docutils"><tr><th>类型类</th><th>匹配</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt></td><td>任意对象类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">tuple</span></span></tt></td><td>任意元组类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">enum</span></span></tt></td><td>任意枚举类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt></td><td>任意过程类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt></td><td>任意 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt></td><td>任意 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt></td><td>任意 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Keyword">distinct</span></span></tt></td><td>任意 distinct 类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">array</span></span></tt></td><td>任意数组类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">set</span></span></tt></td><td>任意集合类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">seq</span></span></tt></td><td>任意序列类型</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">auto</span></span></tt></td><td>任意类型</td></tr>
</table><p>此外，任何泛型类型都会自动创建一个同名的类型类，可匹配该泛型类的任意实例。</p>
<p>类型类通过标准的布尔运算符可组合成更复杂的类型类。</p>
<p><pre class="listing">
<span class="Comment"># 创建一个可以匹配所有元组类型和对象类型的类型类</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre></p>
<p>泛型参数列表中的参数类型约束可以通过 <tt class="docutils literal"><span class="pre"><span class="Punctuation">,</span></span></tt> 进行分组，并以 <tt class="docutils literal"><span class="pre"><span class="Punctuation">;</span></span></tt> 结束，就像宏和模板中的参数列表那样:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">fn1</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">U</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">:</span> <span class="Identifier">SomeFloat</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>    <span class="Comment"># T 没有类型约束</span>
<span class="Keyword">template</span> <span class="Identifier">fn2</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">;</span> <span class="Identifier">u</span><span class="Punctuation">,</span> <span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">SomeFloat</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>  <span class="Comment"># t 没有类型约束</span></pre></p>
<p>虽然类型类在语法上接近于类 ML 语言中的代数数据类型 (ADT)，但应该知道，类型类只是实例化时所必须遵守的静态约束。类型类本身并非真的类型，只是一种检查系统，检查泛型是否最终被 <em>解析</em> 成某种单一类型。与对象、变量和方法不同，类型类不允许运行时的类型动态特性。</p>
<p>例如，以下代码无法通过编译:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="Identifier">int</span> <span class="Operator">|</span> <span class="Identifier">string</span>
<span class="Keyword">var</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">TypeClass</span> <span class="Operator">=</span> <span class="DecNumber">2</span> <span class="Comment"># foo的类型在这里被解释为 int 类型</span>
<span class="Identifier">foo</span> <span class="Operator">=</span> <span class="StringLit">&quot;this will fail&quot;</span> <span class="Comment"># 这里发生错误，因为 foo 是 int</span></pre></p>
<p>Nim 允许将类型类和常规类型用作泛型类型参数的 <span id="type-constraints_1">type constraints</span> &quot;类型约束&quot;:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">onlyIntOrString</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Operator">|</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="DecNumber">450</span><span class="Punctuation">,</span> <span class="DecNumber">616</span><span class="Punctuation">)</span> <span class="Comment"># 可以</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="FloatNumber">5.0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.0</span><span class="Punctuation">)</span> <span class="Comment"># 类型不匹配</span>
<span class="Identifier">onlyIntOrString</span><span class="Punctuation">(</span><span class="StringLit">&quot;xy&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">50</span><span class="Punctuation">)</span> <span class="Comment"># 不行，因为同一个 T 不能同时是两种不同的类型</span></pre></p>

<h2><a class="toc-backref" id="泛型-隐式泛型" href="#泛型-隐式泛型">隐式泛型</a></h2><p>一个类型类可以直接作为参数的类型使用。</p>
<p><pre class="listing">
<span class="Comment"># 创建一个可以同时匹配元组和对象类型的类型类</span>
<span class="Keyword">type</span> <span class="Identifier">RecordType</span> <span class="Operator">=</span> <span class="Keyword">tuple</span> <span class="Keyword">or</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">printFields</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">:</span> <span class="Identifier">RecordType</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Identifier">fieldPairs</span><span class="Punctuation">(</span><span class="Identifier">rec</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">key</span><span class="Punctuation">,</span> <span class="StringLit">&quot; = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">value</span></pre></p>
<p>以这种方式使用类型类的过程，被当成是 <span id="implicitly-generic_1">implicitly generic</span> &quot;隐式泛型&quot;。在程序中，对于每个特定参数类型组合时被实例化一次。</p>
<p>通常，重载解析期间，每一个被命名的类型类都将被绑定到单一的具体类型。我们称这些类型类为 <span id="bind-once_1">bind once</span> &quot;单一绑定&quot; 类型。以下是从 system 模块里直接拿来的例子:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Comment">## 需要 `x` 和 `y` 都是相同的元组类型</span>
  <span class="Comment">## 针对元组的泛型运算符 `==` 建立于 `x` 和 `y` 各字段的相等性之上</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">fields</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre></p>
<p>另一种情况是用 <tt class="docutils literal"><span class="pre"><span class="Keyword">distinct</span></span></tt> 修饰类型类，这将允许每一参数绑定到匹配类型类的不同类型。这样的类型类被称为 <span id="bind-many_1">bind many</span> &quot;多绑定&quot; 类型。</p>
<p>使用了隐式泛型的过程，常常需要引用匹配的泛型类型内的类型参数。使用 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> 语法能便捷地实现此功能:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">Rows</span><span class="Punctuation">,</span> <span class="Identifier">Columns</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">m</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Punctuation">,</span> <span class="Identifier">row</span><span class="Punctuation">,</span> <span class="Identifier">col</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">col</span> <span class="Operator">*</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">Matrix</span><span class="Operator">.</span><span class="Identifier">Columns</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">row</span><span class="Punctuation">]</span></pre></p>
<p>下面是关于隐式泛型更多的例子:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">;</span> <span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Operator">.</span><span class="Identifier">Key</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Operator">.</span><span class="Identifier">Value</span>

<span class="Comment"># 大致等同于:</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">Key</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Value</span></pre></p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">)</span>

<span class="Comment"># 大致等同于:</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Keyword">distinct</span> <span class="Identifier">Table</span><span class="Punctuation">)</span>

<span class="Comment"># 大致等同于:</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">,</span> <span class="Identifier">KeyB</span><span class="Punctuation">,</span> <span class="Identifier">ValueB</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">Key</span><span class="Punctuation">,</span> <span class="Identifier">Value</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">KeyB</span><span class="Punctuation">,</span> <span class="Identifier">ValueB</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 作为参数类型使用时，也会产生隐式泛型，<tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 有其独有的规则:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span>

<span class="Comment"># 等同于以下写法:</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 是一个 &quot;多绑定&quot; 类型类:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span>

<span class="Comment"># 大致等同于:</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">T2</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T2</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 类型的参数本身可以作为一个类型使用。如果其作为类型使用，就是底层类型。换言来说，&quot;typedesc&quot; 剥离了一层。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 大致等同于:</span>
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 所以这是合法的:</span>
<span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span>
<span class="Comment"># 这里参数 'a' 需要的是一个类型, 而 'b' 需要的则是一个值。</span></pre></p>

<h2><a class="toc-backref" id="泛型-泛型推断的局限" href="#泛型-泛型推断的局限">泛型推断的局限</a></h2><p>泛型实例化时不会推断出 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">T</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>。下面的例子是不允许的:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">g</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="Identifier">y</span>
<span class="Keyword">proc</span> <span class="Identifier">v</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">y</span> <span class="Operator">+=</span> <span class="DecNumber">100</span>
<span class="Keyword">var</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># 允许: 'T' 被推断为 'int' 类型</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="DecNumber">42</span><span class="Punctuation">)</span>

<span class="Comment"># 不允许: 'T' 不会被推断为 'var int'</span>
<span class="Identifier">g</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Comment"># 也不允许: 明确地通过 'var int' 实例化</span>
<span class="Identifier">g</span><span class="Punctuation">[</span><span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="泛型-泛型中的符号查找" href="#泛型-泛型中的符号查找">泛型中的符号查找</a></h2>
<h3><a class="toc-backref" id="泛型中的符号查找-开放和封闭符号" href="#泛型中的符号查找-开放和封闭符号">开放和封闭符号</a></h3><p>泛型中的符号绑定规则略显微妙: 存在开放和封闭两种符号。封闭的符号在实例化的上下文中无法被重新绑定，而开放的符号则可以。默认情况下，重载符号都是开放的，所有其他符号都是封闭的。</p>
<p>会在两种不同的上下文中查找开放的符号: 一是其定义所处的上下文，二是实例化时的上下文:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Index</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Index</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">borrow</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="FloatNumber">0.</span><span class="Identifier">Index</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span> <span class="Comment"># 可以!</span></pre></p>
<p>在这个例子中，针对元组的泛型 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> (定义于 system 模块) 建立在元组各字段的 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 运算之上。然而，针对 <tt class="docutils literal"><span class="pre"><span class="Identifier">Index</span></span></tt> 类型的 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 定义发生泛型 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 定义 <em>之后</em>；这个例子可以编译，因为实例化关于元组的 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 时，当前定义的关于 <tt class="docutils literal"><span class="pre"><span class="Identifier">Index</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 也会考虑进来。</p>

<h2><a class="toc-backref" id="泛型-mixin-语句" href="#泛型-mixin-语句">Mixin 语句</a></h2><p>符号通过 <span id="mixin_1">mixin</span> 关键字可以声明为开放的:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">create</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># 这里没有 'init' 的重载，我们需要显式的将其声明为一个开放的符号:</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">new</span> <span class="Identifier">result</span>
  <span class="Identifier">init</span> <span class="Identifier">result</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">mixin</span></span></tt> 语句只在模板和泛型中才有意义。</p>

<h2><a class="toc-backref" id="泛型-bind-语句" href="#泛型-bind-语句">Bind 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 语句是 <tt class="docutils literal"><span class="pre"><span class="Keyword">mixin</span></span></tt> 语句的反面。可用于显式地声明标识符需要更早绑定(也就是说应在模板/泛型的定义作用域中查找这些标识符)。</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">lastId</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>但是 <tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 用处不大，因为默认就是从定义作用域绑定符号。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 语句只在模板和泛型中有意义。</p>

<h2><a class="toc-backref" id="泛型-委托绑定语句" href="#泛型-委托绑定语句">委托绑定语句</a></h2><p>下面的示例概述了当泛型的实例化跨越多个不同模块时会出现的一个问题:</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">proc</span> <span class="Identifier">genericA</span><span class="Operator">*</span> <span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">mixin</span> <span class="Identifier">init</span>
  <span class="Identifier">init</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">C</span>

<span class="Comment"># 模块 B</span>
<span class="Keyword">proc</span> <span class="Identifier">genericB</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
      <span class="Comment"># 实例化 `genericB` 时，如果没有 `bind init` 语句，来自模块 C 的 init 过程就是不可用的:</span>
  <span class="Keyword">bind</span> <span class="Identifier">init</span>
  <span class="Identifier">genericA</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 C</span>
<span class="Keyword">type</span> <span class="Identifier">O</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Identifier">init</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">O</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 主模块</span>
<span class="Keyword">import</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span>

<span class="Identifier">genericB</span> <span class="Identifier">O</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>当由实例化 <tt class="docutils literal"><span class="pre"><span class="Identifier">genericB</span></span></tt> 引发实例化 <tt class="docutils literal"><span class="pre"><span class="Identifier">genericA</span></span></tt> 时，模块 B 的作用域中那个来自模块 C 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">init</span></span></tt> 过程未在考虑之中。解决方案是在 <tt class="docutils literal"><span class="pre"><span class="Identifier">genericB</span></span></tt> 中通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 语句 <span id="forward_2">forward</span> &quot;转发&quot; 这个符号。</p>

<h1><a class="toc-backref" id="模板" href="#模板">模板</a></h1><p>模板是简单形式的宏: 它是运行于 Nim 的抽象语法树的简单替换机制。编译器在语义分析阶段处理它。</p>
<p><em>调用</em> 模板的语法和调用过程的语法是相同的。</p>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># 这个定义存在于系统模块中</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># 编译器将其重写为: assert(not (5 == 6))</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">!=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&gt;</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">&gt;=</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">in</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">isnot</span></span></tt> 等运算符实际上都是模板:</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">&gt;</span> <span class="Identifier">b</span></span></tt> 转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span> <span class="Operator">&lt;</span> <span class="Identifier">a</span></span></tt>。<br/><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Keyword">in</span> <span class="Identifier">b</span></span></tt> 转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">contains</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span></span></tt>。<br/><tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">isnot</span></span></tt> 的转换也显而易见。<br/></p><p>模板中的 &quot;类型&quot; 可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 、<tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 等三个符号。这些都是 &quot;元类型&quot; ，它们仅用于特定上下文中。常规类型也可使用；这意味着会得到一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 表达式。</p>

<h2><a class="toc-backref" id="模板-typed-参数和-untyped-参数的比较" href="#模板-typed-参数和-untyped-参数的比较">Typed 参数和 untyped 参数的比较</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 参数表示表达式传递给模板前不执行符号的查找和类型的解析。这意味着，比如，<em>未声明</em> 的标识符也能传递给模板:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 可以</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">3</span></pre></p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 不正确，因为此处 x 没有被声明，所以它没有类型</span></pre></p>
<p>如果一个模板的每个参数都是 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 的，则称它为 <span id="immediate_1">immediate</span> 模板。由于历史原因，模板可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">immediate</span></span></tt> 编译指示显式地标记，这类模板不参与重载解析，参数的类型也将被编译器 <em>忽略</em>。显式声明的即时模板现在已经弃用。</p>
<p><strong>注意</strong>: 由于历史原因， <tt class="docutils literal"><span class="pre"><span class="Identifier">stmt</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 的别名， <tt class="docutils literal"><span class="pre"><span class="Identifier">expr</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 的别名，但它们都被移除了。</p>

<h2><a class="toc-backref" id="模板-传递代码块到模板" href="#模板-传递代码块到模板">传递代码块到模板</a></h2><p>通过专门的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">:</span></span></tt> 语法，可以将一个语句块传递给模板的最后一个参数:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">actions</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>  <span class="Comment"># 专门的冒号</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre></p>
<p>在这个例子中，那两行 <tt class="docutils literal"><span class="pre"><span class="Identifier">writeLine</span></span></tt> 语句被绑定到了模板的 <tt class="docutils literal"><span class="pre"><span class="Identifier">actions</span></span></tt> 参数。</p>
<p>通常，当传递一个代码块到模板时，接受代码块的参数需要被声明为 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 类型。因为这样，符号查找会被推迟到模板实例化期间:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">typed</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hey&quot;</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># 因 p 未声明而失败</span></pre></p>
<p>以上代码错误信息为 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 未被声明。其原因是 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 语句在传递到 <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> 参数前执行类型检查和符号查找。修改模板参数类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 使得传递语句体时不做类型检查，同样的代码便可以通过:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;hey&quot;</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span>

<span class="Identifier">t</span><span class="Punctuation">:</span>
  <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># 编译通过</span></pre></p>

<h2><a class="toc-backref" id="模板-untyped-可变参数" href="#模板-untyped-可变参数">untyped 可变参数</a></h2><p>除了 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 元类型可以阻止类型检查之外，用了 <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span></span></tt> 连参数的个数也不检查的了:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Identifier">hideIdentifiers</span><span class="Punctuation">(</span><span class="Identifier">undeclared1</span><span class="Punctuation">,</span> <span class="Identifier">undeclared2</span><span class="Punctuation">)</span></pre></p>
<p>然而，因为模板不能遍历可变参数，一般而言这个功能在宏中更有用。</p>

<h2><a class="toc-backref" id="模板-模板中的符号绑定" href="#模板-模板中的符号绑定">模板中的符号绑定</a></h2><p>模板是 <span id="hygienic_1">hygienic</span> &quot;卫生&quot; 宏，会新开作用域。大部分符号会在宏的定义作用域中绑定:</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">var</span>
  <span class="Identifier">lastId</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Keyword">template</span> <span class="Identifier">genId</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">lastId</span><span class="Punctuation">)</span>
  <span class="Identifier">lastId</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Identifier">echo</span> <span class="Identifier">genId</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 可以，因为 'lastId' 在 'genId' 的定义作用域中完成绑定</span></pre></p>
<p>像在泛型中一样，模板中的符号绑定也受 <tt class="docutils literal"><span class="pre"><span class="Keyword">mixin</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 语句影响。</p>

<h2><a class="toc-backref" id="模板-标识符的构建" href="#模板-标识符的构建">标识符的构建</a></h2><p>在模板中，标识符可以通过反引号标注构建:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">typ</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">typ</span>
    <span class="Punctuation">`</span><span class="Identifier">P</span> <span class="Identifier">name</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Punctuation">`</span><span class="Identifier">T</span> <span class="Identifier">name</span><span class="Punctuation">`</span>

<span class="Identifier">typedef</span><span class="Punctuation">(</span><span class="Identifier">myint</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">PMyInt</span></pre></p>
<p>在这个例子中， <tt class="docutils literal"><span class="pre"><span class="Identifier">name</span></span></tt> 参数实例化为 <tt class="docutils literal"><span class="pre"><span class="Identifier">myint</span></span></tt>，所以 `T name` 就变为 <tt class="docutils literal"><span class="pre"><span class="Identifier">Tmyint</span></span></tt>。</p>

<h2><a class="toc-backref" id="模板-模板参数的查找规则" href="#模板-模板参数的查找规则">模板参数的查找规则</a></h2><p>模板中的参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 总是会被替换，即使是像 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">p</span></span></tt> 这样的表达式。因此，模板参数可当作字段名称使用，而且一个全局符号会被同名参数所覆盖，即便使用了完全限定也会覆盖:</p>
<p><pre class="listing">
<span class="Comment"># 模块 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># 输出: 'levA levA'</span></pre></p>
<p>但是全局符号可以通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">bind</span></span></tt> 语句适时捕获:</p>
<p><pre class="listing">
<span class="Comment"># 模块 'm'</span>

<span class="Keyword">type</span>
  <span class="Identifier">Lev</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">levA</span><span class="Punctuation">,</span> <span class="Identifier">levB</span>

<span class="Keyword">var</span> <span class="Identifier">abclev</span> <span class="Operator">=</span> <span class="Identifier">levB</span>

<span class="Keyword">template</span> <span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">abclev</span><span class="Punctuation">:</span> <span class="Identifier">Lev</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">bind</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>
  <span class="Identifier">echo</span> <span class="Identifier">abclev</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">abclev</span>

<span class="Identifier">tstLev</span><span class="Punctuation">(</span><span class="Identifier">levA</span><span class="Punctuation">)</span>
<span class="Comment"># 输出: 'levA levB'</span></pre></p>

<h2><a class="toc-backref" id="模板-模板的卫生性" href="#模板-模板的卫生性">模板的卫生性</a></h2><p>默认情况下，模板是 <span id="hygienic_2">hygienic</span> &quot;卫生&quot; 的: 模板内局部声明的标识符，不能在实例化上下文中访问:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">newException</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">exceptn</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">message</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">exceptn</span>  <span class="Comment"># e 在这里被隐式地 gensym</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
  <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">message</span>
  <span class="Identifier">e</span>

<span class="Comment"># 允许这样写:</span>
<span class="Keyword">let</span> <span class="Identifier">e</span> <span class="Operator">=</span> <span class="StringLit">&quot;message&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">IoError</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></pre></p>
<p>模板中声明的符号是否向实例所处作用域公开取决于 <span id="inject_1">inject</span> 和 <span id="gensym_1">gensym</span> 编译指示。被 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt> 编译指示标记的符号不会公开，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">inject</span></span></tt> 编译指示则反之。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 等实体符号默认是 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">converter</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">template</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">macro</span></span></tt> 等默认是 <tt class="docutils literal"><span class="pre"><span class="Identifier">inject</span></span></tt>。 然而，如果实体的名称是由模板参数传入的，那么会标记为 <tt class="docutils literal"><span class="pre"><span class="Identifier">inject</span></span></tt>。</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">actions</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">block</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>  <span class="Comment"># 由于 'f' 是一个模板参数，其被隐式注入</span>
    <span class="Operator">...</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">inject</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt> 编译指示是二类注解；它们在模板定义之外没有语义，也不能被再次封装。</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span> <span class="Identifier">myInject</span><span class="Punctuation">:</span> <span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">template</span> <span class="Identifier">t</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">myInject</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># 无法工作</span></pre></p>
<p>如果不想保持模板的卫生性，我们可以在模板中使用 <span id="dirty_1">dirty</span> 编译指示。<tt class="docutils literal"><span class="pre"><span class="Identifier">inject</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt> 在 <tt class="docutils literal"><span class="pre"><span class="Identifier">dirty</span></span></tt> 模板中没有作用。</p>
<p>标记为 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt> 的符号既不能作为 <tt class="docutils literal"><span class="pre"><span class="Identifier">field</span></span></tt> 用在 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">field</span></span></tt> 语义中，也不能用于 <tt class="docutils literal"><span class="pre"><span class="Identifier">ObjectConstruction</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">value</span><span class="Punctuation">)</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">namedParameterCall</span><span class="Punctuation">(</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="Identifier">value</span><span class="Punctuation">)</span></span></tt> 等语义构造。</p>
<p>其原因在于要让以下代码:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">template</span> <span class="Identifier">tmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="DecNumber">34</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre></p>
<p>按预期执行。</p>
<p>但是这意味着 <tt class="docutils literal"><span class="pre"><span class="Identifier">gensym</span></span></tt> 生成的符号无法用于方法调用语法:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">tmp</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">type</span>
    <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">gensym</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">int</span>
  
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">T</span> <span class="Comment"># 不可以，应该使用: 'echo T(x)' 。</span>

<span class="Identifier">tmp</span><span class="Punctuation">(</span><span class="DecNumber">12</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="模板-方法调用语法的局限" href="#模板-方法调用语法的局限">方法调用语法的局限</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">f</span></span></tt> 里的表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 需要先经过语义检查(意味着符号查找和类型检查)，然后才能决定是否需要重写成 <tt class="docutils literal"><span class="pre"><span class="Identifier">f</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 的形式。因此，当用于调用模板或宏时，<tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> 语法有一些局限:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">declareVar</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">const</span> <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inject</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Comment"># 无法编译:</span>
<span class="Identifier">unknownIdentifier</span><span class="Operator">.</span><span class="Identifier">declareVar</span></pre></p>
<p>在方法调用语义中，无法使用带有模块符号的完全限定标识符，这是 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> 运算符的绑定顺序决定的。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">sequtils</span>

<span class="Keyword">var</span> <span class="Identifier">myItems</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">,</span><span class="DecNumber">7</span><span class="Punctuation">]</span>
<span class="Keyword">let</span> <span class="Identifier">N1</span> <span class="Operator">=</span> <span class="Identifier">count</span><span class="Punctuation">(</span><span class="Identifier">myItems</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 可行</span>
<span class="Keyword">let</span> <span class="Identifier">N2</span> <span class="Operator">=</span> <span class="Identifier">sequtils</span><span class="Operator">.</span><span class="Identifier">count</span><span class="Punctuation">(</span><span class="Identifier">myItems</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 完全限定, 此处可行</span>
<span class="Keyword">let</span> <span class="Identifier">N3</span> <span class="Operator">=</span> <span class="Identifier">myItems</span><span class="Operator">.</span><span class="Identifier">count</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 可行</span>
<span class="Keyword">let</span> <span class="Identifier">N4</span> <span class="Operator">=</span> <span class="Identifier">myItems</span><span class="Operator">.</span><span class="Identifier">sequtils</span><span class="Operator">.</span><span class="Identifier">count</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 非法的, `myItems.sequtils` 无法解析</span></pre></p>
<p>这就是说，当由于某种原因，一个过程需要借助模块名消除歧义时，这个调用就需要使用函数调用的语法来书写。</p>

<h1><a class="toc-backref" id="宏" href="#宏">宏</a></h1><p>宏是一种在编译时运行的特殊函数。通常，宏的输入是所传入的代码的抽象语法树(AST)。宏然后可以对其执行转换，并将转换后的 AST 结果返回。可以用来添加自定义的语言功能，实现 <span id="domainminusspecific-languages_1">domain-specific languages</span> &quot;领域特定语言&quot;。</p>
<p>宏的调用是一种特殊情况，语义分析并<strong>不</strong>完全是自顶向下、从左到右的。相反，语义分析至少发生两次:</p>
<ul class="simple"><li>语义分析识别并解析宏调用。</li>
<li>编译器执行宏正文(可能会调用其他过程)。</li>
<li>将宏调用的 AST 替换为宏返回的 AST。</li>
<li>再次对该区域的代码进行语义分析。</li>
<li>如果宏返回的 AST 包含其他宏调用，则迭代执行。</li>
</ul>
<p>虽然宏支持高级的编译时代码转换，但它们无法更改 Nim 的语法。</p>
<p><strong>风格说明:</strong> 为了代码的可读性，最好选用最弱的但又能满足需要的编程结构。建议如下:</p>
<ol class="simple"><li>尽可能使用常规的过程和迭代器。</li>
<li>其次尽可能使用泛型过程和迭代器。</li>
<li>再次尽可能使用模板。</li>
<li>最后才考虑使用宏。</li>
</ol>

<h2><a class="toc-backref" id="宏-debug-示例" href="#宏-debug-示例">debug 示例</a></h2><p>下面的例子实现了一个接受可变参数的 <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> 命令，功能强大:</p>
<p><pre class="listing">
<span class="Comment"># 导入 `macros` 模块以获得操作 Nim 语法树所需要的 API</span>
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># `args` 是一个 `NimNode` 值列表，每个值对应一个传入参数的 AST</span>
  <span class="Comment"># 宏总是需要返回一个 `NimNode`，本例子返回的是 `nnkStmtList` 节点</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">nnkStmtList</span><span class="Operator">.</span><span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 遍历传入这个宏传递的所有参数:</span>
  <span class="Keyword">for</span> <span class="Identifier">n</span> <span class="Keyword">in</span> <span class="Identifier">args</span><span class="Punctuation">:</span>
    <span class="Comment"># 为语句列表添加 write 调用;</span>
    <span class="Comment"># `toStrLit` 将 AST 转换为字符串形式:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">repr</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># 为语句列表添加 write 调用，输出 &quot;: &quot;</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;write&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Comment"># 为语句列表添加 writeLine 调用，输出值并换行:</span>
    <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newIdentNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;stdout&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>这个宏展开为以下代码:</p>
<p><pre class="listing">
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 的各参数被包装到数组构造函数表达式中。这就是 <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> 能遍历所有 <tt class="docutils literal"><span class="pre"><span class="Identifier">args</span></span></tt> 子节点的原因。</p>

<h2><a class="toc-backref" id="宏-bindsym" href="#宏-bindsym">bindSym</a></h2><p>上面的 <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> 宏依赖于这样一个事实，<tt class="docutils literal"><span class="pre"><span class="Identifier">write</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Identifier">writeLine</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">stdout</span></span></tt> 是在 system 模块中声明的，所以在实例化时的上下文里是可见的。有一种使用绑定标识符 (即 <span id="symbols_1">symbols</span>) 代替未绑定的标识符的方法，这用到了内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">bindSym</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">typed</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newNimNode</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">n</span><span class="Punctuation">:</span>
    <span class="Comment"># 我们通过 'bindSym' 在作用域中绑定符号:</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">toStrLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;write&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">newStrLitNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;writeLine&quot;</span><span class="Punctuation">,</span> <span class="RawData">bindSym&quot;stdout&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="DecNumber">45</span>

<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>这个宏展开为以下代码:</p>
<p><pre class="listing">
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[0]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a[1]&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;x&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>在这个版本的 <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> 中，标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">write</span> <span class="Punctuation">`</span><span class="Identifier">，</span> <span class="Punctuation">`</span><span class="Identifier">writeLine</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">stdout</span></span></tt> 已经绑定，不会重复查找。如示例所示， <tt class="docutils literal"><span class="pre"><span class="Identifier">bindSym</span></span></tt> 确切可以隐式处理重载标识符。</p>
<p>注意，传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">bindSym</span></span></tt> 的标识符名称必须是常量。实验性功能 <tt class="docutils literal"><span class="pre"><span class="Identifier">dynamicBindSym</span></span></tt> (<a class="reference external" href="manual_experimental.html#dynamic-arguments for-bindsym">实验手册</a>)允许动态地计算这个值。</p>

<h2><a class="toc-backref" id="宏-语句后的代码块" href="#宏-语句后的代码块">语句后的代码块</a></h2><p>当以语句形式调用宏时，宏可以接受 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt>，<tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 代码块 (包括诸如带有例程参数的 <tt class="docutils literal"><span class="pre"><span class="Keyword">do</span></span></tt> 等其它形式)。</p>
<p><pre class="listing">
<span class="Keyword">macro</span> <span class="Identifier">performWithUndo</span><span class="Punctuation">(</span><span class="Identifier">task</span><span class="Punctuation">,</span> <span class="Identifier">undo</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Operator">...</span>

<span class="Identifier">performWithUndo</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># 若干行用来执行</span>
  <span class="Comment"># 任务的代码</span>
<span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Comment"># 用来撤消操作的代码</span>

<span class="Keyword">let</span> <span class="Identifier">num</span> <span class="Operator">=</span> <span class="DecNumber">12</span>
<span class="Comment"># 如果没有初始代码块，可只使用一个冒号</span>
<span class="Identifier">match</span> <span class="Punctuation">(</span><span class="Identifier">num</span> <span class="Keyword">mod</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">num</span> <span class="Keyword">mod</span> <span class="DecNumber">5</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;FizzBuzz&quot;</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">_</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Fizz&quot;</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="Identifier">_</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Buzz&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">num</span></pre></p>

<h2><a class="toc-backref" id="宏-for-循环宏" href="#宏-for-循环宏">For 循环宏</a></h2><p>当宏只有一个输入参数，而且这个参数的类型是特殊的 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">ForLoopStmt</span></span></tt> 时， 这个宏可以重写整个 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">example</span><span class="Punctuation">(</span><span class="Identifier">loop</span><span class="Punctuation">:</span> <span class="Identifier">ForLoopStmt</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkForStmt</span><span class="Punctuation">)</span>    <span class="Comment"># 创建一个新的 For 循环。</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">loop</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">3</span><span class="Punctuation">]</span>             <span class="Comment"># 这是 &quot;item&quot; 。</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">loop</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span>         <span class="Comment"># 这是 &quot;[1, 2, 3]&quot; 。</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;echo&quot;</span><span class="Punctuation">,</span> <span class="Identifier">loop</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Keyword">for</span> <span class="Identifier">item</span> <span class="Keyword">in</span> <span class="Identifier">example</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre></p>
<p>展开成:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">item</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">item</span></pre></p>
<p>再举一个例子:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">ForLoopStmt</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">expectKind</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">nnkForStmt</span>
  <span class="Comment"># 检查是否指定了计数的起始值</span>
  <span class="Keyword">var</span> <span class="Identifier">countStart</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">==</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newStmtList</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Comment"># 我们把第一个 for 循环变量修改为整数计数器:</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newVarStmt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">countStart</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">if</span> <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">!=</span> <span class="Identifier">nnkStmtList</span><span class="Punctuation">:</span>
    <span class="Identifier">body</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">body</span><span class="Punctuation">)</span>
  <span class="Identifier">body</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="RawData">bindSym&quot;inc&quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">newFor</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkForStmt</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">3</span><span class="Punctuation">:</span>
    <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Comment"># 将 enumerate(X) 转换为 'X'</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Identifier">newFor</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">body</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newFor</span>
  <span class="Comment"># 现在将整个宏包装到代码块里从而创建一个新的作用域</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Keyword">block</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Identifier">result</span><span class="Punctuation">`</span>

<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="Identifier">items</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span>

<span class="Comment"># 如果不将宏包装到代码块里，我们就需要为这里的 `a` 和 `b` 选择不同的名称</span>
<span class="Comment"># 以免犯重复定义的错误。</span>
<span class="Keyword">for</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span> <span class="Keyword">in</span> <span class="Identifier">enumerate</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Identifier">b</span></pre></p>

<h2><a class="toc-backref" id="宏-case-语句宏" href="#宏-case-语句宏">Case 语句宏</a></h2><p>名为 `` <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> `` 的宏能够为特定类型实现 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句。 下面的例子借助元组已有的相等运算符(由 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.==</span></span></tt> 提供)为它们实现了 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Punctuation">`</span><span class="Keyword">case</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkIfStmt</span><span class="Punctuation">)</span>
  <span class="Keyword">let</span> <span class="Identifier">selector</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..&lt;</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">kind</span>
    <span class="Keyword">of</span> <span class="Identifier">nnkElse</span><span class="Punctuation">,</span> <span class="Identifier">nnkElifBranch</span><span class="Punctuation">,</span> <span class="Identifier">nnkElifExpr</span><span class="Punctuation">,</span> <span class="Identifier">nnkElseExpr</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">it</span>
    <span class="Keyword">of</span> <span class="Identifier">nnkOfBranch</span><span class="Punctuation">:</span>
      <span class="Keyword">for</span> <span class="Identifier">j</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">:</span>
        <span class="Keyword">let</span> <span class="Identifier">cond</span> <span class="Operator">=</span> <span class="Identifier">newCall</span><span class="Punctuation">(</span><span class="StringLit">&quot;==&quot;</span><span class="Punctuation">,</span> <span class="Identifier">selector</span><span class="Punctuation">,</span> <span class="Identifier">it</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
        <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkElifBranch</span><span class="Punctuation">,</span> <span class="Identifier">cond</span><span class="Punctuation">,</span> <span class="Identifier">it</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span>
      <span class="Identifier">error</span> <span class="StringLit">&quot;自定义的元组 'case' 无法处理这个节点&quot;</span><span class="Punctuation">,</span> <span class="Identifier">it</span>

<span class="Keyword">case</span> <span class="Punctuation">(</span><span class="StringLit">&quot;foo&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">78</span><span class="Punctuation">)</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="StringLit">&quot;foo&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">78</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;yes&quot;</span>
<span class="Keyword">of</span> <span class="Punctuation">(</span><span class="StringLit">&quot;bar&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">88</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;no&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre></p>
<p>重载解析会处理 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 宏: <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 宏的第一个参数的类型用来匹配 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句选择器表达式的类型。 然后整个 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句被填入这个参数并对宏求值。</p>
<p>换句话说，这种宏需要转换整个 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句，但是决定调用哪个宏的仅是语句的选择器表达式。</p>

<h1><a class="toc-backref" id="特殊类型" href="#特殊类型">特殊类型</a></h1>
<h2><a class="toc-backref" id="特殊类型-static-t" href="#特殊类型-static-t">static[T]</a></h2><p>如名称所示，静态参数必须是常数表达式:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">RegEx</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span>
  <span class="Keyword">return</span> <span class="Identifier">res</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="StringLit">&quot;/d+&quot;</span><span class="Punctuation">)</span> <span class="Comment"># 这个调用被替换成一个预编译的、</span>
                        <span class="Comment"># 存储在全局变量里的正则表达式</span>

<span class="Identifier">precompiledRegex</span><span class="Punctuation">(</span><span class="Identifier">paramStr</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># 错误，命令行选项不是常数表达式</span></pre></p>
<p>出于代码生成的目的，所有静态参数都被视为泛型参数，即过程将为每个特定值提供(或值的组合)单独编译。</p>
<p>静态参数也可以出现在泛型类型签名中:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="Identifier">M</span><span class="Punctuation">,</span><span class="Identifier">N</span><span class="Punctuation">:</span> <span class="Keyword">static</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">Number</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">(</span><span class="Identifier">M</span><span class="Operator">*</span><span class="Identifier">N</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
    <span class="Comment"># 注意这里的 `Number` 只是一个类型约束，而</span>
    <span class="Comment"># `static int` 则要求我们提供一个整数值</span>
  
  <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>
  <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">Matrix</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">var</span> <span class="Identifier">m1</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform3D</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span>  <span class="Comment"># OK</span>
<span class="Keyword">var</span> <span class="Identifier">m2</span><span class="Punctuation">:</span> <span class="Identifier">AffineTransform2D</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># 错误，`string` 不是一种 `Number`</span></pre></p>
<p>请注意， <tt class="docutils literal"><span class="pre"><span class="Keyword">static</span> <span class="Identifier">T</span></span></tt> 只是底层泛型 <tt class="docutils literal"><span class="pre"><span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 的语法便利。 类型参数可以被省略，以获得所有常量表达式的类型类。通过将 <tt class="docutils literal"><span class="pre"><span class="Keyword">static</span></span></tt> 与另一个类型类实例化，来创建更具体的类型类。</p>
<p>把表达式强制转换成对应的 <tt class="docutils literal"><span class="pre"><span class="Keyword">static</span></span></tt> 类型可以强制其像常数表达式一样在编译期就进行求值。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">math</span>

<span class="Identifier">echo</span> <span class="Keyword">static</span><span class="Punctuation">(</span><span class="Identifier">fac</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">bool</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="FloatNumber">16.</span><span class="Identifier">isPowerOfTwo</span><span class="Punctuation">)</span></pre></p>
<p>编译器将报告表达式求值失败或可能的类型不匹配错误。</p>

<h2><a class="toc-backref" id="特殊类型-typedesc-t" href="#特殊类型-typedesc-t">typedesc[T]</a></h2><p>在一些上下文中，Nim 把类型名当作常规的值处理。这些值只存在于编译阶段，由于所有的值都必须有类型， 就用 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 来表示它们的这种特殊类型。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 作为泛型类型。例如，标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 的类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span></span></tt> 。 和普通的泛型一样，当省略泛型参数时，<tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 就表示所有的类型类。 作为一种语法上的便利，我们也可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 作为修饰语。</p>
<p>具有 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 参数的过程，被当成是隐式泛型的。 它们按提供类型的每个特定组合来实例化，并在过程主体中，每个参数名称将指代为绑定的具体类型。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;allocating &quot;</span><span class="Punctuation">,</span> <span class="Identifier">T</span><span class="Operator">.</span><span class="Identifier">name</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Operator">.</span><span class="Identifier">new</span>
<span class="Keyword">var</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>当出现多个类型参数时，它们将自由绑定到不同的类型。可以使用明确的泛型参数，来强制执行一次性绑定。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">acceptOnlyTypePairs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">,</span> <span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">C</span><span class="Punctuation">,</span> <span class="Identifier">D</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">U</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>一旦绑定，类型参数就可以出现在过程签名的其它部分:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">declareVariableWithType</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Identifier">declareVariableWithType</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="DecNumber">42</span></pre></p>
<p>通过限制与类型参数相匹配的类型集，可以进一步影响重载解析。在实践中，通过模板将属性附加到类型上。该约束可以是一个具体的类型或一个类型类。</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">template</span> <span class="Identifier">maxval</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">float</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="Identifier">Inf</span>

<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">var</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="Identifier">float</span><span class="Operator">.</span><span class="Identifier">maxval</span>
<span class="Keyword">when</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="Identifier">string</span><span class="Operator">.</span><span class="Identifier">maxval</span> <span class="Comment"># error, maxval is not implemented for string</span>

<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Keyword">object</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;不这么看。&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeInteger</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;是的！&quot;</span>
<span class="Keyword">template</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">[</span><span class="Identifier">SomeFloat</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;有可能，也可能是 NaN。&quot;</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;int 是数字吗？ &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;float 是数字吗？ &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">float</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;RootObj 是数字吗？ &quot;</span><span class="Punctuation">,</span> <span class="Identifier">isNumber</span><span class="Punctuation">(</span><span class="Identifier">RootObj</span><span class="Punctuation">)</span></pre></p>
<p>给宏传入 <tt class="docutils literal"><span class="pre"><span class="Identifier">typedesc</span></span></tt> 与传入其它参数几乎是一样的，区别仅在于宏一般不会被实例化。类型表达式简单地作为 <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt> 传给宏，就像其它任何东西一样。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span> <span class="Operator">=</span>
  <span class="Comment"># `arg` 的类型是 `NimNode`</span>
  <span class="Keyword">let</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span> <span class="Identifier">arg</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">tmp</span>

<span class="Keyword">var</span> <span class="Identifier">tmp</span><span class="Punctuation">:</span> <span class="Identifier">forwardType</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="特殊类型-typeof-运算符" href="#特殊类型-typeof-运算符">typeof 运算符</a></h2><p><strong>注意</strong>: 由于历史原因 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 也可写作 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> ，但是不鼓励这种写法。</p>
<p>取给定的表达式的 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeof</span></span></tt> 值就能得到这个表达式的类型(在其它的很多语言里这被称为 <span id="typeof_1">typeof</span> 运算符):</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Keyword">var</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># y 的类型是 int</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeof</span></span></tt> 被用来判断函数(或迭代器、变换器)调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">c</span><span class="Punctuation">(</span><span class="Identifier">X</span><span class="Punctuation">)</span></span></tt> 的结果的类型(这里，<tt class="docutils literal"><span class="pre"><span class="Identifier">X</span></span></tt> 代表可能为空的参数列表)， 解释代码时，与其它方式相比，优先考虑把 <tt class="docutils literal"><span class="pre"><span class="Identifier">c</span></span></tt> 视作迭代器。通过给 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeof</span></span></tt> 传入第二个参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">typeOfProc</span></span></tt> 可以改变这种行为。</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Keyword">proc</span> <span class="Identifier">split</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Comment"># 因为迭代器是首选的解释，所以它的类型是 `string` :</span>
<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">string</span>

<span class="Identifier">assert</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="StringLit">&quot;a b c&quot;</span><span class="Operator">.</span><span class="Identifier">split</span><span class="Punctuation">,</span> <span class="Identifier">typeOfProc</span><span class="Punctuation">)</span> <span class="Keyword">is</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre></p>

<h1><a class="toc-backref" id="模块" href="#模块">模块</a></h1><p>依靠模块概念 Nim 支持将程序拆分成小块。每个模块单独一个文件，有其独立的 <span id="namespace_1">namespace</span> &quot;命名空间&quot;。 模块为 <span id="information-hiding_1">information hiding</span> &quot;信息隐藏&quot;和 <span id="separate-compilation_1">separate compilation</span> &quot;独立编译&quot;提供了可能。一个模块可以通过 <span id="import_1">import</span> 语句访问另一个模块里的符号。允许 <span id="recursive-module-dependencies_1">Recursive module dependencies</span> &quot;递归模块依赖&quot;，但是略微复杂。只会导出带了星号( <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt> )标记的顶层符号。 只有合法的 Nim 标识符才能作为模块名(所以对应的文件名是 <tt class="docutils literal"><span class="pre">identifier.nim</span></tt> )。</p>
<p>编译模块的算法如下:</p>
<ul class="simple"><li>递归地追随导入语句正常编译整个模块。</li>
<li>如果发现成环，只导入已经完成语法分析的(且被导出的)符号；如果遇到未知标识符就中止。</li>
</ul>
<p>最好用一个例子来演示(译者注:代码里的注释描述了编译模块 A 时编译器的行为):</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">type</span>
  <span class="Identifier">T1</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Identifier">int</span>  <span class="Comment"># 模块 A 导出了类型 `T1`</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>     <span class="Comment"># 编译器开始分析模块 B</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Comment"># 由于此处模块 B 已经完成语法分析，所以没有问题</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>  <span class="Comment"># 此时模块 A 未完成语法分析，只会导入模块 A 中目前已知的符号</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">T1</span> <span class="Operator">=</span>
  <span class="Comment"># 编译器已把 T1 添加到 A 的接口符号表，所以这么写没问题</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="DecNumber">1</span></pre></p>

<h2><a class="toc-backref" id="模块-import-语句" href="#模块-import-语句">Import 语句</a></h2><p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> 关键字之后，可以有一个模块名称的列表，或者在单独的模块名称之后有一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 列表，以防止某些标识符被导入。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">except</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Identifier">toUpperAscii</span>

<span class="Comment"># 这行代码无法工作:</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span></pre></p>
<p>不检查 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 列表是否真的从模块中导出。这个特点使我们可以针对不同版本的模块进行编译，即使某个版本没有导出其中的一些标识符。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> 只允许在顶层出现。</p>

<h2><a class="toc-backref" id="模块-include-语句" href="#模块-include-语句">Include 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 语句所干的事情与导入模块截然不同: 它只是把文件的内容包含进来而已。 <tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 语句可用来把一个大模块切分成几个文件:</p>
<p><pre class="listing">
<span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 语句可以在顶层之外使用，比如:</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hello World!&quot;</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">include</span> <span class="Identifier">A</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># =&gt; Hello World!</span></pre></p>

<h2><a class="toc-backref" id="模块-导入语句里的模块名" href="#模块-导入语句里的模块名">导入语句里的模块名</a></h2><p>可以通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">as</span></span></tt> 关键字引入一个模块的别名，之后将无法访问原始的模块名称。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">su</span><span class="Punctuation">,</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">sequtils</span> <span class="Keyword">as</span> <span class="Identifier">qu</span>

<span class="Identifier">echo</span> <span class="Identifier">su</span><span class="Operator">.</span><span class="Identifier">format</span><span class="Punctuation">(</span><span class="StringLit">&quot;$1&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lalelu&quot;</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">path</span><span class="Operator">/</span><span class="Identifier">to</span><span class="Operator">/</span><span class="Identifier">module</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;path/to/module&quot;</span></span></tt> 标注，可以用来描述子目录中的模块。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">os</span><span class="Punctuation">,</span> <span class="StringLit">&quot;lib/pure/times&quot;</span></pre></p>
<p>注意模块名仍然是 <tt class="docutils literal"><span class="pre"><span class="Identifier">strutils</span></span></tt> 而不是 <tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span></span></tt>，所以 <strong>不能</strong> 这么干:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span>
<span class="Identifier">echo</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span></pre></p>
<p>与之类似，因为模块名已经就是 <tt class="docutils literal"><span class="pre"><span class="Identifier">strutils</span></span></tt> 了，所以下面的代码是不合理的:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">lib</span><span class="Operator">/</span><span class="Identifier">pure</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">as</span> <span class="Identifier">strutils</span></pre></p>

<h2><a class="toc-backref" id="模块-从目录里集体导入" href="#模块-从目录里集体导入">从目录里集体导入</a></h2><p>使用语法 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">dir</span> <span class="Operator">/</span> <span class="Punctuation">[</span><span class="Identifier">moduleA</span><span class="Punctuation">,</span> <span class="Identifier">moduleB</span><span class="Punctuation">]</span></span></tt> 能够从同一个路径里导入多个模块。</p>
<p>在语法上，路径名可以是 Nim 标识符或者字符串字面量。如果路径名不是一个合法的 Nim 标识符， 那么就需要写成字符串字面量的形式:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="StringLit">&quot;gfx/3d/somemodule&quot;</span> <span class="Comment"># '3d' 不是合法的 Nim 标识符，要用引号</span></pre></p>

<h2><a class="toc-backref" id="模块-用于-importslashinclude-的伪路径" href="#模块-用于-importslashinclude-的伪路径">用于 import/include 的伪路径</a></h2><p>路径也可以是所谓的 &quot;pseudo directory&quot; &quot;伪路径&quot;。它们用来解决存在同名模块时的多义问题。</p>
<p>有两个伪路径:</p>
<ol class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">std</span></span></tt>:<tt class="docutils literal"><span class="pre"><span class="Identifier">std</span></span></tt> 这个伪路径代表了 Nim 标准库的抽象位置。例如，<tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">std</span> <span class="Operator">/</span> <span class="Identifier">strutils</span></span></tt> 可用来明确地导入标准库里的 <tt class="docutils literal"><span class="pre"><span class="Identifier">stutils</span></span></tt> 模块。</li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">pkg</span></span></tt>:<tt class="docutils literal"><span class="pre"><span class="Identifier">pkg</span></span></tt> 这个伪路径用来明确地指向 Nim 软件包。不过，其技术细节不在本文档的范围以内。</li>
</ol>
<p>它的语义是: <em>使用搜索路径去查找模块名，但是忽略标准库所在位置</em> 。换句话说，它是 <tt class="docutils literal"><span class="pre"><span class="Identifier">std</span></span></tt> 的反面。</p>
<p>对于所有导入标准库(stdlib)里的模块的情况，建议、优选(但是目前并不强制)把 std/ 这个伪路径写到导入语句里。</p>

<h2><a class="toc-backref" id="模块-from-import-语句" href="#模块-from-import-语句">From import 语句</a></h2><p>在 <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span></span></tt> 关键字之后，是一个模块名称，后面是一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> ，用来列出一个偏好使用的标识符，而不需要完全明确的限定。</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">%</span><span class="Punctuation">`</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;$1&quot;</span> <span class="Operator">%</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Comment"># 总是允许全限定形式:</span>
<span class="Identifier">echo</span> <span class="Identifier">strutils</span><span class="Operator">.</span><span class="Identifier">replace</span><span class="Punctuation">(</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;z&quot;</span><span class="Punctuation">)</span></pre></p>
<p>如果要导入模块 <tt class="docutils literal"><span class="pre"><span class="Identifier">module</span></span></tt> ，又要强制以全限定的形式访问它的每一个符号，那么可以 <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span> <span class="Identifier">module</span> <span class="Keyword">import</span> <span class="Keyword">nil</span></span></tt> 。</p>

<h2><a class="toc-backref" id="模块-export-语句" href="#模块-export-语句">Export 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">export</span></span></tt> 语句用来转发符号，这样客户模块就不需要再导入本模块的依赖了:</p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">type</span> <span class="Identifier">MyObject</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">import</span> <span class="Identifier">B</span>
<span class="Keyword">export</span> <span class="Identifier">B</span><span class="Operator">.</span><span class="Identifier">MyObject</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;my object&quot;</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span>

<span class="Comment"># 这里 B.MyObject 被隐式导入:</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
<span class="Identifier">echo</span> <span class="Operator">$</span><span class="Identifier">x</span></pre></p>
<p>当被导出的符号是另一个模块时，这个模块里的所有定义都会被导出。通过使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 列表可以将其中的某些符号排除。</p>
<p>注意当导出时，只需要指定模块名:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">foo</span><span class="Operator">/</span><span class="Identifier">bar</span><span class="Operator">/</span><span class="Identifier">baz</span>
<span class="Keyword">export</span> <span class="Identifier">baz</span></pre></p>

<h2><a class="toc-backref" id="模块-作用域规则" href="#模块-作用域规则">作用域规则</a></h2><p>标识符从它的声明处开始生效，并持续到到其声明所在的那个块结束。标识符为已知状态的那段代码范围称为标识符的作用域。标识符的准确的作用域与其声明方式有关。</p>

<h3><a class="toc-backref" id="作用域规则-块作用域" href="#作用域规则-块作用域">块作用域</a></h3><p>对于在块(block)的声明部分里声明的变量，其作用域从其声明处开始，直到块的末尾结束。 如果一个块里包含另一个块，在这个块里又再次声明了这个标识符，那么，在这个内部的块里，第二个声明有效。 当离开这个内部的块时，第一个声明又一次有效。在同一个块里，同一个标识符不能被重复定义， 除非是为了过程或者迭代器重载之目的。</p>

<h3><a class="toc-backref" id="作用域规则-元组或对象作用域" href="#作用域规则-元组或对象作用域">元组或对象作用域</a></h3><p>在元组或者对象定义里的字段标识符在下列地方有效:</p>
<ul class="simple"><li>直到元组/对象的定义结束</li>
<li>所给的元组/对象类型的变量的字段指示器(designators)</li>
<li>对象类型的所有派生类型内</li>
</ul>

<h3><a class="toc-backref" id="作用域规则-模块作用域" href="#作用域规则-模块作用域">模块作用域</a></h3><p>模块里的所有标识符从声明开始直到模块结束一直有效。间接依赖的模块里的标识符在本模块里 <em>不可用</em> 。 每个模块都自动导入了 <span id="system_1">system</span> &quot;系统&quot;模块。</p>
<p>如果一个模块从两个不同模块里导入了相同的标识符，那么每次使用它时都必须加上限定，除非它是一个重载的过程或者迭代器， 这时重载解析会进来解决多义性:</p>
<p><pre class="listing">
<span class="Comment"># 模块 A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*</span> <span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p><pre class="listing">
<span class="Comment"># 模块 C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 错误:x 指代不明</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 正确:加上限定后 x 的指代明确</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 没有多义性: 这是模块 C 自己的 x</span></pre></p>

<h2><a class="toc-backref" id="模块-包" href="#模块-包">包</a></h2><p>对于根目录里有一个 <tt class="docutils literal"><span class="pre">identifier.nimble</span></tt> 文件的目录树，里面的那些模块被合称为一个 Nimble 包。 <tt class="docutils literal"><span class="pre">identifier.nimble</span></tt> 这个文件名里的 <tt class="docutils literal"><span class="pre">identifier</span></tt> 就是包的名称，必须是合法的 Nim 标识符。 对于没有与之关联的 <tt class="docutils literal"><span class="pre">.nimble</span></tt> 文件的模块，给它这么一个包名: <tt class="docutils literal"><span class="pre"><span class="Identifier">unknown</span></span></tt> 。</p>
<p>包与包之间有了区分，就可以限制编译器输出的诊断信息的范围: 仅限当前项目里的包，或者仅限项目外部的包。</p>

<h1><a class="toc-backref" id="编译器消息" href="#编译器消息">编译器消息</a></h1><p>Nim 编译器会输出不同类型的消息: <span id="hint_1">hint</span> &quot;提示&quot;，<span id="warning_1">warning</span> &quot;警告&quot;和 <span id="error_1">error</span> &quot;错误&quot;。 编译器遇到静态错误时会输出 <em>错误</em> 消息。</p>

<h1><a class="toc-backref" id="编译指示" href="#编译指示">编译指示</a></h1><p>编译指示(pragmas)是 Nim 语言在不引入大量新关键字的前提下给编译器提供额外信息、命令的方法。 编译指示在语法检查时随即就处理了。编译指示由一对特殊的花括号 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 包围。 当语言有了新特性但是还没设计出与之匹配的漂亮语法时，常常通过编译指示提供尝鲜体验。</p>

<h2><a class="toc-backref" id="编译指示-deprecated-编译指示" href="#编译指示-deprecated-编译指示">deprecated 编译指示</a></h2><p>deprecated 编译指示用来标记某符号已废弃:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre></p>
<p>可选地，这个编译指示还能接受一个包含警告信息的字符串，编译器会把它呈现给开发者。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">thing</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="StringLit">&quot;请改用 thong&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="编译指示-compiletime-编译指示" href="#编译指示-compiletime-编译指示">compileTime 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">compileTime</span></span></tt> 编译指示用来指示一个过程或者变量只能用于编译期的执行。不会为它生成代码。 编译期过程可作为宏的辅助。从语言的 0.12.0 版本开始，包含 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">NimNode</span></span></tt> 类型的参数的过程隐式地声明为 <tt class="docutils literal"><span class="pre"><span class="Identifier">compileTime</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre></p>
<p>与下面的代码一致:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">astHelper</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">n</span></pre></p>
<p>加了 <tt class="docutils literal"><span class="pre"><span class="Identifier">compileTime</span></span></tt> 编译指示的变量在运行时也存在。很多时候希望某些变量(例如查找表)在编译时填充数据、 在运行时访问——这轻而易举:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">var</span> <span class="Identifier">nameToProc</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nimcall</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">]</span>

<span class="Keyword">macro</span> <span class="Identifier">registerProc</span><span class="Punctuation">(</span><span class="Identifier">p</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newTree</span><span class="Punctuation">(</span><span class="Identifier">nnkStmtList</span><span class="Punctuation">,</span> <span class="Identifier">p</span><span class="Punctuation">)</span>
  
  <span class="Keyword">let</span> <span class="Identifier">procName</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Keyword">let</span> <span class="Identifier">procNameAsStr</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">p</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">add</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Identifier">nameToProc</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Punctuation">`</span><span class="Identifier">procNameAsStr</span><span class="Punctuation">`</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Identifier">procName</span><span class="Punctuation">`</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">registerProc</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;foo&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">registerProc</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;bar&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">baz</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">registerProc</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;baz&quot;</span>

<span class="Identifier">doAssert</span> <span class="Identifier">nameToProc</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;baz&quot;</span></pre></p>

<h2><a class="toc-backref" id="编译指示-noreturn-编译指示" href="#编译指示-noreturn-编译指示">noreturn 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">noreturn</span></span></tt> 编译指示用来指示过程永远不会返回。</p>

<h2><a class="toc-backref" id="编译指示-acyclic-编译指示" href="#编译指示-acyclic-编译指示">acyclic 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">acyclic</span></span></tt> 编译指示用来指示对象类型是无环的，即使看起来像是有环的。 这个信息是一种 <strong>优化</strong> ，有了这个信息垃圾回收器不再需要考虑这个类的对象构成环的情况:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">acyclic</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>我们也可以直接使用引用对象类型:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">acyclic</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>这个例子里通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">Node</span></span></tt> 类型声明了一个树形结构。注意到这个类型的定义是递归的，GC 不得不考虑各对象可能构成一个有环图的情况。 <tt class="docutils literal"><span class="pre"><span class="Identifier">acyclic</span></span></tt> 编译指示告知 GC 这不可能发生。如果程序员把 <tt class="docutils literal"><span class="pre"><span class="Identifier">acyclic</span></span></tt> 编译指示赋予了实际上有环的数据类型，那么将导致内存泄露，但是不会破坏内存安全。</p>

<h2><a class="toc-backref" id="编译指示-final-编译指示" href="#编译指示-final-编译指示">final 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">final</span></span></tt> 编译指示用来指示一个对象类型不能被继承。注意只能继承那些继承自已有对象类型的类型(通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">SuperType</span></span></tt> 语法) 或者标注了 <tt class="docutils literal"><span class="pre"><span class="Identifier">inheritable</span></span></tt> 的类型。</p>

<h2><a class="toc-backref" id="编译指示-shallow-编译指示" href="#编译指示-shallow-编译指示">shallow 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">shallow</span></span></tt> 编译指示影响类型的语义: 允许编译器进行浅拷贝。这会导致严重的语义问题，破坏内存安全！ 但是，它也可以大幅度提高赋值的速度，因为 Nim 的语义要求对序列和字符串做深拷贝。深拷贝代价高昂， 尤其是用序列来构造树形结构的时候:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre></p>

<h2><a class="toc-backref" id="编译指示-pure-编译指示" href="#编译指示-pure-编译指示">pure 编译指示</a></h2><p>给对象类型加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">pure</span></span></tt> 编译指示后，编译器就不再为它生成用于运行时类型识别的类型字段。 这曾是为了实现与其它编译型语言的二进制兼容。</p>
<p>枚举类型可以标记为 <tt class="docutils literal"><span class="pre"><span class="Identifier">pure</span></span></tt> 。这样一来，访问其成员时总是需要使用全限定。</p>

<h2><a class="toc-backref" id="编译指示-asmnostackframe-编译指示" href="#编译指示-asmnostackframe-编译指示">asmNoStackFrame 编译指示</a></h2><p>可以给过程加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">asmNoStackFrame</span></span></tt> 编译指示以告知编译器不要为它生成栈帧。编译器同样也不会生成类似<tt class="docutils literal"><span class="pre"><span class="Keyword">return</span> <span class="Identifier">result</span><span class="Punctuation">;</span></span></tt> 的退出语句。 根据所用的 C 编译器，生成的 C 函数会被声明成 <tt class="docutils literal"><span class="pre"><span class="Identifier">__declspec</span><span class="Punctuation">(</span><span class="Identifier">naked</span><span class="Punctuation">)</span></span></tt> 或者 <tt class="docutils literal"><span class="pre"><span class="Identifier">__attribute__</span><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">naked</span><span class="Punctuation">)</span><span class="Punctuation">)</span></span></tt> 。</p>
<p><strong>注意</strong>: 这个编译指示应该只用于完全由汇编语句构成的过程。</p>

<h2><a class="toc-backref" id="编译指示-error-编译指示" href="#编译指示-error-编译指示">error 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">error</span></span></tt> 编译指示可使编译器输出一条包含指定内容的错误消息。但是输出了这个错误消息后，编译过程并不一定会中止。</p>
<p>可以给符号(比如迭代器或者过程)附加 <tt class="docutils literal"><span class="pre"><span class="Identifier">error</span></span></tt> 编译指示。 <em>使用</em> 这个符号将触发静态错误。 当需要排除某些由于重载和类型转换导致的合法操作时，这个 <tt class="docutils literal"><span class="pre"><span class="Identifier">error</span></span></tt> 就派上用场了:</p>
<p><pre class="listing">
<span class="Comment">## 检查所比较的是整形数值，而不是指针:</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="编译指示-fatal-编译指示" href="#编译指示-fatal-编译指示">fatal 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">fatal</span></span></tt> 编译指示可使编译器输出一条包含指定内容的错误消息。与 <tt class="docutils literal"><span class="pre"><span class="Identifier">error</span></span></tt> 编译指示不同， 输出了这个错误消息后，编译过程必然中止。例子:</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;编译这个程序时带上 objc 命令！&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="编译指示-warning-编译指示" href="#编译指示-warning-编译指示">warning 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">warning</span></span></tt> 编译指示可使编译器输出一条包含指定内容的警告消息，然后继续编译。</p>

<h2><a class="toc-backref" id="编译指示-hint-编译指示" href="#编译指示-hint-编译指示">hint 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">hint</span></span></tt> 编译指示可使编译器输出一条包含指定内容的提示消息，然后继续编译。</p>

<h2><a class="toc-backref" id="编译指示-line-编译指示" href="#编译指示-line-编译指示">line 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">line</span></span></tt> 编译指示可以修改所在语句的代码行信息。这个行信息可在栈回溯信息里看到:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># 修改 `raise` 语句运行时的行信息</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">instantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">AssertionDefect</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">line</span></span></tt> 带了参数，那么参数需要是 <tt class="docutils literal"><span class="pre"><span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span></span></tt> 的形式； 如果不带参数，那么相当于以 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">instantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 为参数。</p>

<h2><a class="toc-backref" id="编译指示-linearscanend-编译指示" href="#编译指示-linearscanend-编译指示">linearScanEnd 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">linearScanEnd</span></span></tt> 编译指示用来告知编译器如何处理 Nim <span id="case_1">case</span> 语句。这个编译指示在语法上必须是一个语句:</p>
<p><pre class="listing">
<span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;最常见的情况&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;第二常见的情况&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;不常见:使用分支表&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;也不常见:使用了分支表，数值为 &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre></p>
<p>在这个例子里， <tt class="docutils literal"><span class="pre"><span class="DecNumber">0</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="DecNumber">1</span></span></tt> 分支比其它情况更加常见。所以，生成的汇编代码应该首先测试这两个值以使 CPU的分支预测器有更大的几率预测成功(避免出现开销高昂的 CPU 流水线停滞)。 其它的情况则可以放到跳转表里，其开销为 O(1)，但代价是一次(很可能出现的)流水线停滞。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">linearScanEnd</span></span></tt> 编译指示应该被到最后一个需要进行线性扫描的分支里。如果放到整个 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句最后那个分支里，那么整个 <tt class="docutils literal"><span class="pre"><span class="Keyword">case</span></span></tt> 语句都会使用线性扫描。</p>

<h2><a class="toc-backref" id="编译指示-computedgoto-编译指示" href="#编译指示-computedgoto-编译指示">computedGoto 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">computedGoto</span></span></tt> 编译指令告知编译器如何编译嵌在 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span> <span class="Identifier">true</span></span></tt> 语句里的 Nim <span id="case_2">case</span> 语句。 这个编译指示在语法上必须是这个循环体里的一条语句:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>如例子所示，<tt class="docutils literal"><span class="pre"><span class="Identifier">computedGoto</span></span></tt> 对于实现解释器非常有用。如果所使用的后端(C 编译器)不支持计算跳转这个扩展功能，那么该编译指示被直接忽略。</p>

<h2><a class="toc-backref" id="编译指示-immediate-编译指示" href="#编译指示-immediate-编译指示">immediate 编译指示</a></h2><p>即时编译指示已经过时。参阅<a class="reference internal" href="#类型化参数与非类型化参数">类型化参数与非类型化参数</a>。</p>

<h2><a class="toc-backref" id="编译指示-redefine-编译指示" href="#编译指示-redefine-编译指示">redefine 编译指示</a></h2><p>允许对具有相同签名的模板标识符进行重新定义。这可以通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">redefine</span></span></tt> 编译指示来明确。</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Identifier">echo</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 1</span>
<span class="Keyword">template</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">redefine</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
<span class="Identifier">echo</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># 2</span>
<span class="Comment"># 警告:模板隐式重定义</span>
<span class="Keyword">template</span> <span class="Identifier">foo</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">3</span></pre></p>
<p>这主要是针对宏生成的代码。</p>

<h2><a class="toc-backref" id="编译指示-与编译选项相关的编译指示" href="#编译指示-与编译选项相关的编译指示">与编译选项相关的编译指示</a></h2><p>下面列出的编译指示用来改写过程、方法、转换器的代码生成选项。</p>
<p>当前，编译器提供以下可能的选项(以后可能会增加)。</p>
<table border="1" class="docutils"><tr><th>编译指示</th><th>允许的值</th><th>描述</th></tr>
<tr><td>checks</td><td>on|off</td><td>是否为所有的运行时检查生成代码。</td></tr>
<tr><td>boundChecks</td><td>on|off</td><td>是否为数组边界检查生成代码。</td></tr>
<tr><td>overflowChecks</td><td>on|off</td><td>是否为上、下溢出检查生成代码。</td></tr>
<tr><td>nilChecks</td><td>on|off</td><td>是否为空指针检查生成代码。</td></tr>
<tr><td>assertions</td><td>on|off</td><td>是否为断言生成代码。</td></tr>
<tr><td>warnings</td><td>on|off</td><td>打开或关闭编译器的警告消息。</td></tr>
<tr><td>hints</td><td>on|off</td><td>打开或关闭编译器的提示消息。</td></tr>
<tr><td>optimization</td><td>none|speed|size </td><td>设置优化目标为执行速度(speed)、文件大小(size)， 或者关闭优化(none)</td></tr>
<tr><td>patterns</td><td>on|off</td><td>打开或关闭项重写模块、宏。</td></tr>
<tr><td>callconv</td><td>cdecl|...</td><td>为所有过程(及过程类型)设置默认的调用规范。</td></tr>
</table><p>例如:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># 关闭运行时检查，优化执行速度</span></pre></p>

<h2><a class="toc-backref" id="编译指示-push-和-pop-编译指示" href="#编译指示-push-和-pop-编译指示">push 和 pop 编译指示</a></h2><p><span id="pushslashpop_1">push/pop</span> 编译指示也是用来控制编译选项的，不过是用于临时性地修改设置然后还原。例子:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># 由于这一段代码对于执行速度非常关键，所以不做运行时检查</span>
<span class="Comment"># ... 一些代码 ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 恢复原来旧的编译设置</span></pre></p>
<p><span id="pushslashpop_2">push/pop</span> 能够开关一些来自标准库的编译指示，例如:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">thisIsInlined</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
<span class="Keyword">func</span> <span class="Identifier">willBeInlined</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">42.0</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">notInlined</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">9</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">discardable</span><span class="Punctuation">,</span> <span class="Identifier">boundChecks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">compileTime</span><span class="Punctuation">,</span> <span class="Identifier">noSideEffect</span><span class="Punctuation">,</span> <span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">example</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;https://nim-lang.org&quot;</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">deprecated</span><span class="Punctuation">,</span> <span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">used</span><span class="Punctuation">,</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">sample</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>对于来自第三方的编译指示，<span id="pushslashpop_3">push/pop</span> 是否有效与第三方的实现有关，但是无论如何使用的语法是相同的。</p>

<h2><a class="toc-backref" id="编译指示-register-编译指示" href="#编译指示-register-编译指示">register 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">register</span></span></tt> 编译指示仅用于变量。这个编译指示将变量声明为 <tt class="docutils literal"><span class="pre"><span class="Identifier">register</span></span></tt>， 提示编译器应该将这个变量放到硬件寄存器里以提高访问速度。C 编译器经常忽略这个提示，理由充分: 没有这个提示它们往往能把活干得更漂亮。</p>
<p>然而，特定的情况下(例如一个字节码解释器的调度循环)这个编译指示可能会有所帮助。</p>

<h2><a class="toc-backref" id="编译指示-global-编译提示" href="#编译指示-global-编译提示">global 编译提示</a></h2><p>可以给过程里的变量加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">global</span></span></tt> 编译提示，命令编译器把这个变量存储在全局位置，并且在程序启动时初始化一次。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre></p>
<p>在泛型过程里使用时，编译器会为泛型过程的每个实例创建独立的全局变量。编译器为某个模块创建的这些全局变量， 其初始化时的先后顺序不做规定；但是，整体上是先初始化这个模块的顶层变量，再初始化这些全局变量； 如果其它模块导入了这个模块，那么这些全局变量的初始化将早于其它模块里的变量。</p>

<h2><a class="toc-backref" id="编译指示-禁用某些信息" href="#编译指示-禁用某些信息">禁用某些信息</a></h2><p>Nim会产生一些长行的警告和提示，可能会使用户烦恼。我们提供了一个禁用某些信息的机制。 每个提示和警告信息都与一个标识符相关联。可以通过把该信息标识符，放在编译指示后面的括号里，来启用或禁用该信息。</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 关闭关于代码行太长的那条提示</span></pre></p>
<p>对于警告消息而言，这种办法往往比一股脑地禁用所有警告更好。</p>

<h2><a class="toc-backref" id="编译指示-used-编译提示" href="#编译指示-used-编译提示">used 编译提示</a></h2><p>当一个符号既未导出也未被使用时，Nim 会输出一条警告消息。给这个符号加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">used</span></span></tt> 编译提示可以抑制这条消息。 当通过宏生成符号时，这个编译提示非常有用:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoAdd</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span>
  <span class="Keyword">proc</span> <span class="Identifier">echoSub</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Identifier">echo</span> <span class="Identifier">a</span> <span class="Operator">-</span> <span class="Identifier">b</span>

<span class="Comment"># 'echoSub' 虽然未被使用，但是不会触发警告</span>
<span class="Identifier">implementArithOps</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Identifier">echoAdd</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">5</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">used</span></span></tt> 也可用作顶层语句，把模块标记为&quot;已使用&quot;。这样就可以抑制针对这个模块的&quot;未使用的导入&quot;这条警告:</p>
<p><pre class="listing">
<span class="Comment"># 模块:debughelper.nim</span>
<span class="Keyword">when</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">nimHasUsed</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Comment"># 'import debughelper' 对于调试来说非常有用，</span>
  <span class="Comment"># 即使这个模块未被使用，也不需要 Nim 输出警告:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">used</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="编译指示-expermimental-编译指示" href="#编译指示-expermimental-编译指示">expermimental 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">experimental</span></span></tt> 编译指示用于启用实验性的语言特性。也就是说，具体到每个特性，有的过于不稳定，无法发布；有的前景不明朗(可能随时被删除)。详情参阅<a class="reference external" href="manual_experimental.html">实验手册</a> 。</p>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">threadpool</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">threadedEcho</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">spawn</span> <span class="Identifier">threadedEcho</span><span class="Punctuation">(</span><span class="StringLit">&quot;并行地使用 echo &quot;</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">)</span>

<span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>expermimental 编译指示是顶层语句，模块里出现了这个编译指示之后，它所启用的特性就一直有效。这会给宏和泛型实例的使用带来问题，因为它们可以跨越模块作用域。目前，必须在 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">push</span><span class="Operator">/</span><span class="Identifier">pop</span></span></tt> 环境中使用以避免问题:</p>
<p><pre class="listing">
<span class="Comment"># client.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">useParallel</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">unused</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># 这里使用泛型 T 演示问题.</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">experimental</span><span class="Punctuation">:</span> <span class="StringLit">&quot;parallel&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">parallel</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;并行输出&quot;</span>
  
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">client</span>
<span class="Identifier">useParallel</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>

<h1><a class="toc-backref" id="与实现紧密相关的编译指示" href="#与实现紧密相关的编译指示">与实现紧密相关的编译指示</a></h1><p>本节介绍当前 Nim 实现所支持的额外的编译指示。不要把它们视为语言规范的一部分。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-bitsize-编译指示" href="#与实现紧密相关的编译指示-bitsize-编译指示">Bitsize 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">bitsize</span></span></tt> 是对象字段成员的编译指示。表明该字段为 C/C++ 中的位域。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">mybitfield</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">flag</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bitsize</span><span class="Punctuation">:</span><span class="FloatNumber">1.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cuint</span></pre></p>
<p>生成:</p>
<p><pre class="listing">
<span class="Keyword">struct</span> <span class="Identifier">mybitfield</span> <span class="Punctuation">{</span>
  <span class="Keyword">unsigned</span> <span class="Keyword">int</span> <span class="Identifier">flag</span><span class="Punctuation">:</span><span class="DecNumber">1</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span><span class="Punctuation">;</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-align-编译指示" href="#与实现紧密相关的编译指示-align-编译指示">Align 编译指示</a></h2><p><span id="align_1">align</span> 编译指示是针对变量和对象字段成员的，用于修改所声明的实体的字节对齐要求。其参数必须是常数，是 2 的整数次幂。同一个声明存在多个有效的非 0 对齐的编译指示时，较弱的编译指示会被忽略。与类型的对齐要求相比，较弱的对齐编译指示的声明也会被忽略。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">sseType</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">sseData</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">align</span><span class="Punctuation">(</span><span class="DecNumber">16</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">float32</span><span class="Punctuation">]</span>
  
  <span class="Comment"># 每个对象都按 128 字节边界对齐</span>
  <span class="Identifier">Data</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">char</span>
    <span class="Identifier">cacheline</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">align</span><span class="Punctuation">(</span><span class="DecNumber">128</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">128</span><span class="Punctuation">,</span> <span class="Identifier">char</span><span class="Punctuation">]</span> <span class="Comment"># 超量对齐的字符数组</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;sizeof(Data) = &quot;</span><span class="Punctuation">,</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">Data</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (1 byte + 127 bytes padding + 128-byte array)&quot;</span>
  <span class="Comment"># 输出: sizeof(Data) = 256 (1 byte + 127 bytes padding + 128-byte array)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;sseType 的对齐长度是 &quot;</span><span class="Punctuation">,</span> <span class="Identifier">alignof</span><span class="Punctuation">(</span><span class="Identifier">sseType</span><span class="Punctuation">)</span>
  <span class="Comment"># 输出: sseType 的对齐长度是 16</span>
  <span class="Keyword">var</span> <span class="Identifier">d</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">align</span><span class="Punctuation">(</span><span class="DecNumber">2048</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Data</span> <span class="Comment"># Data 的这个实例的对齐要求更加严格</span>

<span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>这种编译指示对 JS 后端没有任何影响。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-noalias-编译指示" href="#与实现紧密相关的编译指示-noalias-编译指示">Noalias 编译指示</a></h2><p>从 Nim 编译器版本 1.4 开始，有一个用于变量和参数的 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">noalias</span></span></tt> 注解。它被直接映射到 C/C++ 的 <tt class="docutils literal"><span class="pre"><span class="Keyword">restrict</span></span></tt> 关键字，表示底层指向内存中的一个独占地址，此地址不存在其他别名。编译器 <em>不检查</em> 代码是否遵守了此别名限制。如果违反了限制，后端优化器就完全有可能错误地编译代码。这是一个 <strong>不安全的</strong> 语言功能。</p>
<p>理想情况下，在 Nim 之后的版本中，该限制将在编译时得以检查确认。(这也是为什么选择了 <tt class="docutils literal"><span class="pre"><span class="Identifier">noalias</span></span></tt> 做名称，而不是描述更详细的名称，如 <tt class="docutils literal"><span class="pre"><span class="Identifier">unsafeAssumeNoAlias</span></span></tt> 。)</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-volatile-编译指示" href="#与实现紧密相关的编译指示-volatile-编译指示">Volatile 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">volatile</span></span></tt> 编译指示仅用于变量。它声明变量为 <tt class="docutils literal"><span class="pre"><span class="Identifier">volatile</span></span></tt>:c:，不论 C/C++ 中 volatile 代表什么含义 (其语义在 C/C++中没有明确定义)。</p>
<p><strong>注意</strong>: LLVM 后端不存在这种编译指示。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-nodecl-编译指示" href="#与实现紧密相关的编译指示-nodecl-编译指示">nodecl 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">nodecl</span></span></tt> 编译指示可以应用于几乎任何标识符(变量、过程、类型等)，在与 C 的互操作时往往很有用: 它告诉 Nim，不要在 C 代码中声明这个标识符。例如:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">EACCES</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cint</span> <span class="Comment"># 把 EACCES 假装成变量，</span>
                                   <span class="Comment"># Nim 不知道它的值</span></pre></p>
<p>然而， <tt class="docutils literal"><span class="pre"><span class="Identifier">header</span></span></tt> 编译指示通常是更好的选择。</p>
<p><strong>注意</strong>: 这在 LLVM 后端无法使用。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-header-编译指示" href="#与实现紧密相关的编译指示-header-编译指示">Header 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">header</span></span></tt> 编译指示和 <tt class="docutils literal"><span class="pre"><span class="Identifier">nodecl</span></span></tt> 编译指示非常相似: 可以应用于几乎所有的标识符，并指定它不应该被声明，与之相反，生成的代码应该包含一个 <tt class="docutils literal"><span class="pre"><span class="Preprocessor">#include</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">PFile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;FILE*&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">pointer</span>
    <span class="Comment"># 引入 C 的 FILE* 类型；Nim 把它视为一个新的指针类型</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">header</span></span></tt> 编译指示总是需要一个字符串常量。这个字符串常量包含头文件: 像 C 语言里经常发生的那样，系统头文件被括在尖括号中: <tt class="docutils literal"><span class="pre"><span class="Operator">&lt;&gt;</span></span></tt> 。如果没有给出尖括号，Nim 生成 C 代码时就把头文件括在 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt> 中。</p>
<p><strong>注意</strong>: LLVM 后端不存在这种编译指示。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-incompletestruct-编译指示" href="#与实现紧密相关的编译指示-incompletestruct-编译指示">IncompleteStruct 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">incompleteStruct</span></span></tt> 编译指示告知编译器不要在 <tt class="docutils literal"><span class="pre"><span class="Identifier">sizeof</span></span></tt> 表达式中使用底层的 C <tt class="docutils literal"><span class="pre"><span class="Keyword">struct</span></span></tt> 。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">DIR</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;DIR&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;dirent.h&gt;&quot;</span><span class="Punctuation">,</span>
         <span class="Identifier">pure</span><span class="Punctuation">,</span> <span class="Identifier">incompleteStruct</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-compile-编译指示" href="#与实现紧密相关的编译指示-compile-编译指示">Compile 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">compile</span></span></tt> 编译指示用来把 C/C++ 源文件与项目一同编译和链接:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compile</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.cpp&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p><strong>注意</strong>: Nim 会计算 SHA1 校验和，只在文件变化时才重新编译。使用 <tt class="docutils literal"><span class="pre option">-f</span></tt> 命令行选项可以强制重新编译文件。</p>
<p>从 1.4 开始， <tt class="docutils literal"><span class="pre"><span class="Identifier">compile</span></span></tt> 编译指示也可以使用这种语法:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compile</span><span class="Punctuation">(</span><span class="StringLit">&quot;myfile.cpp&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;--custom flags here&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>从例子中可以看出，这个新写法允许在文件重新编译时将自定义标志传递给 C 编译器。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-link-编译指示" href="#与实现紧密相关的编译指示-link-编译指示">Link 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">link</span></span></tt> 编译指示用来将附加文件与项目链接:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;myfile.o&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-passc-编译指示" href="#与实现紧密相关的编译指示-passc-编译指示">passc 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">passc</span></span></tt> 编译指示可以用来传递额外参数到 C 编译器，就像命令行使用的 <tt class="docutils literal"><span class="pre option">--passc</span></tt>:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-Wall -Werror&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>请注意，可以使用<a class="reference external" href="system.html">系统模块</a>中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">gorge</span></span></tt> 来嵌入外部命令中的参数，这些参数将在语义分析期间执行:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passc</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --cflags sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-localpassc-编译指示" href="#与实现紧密相关的编译指示-localpassc-编译指示">localPassC 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">localPassC</span></span></tt> 编译指示可以向 C 编译器传递额外的参数，但只适用于由编译指示所在的 Nim 模块生成的 C/C++ 文件:</p>
<p><pre class="listing">
<span class="Comment"># 模块 A.nim</span>
<span class="Comment"># 生成: A.nim.cpp</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">localPassC</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-Wall -Werror&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 当编译 A.nim.cpp 时传递</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-passl-编译指示" href="#与实现紧密相关的编译指示-passl-编译指示">passl 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">passl</span></span></tt> 编译指示可以把额外参数传递到 C 链接器，就像在命令行使用的 <tt class="docutils literal"><span class="pre option">--passl</span></tt>:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lSDLmain -lSDL&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>请注意，可以使用<a class="reference external" href="system.html">系统模块</a>中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">gorge</span></span></tt> 来嵌入外部命令中的参数，这些参数将在语义分析期间执行:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passl</span><span class="Punctuation">:</span> <span class="Identifier">gorge</span><span class="Punctuation">(</span><span class="StringLit">&quot;pkg-config --libs sdl&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-emit-编译指示" href="#与实现紧密相关的编译指示-emit-编译指示">Emit 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">emit</span></span></tt> 编译指示可以直接影响编译器代码生成器的输出。这样一来，代码将无法移植到其他代码生成器/后端，非常不鼓励使用这种方法。然而，它对于实现与 <span id="cplusplus_1">C++</span> 或 <span id="objective-c_1">Objective C</span> 代码的接口非常有用。</p>
<p>示例:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
static int cvariable = 420;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">stackTrace</span><span class="Punctuation">:</span><span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nimVar</span> <span class="Operator">=</span> <span class="DecNumber">89</span>
  <span class="Comment"># 在 emit 内、字符串字面值以外访问 Nim 符号</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="LongStringLit">&quot;&quot;&quot;fprintf(stdout, &quot;%d\n&quot;, cvariable + (int)&quot;&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nimVar</span><span class="Punctuation">,</span> <span class="StringLit">&quot;);&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">embedsC</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">nimbase</span><span class="Operator">.</span><span class="Identifier">h</span></span></tt> 定义了 <tt class="docutils literal"><span class="pre"><span class="Identifier">NIM_EXTERNC</span></span></tt> C 宏，用于 <tt class="docutils literal"><span class="pre"><span class="Keyword">extern</span> <span class="StringLit">&quot;C&quot;</span></span></tt> 代码，与 <tt class="docutils literal"><span class="pre"><span class="program">nim</span> <span class="option">c</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="program">nim</span> <span class="option">cpp</span></span></tt> 兼容，例如:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foobar</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span><span class="StringLit">&quot;$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;stdio.h&gt;
NIM_EXTERNC
void fun(){}
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
为了向后兼容，如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">emit</span></span></tt> 语句的参数是单一的字符串字面值，可以通过反引号引用 Nim 标识符。但这种用法已经废弃。</div>
<p>顶层 emit 语句所输出的代码混杂在所生成的 C/C++ 文件中，其位置可通过前缀 <tt class="docutils literal"><span class="pre"><span class="Operator">/*</span><span class="Identifier">TYPESECTION</span><span class="Operator">*/</span></span></tt>:c:、<tt class="docutils literal"><span class="pre"><span class="LongComment">/*VARSECTION*/</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="LongComment">/*INCLUDESECTION*/</span></span></tt> 加以影响:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;/*TYPESECTION*/
struct Vector3 {
public:
  Vector3(): x(5) {}
  Vector3(float x_): x(x_) {}
  float x;
};
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span>

<span class="Keyword">proc</span> <span class="Identifier">constructVector3</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">cfloat</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Vector3(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Punctuation">}</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-importcpp-编译指示" href="#与实现紧密相关的编译指示-importcpp-编译指示">ImportCpp 编译指示</a></h2><p><strong>注意</strong>: <a class="reference external" href="https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst">c2nim</a>可以解析大量的C++子集， 关于 <tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 编译指示模式语言，没有必要知道这里描述的所有细节。</p>
<p>与C语言的<a class="reference internal" href="#外部函数接口-importc-编译指示">importc 编译指示</a>类似，<tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 编译指示可以用来导入 <span id="cplusplus_2">C++</span> 方法或一般的C++标识符。 生成的代码使用 C++ 的方法调用语法: <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">-&gt;</span><span class="Identifier">method</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">)</span></span></tt> 。与 <tt class="docutils literal"><span class="pre"><span class="Identifier">header</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">emit</span></span></tt> 编译指示相结合，可与用 C++ 编写的库 <em>宽松</em> 对接。</p>
<p><pre class="listing">
<span class="Comment"># 关于如何与 C++ 引擎对接的可怕示例 ... ;-)</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">link</span><span class="Punctuation">:</span> <span class="StringLit">&quot;/usr/lib/libIrrlicht.so&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
using namespace irr;
using namespace core;
using namespace scene;
using namespace video;
using namespace io;
using namespace gui;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">const</span>
  <span class="Identifier">irr</span> <span class="Operator">=</span> <span class="StringLit">&quot;&lt;irrlicht/irrlicht.h&gt;&quot;</span>

<span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">IrrlichtDevice</span> <span class="Operator">=</span> <span class="Keyword">ptr</span> <span class="Identifier">IrrlichtDeviceObj</span>

<span class="Keyword">proc</span> <span class="Identifier">createDevice</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;createDevice(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">run</span><span class="Punctuation">(</span><span class="Identifier">device</span><span class="Punctuation">:</span> <span class="Identifier">IrrlichtDevice</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.run(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>这个例子需要告知编译器生成 C++ (命令 <tt class="docutils literal"><span class="pre option">cpp</span></tt> ) 才能工作。编译器生成 C++ 代码时会定义条件标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">cpp</span></span></tt>。</p>

<h3><a class="toc-backref" id="importcpp-编译指示-命名空间" href="#importcpp-编译指示-命名空间">命名空间</a></h3><p>这个 <em>宽松对接</em> 的例子使用了 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">emit</span></span></tt> 来生成 <tt class="docutils literal"><span class="pre"><span class="Identifier">using</span> <span class="Identifier">namespace</span></span></tt> 声明。通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">namespace</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">identifier</span></span></tt> 标识符来引用导入的名称往往会更好:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">IrrlichtDeviceObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="Identifier">irr</span><span class="Punctuation">,</span>
                      <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;irr::IrrlichtDevice&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span></pre></p>

<h3><a class="toc-backref" id="importcpp-编译指示-importcpp-应用于枚举" href="#importcpp-编译指示-importcpp-应用于枚举">Importcpp 应用于枚举</a></h3><p><tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 应用于枚举类型时，数字枚举值都会标注 C++ 枚举类型，就像这样: <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">(</span><span class="Identifier">TheCppEnum</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span></span></tt> 。(事实上这已是最简单的实现方式。)</p>

<h3><a class="toc-backref" id="importcpp-编译指示-importcpp-应用于过程" href="#importcpp-编译指示-importcpp-应用于过程">Importcpp 应用于过程</a></h3><p>请注意，用于过程的 <tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 使用了一种有些隐晦的模式语言，以获得最大的灵活性:</p>
<ul class="simple"><li>井号 <tt class="docutils literal"><span class="pre">#</span></tt> 会被第一个或下一个参数所取代。</li>
<li>井号加个点 <tt class="docutils literal"><span class="pre">#.</span></tt> 表示调用应该使用 C++ 的点或箭头符号。</li>
<li>符号 <tt class="docutils literal"><span class="pre">@</span></tt> 被剩余参数替换，通过逗号分隔。</li>
</ul>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.CppMethod(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">CppObj</span>
<span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre></p>
<p>生成:</p>
<p><pre class="listing">
<span class="Identifier">x</span><span class="Operator">-&gt;</span><span class="Identifier">CppMethod</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre></p>
<p>有一项特殊规则: 为了保持与旧版本的 <tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 编译指示的向后兼容性，如果没有任何特殊的模式字符 ( <tt class="docutils literal"><span class="pre"># ' @</span></tt> 中的任意一个 )，就会假定使用 C++ 的点或箭头符号。所以上述例子也可以写成:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">cppMethod</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Identifier">CppObj</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;CppMethod&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>请注意，模式语言当然也具有 C++ 操作符重载的能力:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">vectorAddition</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Vec3</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;# + #&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">dictLookup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Dict</span><span class="Punctuation">,</span> <span class="Identifier">k</span><span class="Punctuation">:</span> <span class="Identifier">Key</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Value</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#]&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<ul class="simple"><li>撇号 <tt class="docutils literal"><span class="pre">'</span></tt> 后面跟着 0..9 范围内的整数 <tt class="docutils literal"><span class="pre">i</span></tt> ，被第 i 个参数的 <em>类型</em> 替换。第 0 个位置是返回值类型。这可以用来向 C++ 函数模板传递类型。</li>
</ul>
<p>在 <tt class="docutils literal"><span class="pre">'</span></tt> 和数字之间，用星号来获得该类型的基本类型。(也就是说，它从类型中“拿走星号”，如 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span><span class="Operator">*</span></span></tt> 变成 <tt class="docutils literal"><span class="pre"><span class="Identifier">T</span></span></tt> 。)两个星号可以用来获取元素类型的元素类型，等等。</p>
<p>例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">Input</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;System::Input&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Identifier">getSubsystem</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;SystemManager::getSubsystem&lt;'*0&gt;()&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Input</span> <span class="Operator">=</span> <span class="Identifier">getSubsystem</span><span class="Punctuation">[</span><span class="Identifier">Input</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>生成:</p>
<p><pre class="listing">
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">SystemManager</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">getSubsystem</span><span class="Operator">&lt;</span><span class="Identifier">System</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">Input</span><span class="Operator">&gt;</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Comment">#@</span></span></tt> 用来支持 <tt class="docutils literal"><span class="pre"><span class="Identifier">cnew</span></span></tt> 操作这一特殊情况。它使调用表达式直接被内联，而不需要经过一个临时地址。这只是为了规避当前代码生成器的限制。</li>
</ul>
<p>例如，C++中 <tt class="docutils literal"><span class="pre"><span class="Keyword">new</span></span></tt> 运算符可以像这样“导入”:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">cnew</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">T</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;(new '*0#@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Comment"># 'Foo' 的构造函数:</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">cnew</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre></p>
<p>生成:</p>
<p><pre class="listing">
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">new</span> <span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre></p>
<p>然而，根据使用情况 <tt class="docutils literal"><span class="pre"><span class="Keyword">new</span> <span class="Identifier">Foo</span></span></tt> 也可以像这样包装:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;new Foo(@)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">newFoo</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span></pre></p>

<h3><a class="toc-backref" id="importcpp-编译指示-包装构造函数" href="#importcpp-编译指示-包装构造函数">包装构造函数</a></h3><p>有时候 C++ 类的拷贝构造函数是私有的，所以不能生成 <tt class="docutils literal"><span class="pre"><span class="Identifier">Class</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">Class</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">;</span></span></tt>:cpp:，而应该是 <tt class="docutils literal"><span class="pre"><span class="Identifier">Class</span> <span class="Identifier">c</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">;</span></span></tt> 。 要达到这个目的，需要给包装 C++ 构造函数的 Nim 过程加上 <span id="constructor_1">constructor</span> 编译指示。这个编译指示也有助于生成更快的 C++ 代码，因为这样一来构造时就不会再调用拷贝构造函数:</p>
<p><pre class="listing">
<span class="Comment"># 'Foo' 的更好的构造函数:</span>
<span class="Keyword">proc</span> <span class="Identifier">constructFoo</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Foo(@)&quot;</span><span class="Punctuation">,</span> <span class="Identifier">constructor</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h3><a class="toc-backref" id="importcpp-编译指示-包装析构函数" href="#importcpp-编译指示-包装析构函数">包装析构函数</a></h3><p>由于 Nim 直接生成C++，任何析构函数都会在作用域退出时被 C++ 编译器隐式调用。这意味着，通常我们可以不包装析构函数！ 但是，当需要显式调用它时，就需要包装。模式语言提供了所需一切:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">destroyFoo</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Foo</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#.~Foo()&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h3><a class="toc-backref" id="importcpp-编译指示-importcpp-应用于对象" href="#importcpp-编译指示-importcpp-应用于对象">Importcpp 应用于对象</a></h3><p>C++ 模板被映射成 <tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 泛型对象。这意味着可以很容易地导入 C++ 模板，不需要再为对象类型设计模式语言:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::map&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">this</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">K</span><span class="Punctuation">,</span> <span class="Identifier">V</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">key</span><span class="Punctuation">:</span> <span class="Identifier">K</span><span class="Punctuation">;</span> <span class="Identifier">val</span><span class="Punctuation">:</span> <span class="Identifier">V</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span>
  <span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;#[#] = #&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;map&gt;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">StdMap</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">,</span> <span class="Identifier">cdouble</span><span class="Punctuation">]</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span></pre></p>
<p>生成:</p>
<p><pre class="listing">
<span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">map</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Punctuation">,</span> <span class="Keyword">double</span><span class="Operator">&gt;</span> <span class="Identifier">x</span><span class="Punctuation">;</span>
<span class="Identifier">x</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="FloatNumber">91.4</span><span class="Punctuation">;</span></pre></p>
<ul class="simple"><li><p>如果需要更精确的控制，可以在提供的模式中使用撇号 <tt class="docutils literal"><span class="pre"><span class="CharLit">'</span></span></tt> 来表示泛型的具体类型参数。更多细节请参见过程模式中的撇号操作符的用法。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">VectorIterator</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importcpp</span><span class="Punctuation">:</span> <span class="StringLit">&quot;std::vector&lt;'0&gt;::iterator&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">VectorIterator</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span></pre></p>
<p>生成:</p>
<p><pre class="listing">

<span class="Identifier">std</span><span class="Punctuation">:</span><span class="Punctuation">:</span><span class="Identifier">vector</span><span class="Operator">&lt;</span><span class="Keyword">int</span><span class="Operator">&gt;::</span><span class="Identifier">iterator</span> <span class="Identifier">x</span><span class="Punctuation">;</span></pre></p>
</li>
</ul>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-importjs-编译指示" href="#与实现紧密相关的编译指示-importjs-编译指示">ImportJs 编译指示</a></h2><p>与C++的<a class="reference internal" href="#与实现紧密相关的编译指示-importcpp-编译指示">importcpp 编译指示</a>类似，<tt class="docutils literal"><span class="pre"><span class="Identifier">importjs</span></span></tt> 编译指示可以用来导入Javascript方法或一般的标识符。 生成的代码使用Javascript方法的调用语法: <tt class="docutils literal"><span class="pre">obj.method(arg)</span></tt> 。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-importobjc-编译指示" href="#与实现紧密相关的编译指示-importobjc-编译指示">ImportObjC 编译指示</a></h2><p>类似于C语言的<a class="reference internal" href="#外部函数接口-importc-编译指示">importc 编译指示</a>，<tt class="docutils literal"><span class="pre"><span class="Identifier">importobjc</span></span></tt> 编译指示可以用来导入 <span id="objective-c_2">Objective C</span> 方法。 生成的代码使用Objective C的方法调用语法。 <tt class="docutils literal"><span class="pre">[obj method param1: arg]</span></tt> 。 除了 <tt class="docutils literal"><span class="pre"><span class="Identifier">header</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">emit</span></span></tt> 编译指示，允许<em>宽松</em>地与用Objective C编写的库对接。</p>
<p><pre class="listing">
<span class="Comment"># 关于如何与 GNUStep 对接的可怕示例...</span>

<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">passl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;-lobjc&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="LongStringLit">&quot;&quot;&quot;
#include &lt;objc/Object.h&gt;
@interface Greeter:Object
{
}

- (void)greet:(long)x y:(long)dummy;
@end

#include &lt;stdio.h&gt;
@implementation Greeter

- (void)greet:(long)x y:(long)dummy
{
  printf(&quot;Hello, World!\n&quot;);
}
@end

#include &lt;stdlib.h&gt;
&quot;&quot;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">type</span>
  <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;id&quot;</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;objc/Object.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">distinct</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">newGreeter</span><span class="Punctuation">:</span> <span class="Identifier">Id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Greeter new&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">greet</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;greet&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">proc</span> <span class="Identifier">free</span><span class="Punctuation">(</span><span class="Identifier">self</span><span class="Punctuation">:</span> <span class="Identifier">Id</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importobjc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;free&quot;</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">var</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="Identifier">newGreeter</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">greet</span><span class="Punctuation">(</span><span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="DecNumber">34</span><span class="Punctuation">)</span>
<span class="Identifier">g</span><span class="Operator">.</span><span class="Identifier">free</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>
<p>这个例子需要告知编译器生成 Objective C (命令 <tt class="docutils literal"><span class="pre option">objc</span></tt> ) 才能工作。当编译器输出 Objective C 代码时会定义条件标识符 <tt class="docutils literal"><span class="pre"><span class="Identifier">objc</span></span></tt>。</p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-codegendecl-编译指示" href="#与实现紧密相关的编译指示-codegendecl-编译指示">CodegenDecl 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">codegenDecl</span></span></tt> 编译指示可以直接影响 Nim 的代码生成器。它接受一个格式字符串，用于决定变量或过程如何在生成的代码中声明。</p>
<p>对于变量，格式字符串中的 $1 表示变量的类型，$2 表示变量的名称，$# 按出现的先后顺序依次表示 $1、$2。</p>
<p>以下 Nim 代码:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;$# progmem $#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>将生成此 C 代码:</p>
<p><pre class="listing">
<span class="Keyword">int</span> <span class="Identifier">progmem</span> <span class="Identifier">a</span></pre></p>
<p>对过程而言，$1是过程的返回值类型，$2是过程的名字，$3是参数列表，$# 按出现的先后顺序依次表示 $1、$2、$3。</p>
<p>以下 Nim 代码:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">codegenDecl</span><span class="Punctuation">:</span> <span class="StringLit">&quot;__interrupt $# $#$#&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;realistic interrupt handler&quot;</span></pre></p>
<p>将生成此代码:</p>
<p><pre class="listing">
<span class="Identifier">__interrupt</span> <span class="Keyword">void</span> <span class="Identifier">myinterrupt</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-nimcppnonpod-编译指示" href="#与实现紧密相关的编译指示-nimcppnonpod-编译指示"><tt class="docutils literal"><span class="pre"><span class="Identifier">cppNonPod</span></span></tt> 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">importcpp</span></span></tt> 非 POD 类型时应该加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">cppNonPod</span></span></tt> 编译指示，这样用作 <tt class="docutils literal"><span class="pre"><span class="Identifier">threadvar</span></span></tt> 变量时才可能正常工作(尤其是对构造函数和析构函数而言)。这需要 <tt class="docutils literal"><span class="pre option">--tlsEmulation:off</span></tt> 。</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">Foo</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cppNonPod</span><span class="Punctuation">,</span> <span class="Identifier">importcpp</span><span class="Punctuation">,</span> <span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;funs.h&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">cint</span>
<span class="Keyword">proc</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span></pre></p>

<h2><a class="toc-backref" id="与实现紧密相关的编译指示-编译期的-define-编译指示" href="#与实现紧密相关的编译指示-编译期的-define-编译指示">编译期的 define 编译指示</a></h2><p>这里列出的编译指示可以用来在编译时接收来自 <tt class="docutils literal"><span class="pre option">-d/-define</span></tt> 命令行参数的值。</p>
<p>当前提供了以下编译指示 (以后可能增加)。</p>
<table border="1" class="docutils"><tr><th>编译指示</th><th>描述</th></tr>
<tr><td><span id="intdefine_1">intdefine</span></td><td>在编译时将 define 读取为整数类型</td></tr>
<tr><td><span id="strdefine_1">strdefine</span></td><td>在编译时将 define 读取为字符串类型</td></tr>
<tr><td><span id="booldefine_1">booldefine</span></td><td>在编译时将 define 读取为布尔类型</td></tr>
</table><p><pre class="listing">
<span class="Keyword">const</span> <span class="Identifier">FooBar</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">intdefine</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">5</span>
<span class="Identifier">echo</span> <span class="Identifier">FooBar</span></pre></p>
<p><pre class="listing">
<span class="program">nim</span> <span class="option">c</span> <span class="option">-d:FooBar=42</span> <span class="Identifier">foobar.nim</span></pre></p>
<p>在上述例子中，<tt class="docutils literal"><span class="pre option">-d</span></tt> 标志在编译时覆盖 <tt class="docutils literal"><span class="pre"><span class="Identifier">FooBar</span></span></tt> 的默认值，打印出 42。如果删除 <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">FooBar</span><span class="Operator">=</span><span class="DecNumber">42</span></span></tt>:option:，则使用默认值5。可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">FooBar</span><span class="Punctuation">)</span></span></tt> 判断是否为它提供了值。</p>
<p>语法 <tt class="docutils literal"><span class="pre option">-d:flag</span></tt> 实际上是 <tt class="docutils literal"><span class="pre option">-d:flag=true</span></tt> 的简写。</p>

<h1><a class="toc-backref" id="用户定义的编译指示" href="#用户定义的编译指示">用户定义的编译指示</a></h1>
<h2><a class="toc-backref" id="用户定义的编译指示-pragma-编译指示" href="#用户定义的编译指示-pragma-编译指示">pragma 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">pragma</span></span></tt> 编译指示可以用来声明用户定义的编译指示。这是有用的，因为 Nim 的模板和宏不会影响编译指示。用户定义的编译指示处于与所有其他符号都不同的模块作用域。它们不能从模块中导入。</p>
<p>示例:</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span></pre></p>
<p>在这个例子中，引入了一个名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">rtl</span></span></tt> 的新编译指示，它表示要么从动态库中导入符号，要么为生成动态库而导出符号。</p>

<h2><a class="toc-backref" id="用户定义的编译指示-定制注解" href="#用户定义的编译指示-定制注解">定制注解</a></h2><p>可以定制带类型的编译指示。定制的编译指示不会直接影响代码生成，但宏可以检测到它们的存在。给模板加上 <tt class="docutils literal"><span class="pre"><span class="Identifier">pragma</span></span></tt> 编译指示就能定义定制的编译指示:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">table_space</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">primary_key</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbForeignKey</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">typedesc</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">template</span> <span class="Identifier">dbIgnore</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>考查这个有风格的例子，它是关于对象关系映射 (ORM) 的一个合理实现:</p>
<p><pre class="listing">
<span class="Keyword">const</span> <span class="Identifier">tblspace</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">strdefine</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="StringLit">&quot;dev&quot;</span> <span class="Comment"># 控制开发、测试、生成环境的开关</span>

<span class="Keyword">type</span>
  <span class="Identifier">User</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;users&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">name</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="RawData">dbKey&quot;full_name&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">is_cached</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbIgnore</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Identifier">UserProfile</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbTable</span><span class="Punctuation">(</span><span class="StringLit">&quot;profiles&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tblspace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbKey</span><span class="Punctuation">(</span><span class="Identifier">primary_key</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">user_id</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dbForeignKey</span><span class="Punctuation">:</span> <span class="Identifier">User</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">read_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">write_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span>
    <span class="Identifier">admin_access</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre></p>
<p>在本例中，通过定制的编译指示来描述 Nim 对象如何被映射到关系数据库的模式中。定制的编译指示可以有零个或多个参数。请使用模板调用语法来传递多个参数。 所有的参数都有类型，并且遵循模板的标准重载解析规则。因此，可以为参数设置默认值，可以通过名称传递，可以使用可变参数，等等。</p>
<p>所有可以使用普通编译指示的地方，都可以使用定制的编译指示，为过程、模板、类型和变量定义、语句等添加注解。</p>
<p>宏模块包含工具，可以用来简化自定义编译指示的访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">hasCustomPragma</span></span></tt> , <tt class="docutils literal"><span class="pre"><span class="Identifier">getCustomPragmaVal</span></span></tt> 。 详情参阅<a class="reference external" href="macros.html">宏</a>模块文档。这些宏并不神奇，它们也可以通过逐步的对象表示的AST来实现。</p>
<p>更多自定义编译指示的例子:</p>
<ul class="simple"><li><p>更好的序列化/反序列化控制:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">MyObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">a</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">dontSerialize</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">b</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">defaultDeserialize</span><span class="Punctuation">:</span> <span class="FloatNumber">5.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">c</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">serializationKey</span><span class="Punctuation">:</span> <span class="StringLit">&quot;_c&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
</li>
<li><p>在游戏引擎中为 gui 查看器添加类型:</p>
<p><pre class="listing">
<span class="Keyword">type</span> <span class="Identifier">MyComponent</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">position</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editable</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">Vector3</span>
  <span class="Identifier">alpha</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">editRange</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="FloatNumber">0.0</span><span class="Operator">..</span><span class="FloatNumber">1.0</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">animatable</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">float32</span></pre></p>
</li>
</ul>

<h2><a class="toc-backref" id="用户定义的编译指示-宏编译指示" href="#用户定义的编译指示-宏编译指示">宏编译指示</a></h2><p>有时可以用编译指示语法来调用宏和模板，比如用在例程(过程、迭代器等)声明或例程类型表达式上。编译器执行以下简单的语法转换:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">command</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">def</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">command</span><span class="Punctuation">(</span><span class="StringLit">&quot;print&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<p>转换为:</p>
<p><pre class="listing">
<span class="Identifier">command</span><span class="Punctuation">(</span><span class="StringLit">&quot;print&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span></pre></p>
<hr />
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">AsyncEventHandler</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Event</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">async</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>转换为:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">AsyncEventHandler</span> <span class="Operator">=</span> <span class="Identifier">async</span><span class="Punctuation">(</span><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Event</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<hr />
<p>当多个宏编译指示应用于同一个定义时，从左到右的第一个将先被求值。 然后，这个宏可以选择是否在其输出中保留其余的宏编译指示。保留下的那些宏编译指示的求值方式依此类推。</p>
<p>宏编译指示还有一些应用，比如在类型、变量和常量声明中，但这是实验性的， 记录在<a class="reference external" href=" manual_experimental.html#extended-macro-pragmas">实验手册</a>。</p>

<h1><a class="toc-backref" id="外部函数接口" href="#外部函数接口">外部函数接口</a></h1><p>Nim 的 <span id="ffi_1">FFI</span> (外部函数接口) 很广博，这里只讲述将来会推广到其他后端(如 LLVM/JavaScript 后端) 的部分。</p>

<h2><a class="toc-backref" id="外部函数接口-importc-编译指示" href="#外部函数接口-importc-编译指示">Importc 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">importc</span></span></tt> 编译指示提供了一种从 C 语言导入程序或变量的方法。可选参数是一个包含 C 标识符的字符串。如果没有这个参数，C 名称就和 Nim 的标识符 <em>一字不差</em>:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>当 <tt class="docutils literal"><span class="pre"><span class="Identifier">importc</span></span></tt> 应用于 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 语句时不需要提供值，因为这时期望从 C 取得值。这个用法能够导入 C <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt>:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">emit</span><span class="Punctuation">:</span> <span class="StringLit">&quot;const int cconst = 42;&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">let</span> <span class="Identifier">cconst</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">nodecl</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">cint</span>

<span class="Identifier">assert</span> <span class="Identifier">cconst</span> <span class="Operator">==</span> <span class="DecNumber">42</span></pre></p>
<p>注意，这个编译指示曾在 JS 后端滥用，用来导入 JS 对象和函数。其他后端也支持这个编译指示，功能相同。另外，当目标语言不是 C 时，还有其他的编译指示:</p>
<ul class="simple"><li><a class="reference internal" href="#与实现紧密相关的编译指示-importcpp-编译指示">importcpp</a></li>
<li><a class="reference internal" href="#与实现紧密相关的编译指示-importobjc-编译指示">importobjc</a></li>
<li><a class="reference internal" href="#与实现紧密相关的编译指示-importjs-编译指示">importjs</a></li>
</ul>
<p>传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">importc</span></span></tt> 的字符串字面量可以是一个格式化字符串:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>在这个例子里，<tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的外部名称被设置为 <tt class="docutils literal"><span class="pre"><span class="Identifier">prefixp</span></span></tt>。只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-exportc-编译指示" href="#外部函数接口-exportc-编译指示">Exportc 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">exportc</span></span></tt> 编译指示提供了一种将类型、变量或过程导出到 C 的手段。枚举和常量不能导出。可选参数是包含 C 标识符的字符串。如果参数缺失，C 名字就和 Nim 标识符 <em>一字不差</em> :</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">callme</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;callMe&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>请注意这个编译指示的名称有点用词不当: 因为其他后端也通过这个名称提供了相同功能。</p>
<p>传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">exportc</span></span></tt> 的字符串字面量可以是一个格式化字符串:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre></p>
<p>在这个例子里，<tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的外部名称被设置为 <tt class="docutils literal"><span class="pre"><span class="Identifier">prefixp</span></span></tt>。只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>
<p>如果该标识符也应被导出到一个动态库中，除了使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">exportc</span></span></tt> 编译指示外， 还应该使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 编译指示。参阅<a class="reference internal" href="#Dynlib编译指示应用于导出">Dynlib编译指示应用于导出</a>。</p>

<h2><a class="toc-backref" id="外部函数接口-extern-编译指示" href="#外部函数接口-extern-编译指示">Extern 编译指示</a></h2><p>像 <tt class="docutils literal"><span class="pre"><span class="Identifier">exportc</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">importc</span></span></tt>一样, <tt class="docutils literal"><span class="pre"><span class="Identifier">extern</span></span></tt> 编译指示也能影响名称混淆。传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">extern</span></span></tt> 的字符串字面量可以是一个格式化字符串:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre></p>
<p>在这个例子里，<tt class="docutils literal"><span class="pre"><span class="Identifier">p</span></span></tt> 的外部名称被设置为 <tt class="docutils literal"><span class="pre"><span class="Identifier">prefixp</span></span></tt>。只有 <tt class="docutils literal"><span class="pre">$1</span></tt> 可用，美元符号必须写成 <tt class="docutils literal"><span class="pre">$$</span></tt> 。</p>

<h2><a class="toc-backref" id="外部函数接口-bycopy-编译指示" href="#外部函数接口-bycopy-编译指示">Bycopy 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">bycopy</span></span></tt> 编译指示可以用于对象或元组类型，指示编译器给过程传递此类型的参数时采用值传递的方式:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Vector</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">bycopy</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span></pre></p>
<p>Nim 编译器根据参数类型的大小自动决定采用值传递还是引用传递。如果一个参数必须通过值传递或引用传递(例如当与 C 库对接时)，请使用 bycopy 或 byref 编译指示。</p>

<h2><a class="toc-backref" id="外部函数接口-byref-编译指示" href="#外部函数接口-byref-编译指示">Byref 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">byref</span></span></tt> 编译指示可以用于对象或元组类型，指示编译器给过程传递此类型的参数时采用引用(隐藏起来的指针)传递的方式:</p>

<h2><a class="toc-backref" id="外部函数接口-varargs-编译指示" href="#外部函数接口-varargs-编译指示">Varargs 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 编译指示只能用于过程(和过程类型)。它告知 Nim 在最后一个指定的参数之后，过程还可以接受数目不定的若干参数。Nim 字符串值将会自动转换为 C 字符串:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;%s 内侯!&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;世界&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;世界&quot; 作为 C 字符串传递</span></pre></p>

<h2><a class="toc-backref" id="外部函数接口-union-编译指示" href="#外部函数接口-union-编译指示">Union 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">union</span></span></tt> 编译指示可以应用于任意 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 类型，表示这个对象的每个字段在内存中都重叠在一起。生成 C/C++ 代码时将产生联合体(<tt class="docutils literal"><span class="pre"><span class="Keyword">union</span></span></tt>)而不是结构体(<tt class="docutils literal"><span class="pre"><span class="Keyword">struct</span></span></tt>)。声明这个对象时禁止使用继承、禁止使用带 GC 的内存，但目前编译器不做这个检查。</p>
<p><strong>未来的方向</strong>: 应该允许联合体使用带 GC 的内存，而 GC 应该保守地扫描联合体。</p>

<h2><a class="toc-backref" id="外部函数接口-packed-编译指示" href="#外部函数接口-packed-编译指示">Packed 编译指示</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">packed</span></span></tt> 编译指示可以用于任意 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span></span></tt> 类型，确保对象里的字段一个接一个地紧密排放。 当需要访问网络、硬件驱动，或者与 C 语言进行互操作时，这个编译指示非常有用。将 packed 编译指示与继承相结合是未定义的。它也不应该用于带 GC 的内存(使用引用)。</p>
<p><strong>未来方向</strong>: 在 packed 编译指示中使用带 GC 的内存将导致静态错误。继承用法应加以定义并写进文档。</p>

<h2><a class="toc-backref" id="外部函数接口-用于导入的-dynlib-编译指示" href="#外部函数接口-用于导入的-dynlib-编译指示">用于导入的 dynlib 编译指示</a></h2><p>使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 编译指示从动态库(Windows 上的 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Identifier">dll</span></span></tt> 文件, UNIX 上的 <tt class="docutils literal"><span class="pre"><span class="Identifier">lib</span><span class="Operator">*.</span><span class="Identifier">so</span></span></tt> 文件)中导入过程或变量。 必须把动态库的名称写在参数里:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>一般来说，导入动态库不需要任何特殊链接选项或与导入库链接。这也意味着不需要安装 <em>devel</em> 软件包。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 导入机制支持版本化:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>运行时, 动态库(按此顺序)搜索:<pre>libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0</pre>
</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 编译指示不仅支持作为参数的常量字符串，还支持普通的字符串表达式:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">fileExists</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">fileExists</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;无法加载动态库&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p><strong>注意</strong>: 类似 <tt class="docutils literal"><span class="pre">libtcl(|8.5|8.4).so</span></tt> 的形式只支持常量字符串，因为它们是预编译的。</p>
<p><strong>注意</strong>: 由于初始化顺序的问题，向 <tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 编译指示传递变量将在运行时出错。</p>
<p><strong>注意</strong>: <tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 导入，可以通过  <tt class="docutils literal"><span class="pre option">--dynlibOverride:name</span></tt> 命令行选项进行覆盖，参阅<a class="reference external" href="nimc.html"> 编译器用户指南</a>]。</p>

<h2><a class="toc-backref" id="外部函数接口-dynlib-编译指示应用于导出" href="#外部函数接口-dynlib-编译指示应用于导出">Dynlib 编译指示应用于导出</a></h2><p>一个使用了 <tt class="docutils literal"><span class="pre"><span class="Identifier">dynlib</span></span></tt> 编译指示的过程，也能被导出为动态库。这时，它不需要参数，但必须结合 <tt class="docutils literal"><span class="pre"><span class="Identifier">exportc</span></span></tt> 编译指示来使用:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>
<p>这只有在程序通过 <tt class="docutils literal"><span class="pre option">--app:lib</span></tt> 命令行选项被编译为动态库时才有用。</p>

<h1><a class="toc-backref" id="线程" href="#线程">线程</a></h1><p>使用 <tt class="docutils literal"><span class="pre option">--threads:on</span></tt> 命令行开关启用线程支持。启用后<a class="reference external" href="system.html">system module</a>模块会包含几个线程原语。 关于底层线程 API，参阅<a class="reference external" href="channels_builtin.html">channels</a>模块。还有一些高层次的并行结构可用，参阅<a class="reference external" href="manual_experimental.html#parallel-amp-spawn">spawn</a> 。</p>
<p>相较于其他的通用编程语言(C，Pascal，Java)，Nim 中线程的内存模型是相当与众不同的： 每个线程都有它自己的(垃圾回收)堆，内存共享也仅限于全局变量。这样有助于防止竞态条件。 因为 GC 永远不必停止其他线程，并查看它们到底引用了什么，故而 GC 的效率也大大提升。</p>
<p>只能通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">spawn</span></span></tt> 或者 <tt class="docutils literal"><span class="pre"><span class="Identifier">createThread</span></span></tt> 创建线程。被调用的过程不得使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 声明参数，参数类型也不得包含 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">closure</span></span></tt> 。 强制实行<em>无堆共享限制</em>。</p>

<h2><a class="toc-backref" id="线程-thread-编译指示" href="#线程-thread-编译指示">Thread 编译指示</a></h2><p>出于可读性的考虑，作为新线程执行的程序应该用 <tt class="docutils literal"><span class="pre"><span class="Identifier">thread</span></span></tt> 编译指示进行标记。 编译器会检查是否违反了 <span id="no-heap-sharing-restriction_1">no heap sharing restriction</span> &quot;无堆共享限制&quot;： 这个限制的意思是，由来自不同的(线程本地)堆上的内存所组成的数据结构是无效的。</p>
<p>线程过程可以被传递给 <tt class="docutils literal"><span class="pre"><span class="Identifier">createThread</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">spawn</span></span></tt> 。</p>

<h2><a class="toc-backref" id="线程-threadvar-编译指示" href="#线程-threadvar-编译指示">Threadvar 编译指示</a></h2><p>变量可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">threadvar</span></span></tt> 编译指示来标记，这会使它成为 <span id="threadminuslocal_1">thread-local</span> &quot;线程本地&quot;变量； 此外，这意味着 <tt class="docutils literal"><span class="pre"><span class="Identifier">global</span></span></tt> 编译指示的所有作用。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">checkpoints</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">threadvar</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></pre></p>
<p>由于实现的限制，本地线程变量不能在 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 块中初始化。(每个线程本地变量都需要在线程创建时复制。)</p>

<h2><a class="toc-backref" id="线程-线程和异常" href="#线程-线程和异常">线程和异常</a></h2><p>线程和异常之间的交互很简单: 一个线程中， <em>被捕获</em> 了的异常，无法影响其他的线程。 然而，某个线程中 <em>未捕获</em> 的异常，会终止整个 <em>进程</em> 。</p>

<h1><a class="toc-backref" id="守卫和锁" href="#守卫和锁">守卫和锁</a></h1><p>Nim 提供了诸如锁、原子性内部函数或条件变量这样的常见底层并发机制。</p>
<p>Nim 通过附带编译指示，显著地提高了这些功能的安全性:</p>
<ol class="simple"><li>引入 <span id="guard_1">guard</span> 注解，以防止数据竞争。</li>
<li>每次访问受保护的内存位置，都需要在适当的 <span id="locks_1">locks</span> 语句中进行。</li>
</ol>

<h2><a class="toc-backref" id="守卫和锁-守卫和锁块" href="#守卫和锁-守卫和锁块">守卫和锁块</a></h2>
<h3><a class="toc-backref" id="守卫和锁块-受保护的全局变量" href="#守卫和锁块-受保护的全局变量">受保护的全局变量</a></h3><p>对象字段和全局变量都可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">guard</span></span></tt> 编译指令进行标注:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">locks</span>

<span class="Keyword">var</span> <span class="Identifier">glock</span><span class="Punctuation">:</span> <span class="Identifier">Lock</span>
<span class="Keyword">var</span> <span class="Identifier">gdata</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">glock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>然后，编译器会确保每次访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">gdata</span></span></tt> 都在 <tt class="docutils literal"><span class="pre"><span class="Identifier">locks</span></span></tt> 块中:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">invalid</span> <span class="Operator">=</span>
  <span class="Comment"># invalid: unguarded access:</span>
  <span class="Identifier">echo</span> <span class="Identifier">gdata</span>

<span class="Keyword">proc</span> <span class="Identifier">valid</span> <span class="Operator">=</span>
  <span class="Comment"># valid access:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">glock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">gdata</span></pre></p>
<p>为了能够方便地初始化，始终允许在顶层访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">gdata</span></span></tt>。 <em>假定</em> (但不强制)所有顶层语句都在发生并发操作之前执行。</p>
<p>我们故意让 <tt class="docutils literal"><span class="pre"><span class="Identifier">locks</span></span></tt> 块看起来很丑，因为它没有运行时的语意，也不应该被直接使用！ 它应该只在模板里出现，再由模板实现运行时的加锁操作:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Lock</span><span class="Punctuation">;</span> <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></pre></p>
<p>守卫不需要属于某种特定类型。它足够灵活，可以对低级无锁机制建模:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">dummyLock</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">compileTime</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Keyword">var</span> <span class="Identifier">atomicCounter</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">dummyLock</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">template</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">dummyLock</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
    <span class="Identifier">memoryReadBarrier</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span>

<span class="Identifier">echo</span> <span class="Identifier">atomicRead</span><span class="Punctuation">(</span><span class="Identifier">atomicCounter</span><span class="Punctuation">)</span></pre></p>
<p>为了支持 <em>多锁</em> 语句，<tt class="docutils literal"><span class="pre"><span class="Identifier">locks</span></span></tt> 编译指示后面是锁表达式的列表 <tt class="docutils literal"><span class="pre"><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">]</span></span></tt> 。 在实验手册的<a class="reference external" href="manual_experimental.md#lock-levels">lock levels</a>章节中对这样做的重要性进行了解释。</p>

<h3><a class="toc-backref" id="守卫和锁块-保护常规地址" href="#守卫和锁块-保护常规地址">保护常规地址</a></h3><p><tt class="docutils literal"><span class="pre"><span class="Identifier">guard</span></span></tt> 注解也可以用于保护对象中的字段。这时，需要用同一个对象的另一个字段或者一个全局变量作为守卫。</p>
<p>由于对象可以驻留在堆上或栈上，这就大大地增强了语言的表达能力:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">locks</span>

<span class="Keyword">type</span>
  <span class="Identifier">ProtectedCounter</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">v</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">guard</span><span class="Punctuation">:</span> <span class="Identifier">L</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">L</span><span class="Punctuation">:</span> <span class="Identifier">Lock</span>

<span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">lock</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">:</span>
      <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre></p>
<p>有 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">L</span></span></tt> 的守卫就可以访问字段 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">v</span></span></tt>。模板展开后得到:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">incCounters</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">ProtectedCounter</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">counters</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">:</span>
    <span class="Identifier">pthread_mutex_lock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">try</span><span class="Punctuation">:</span>
        <span class="Identifier">inc</span> <span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span>
      <span class="Keyword">finally</span><span class="Punctuation">:</span>
        <span class="Identifier">pthread_mutex_unlock</span><span class="Punctuation">(</span><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">)</span></pre></p>
<p>编译器会分析检查 <tt class="docutils literal"><span class="pre"><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span></span></tt> 是否是用于受保护位置 <tt class="docutils literal"><span class="pre"><span class="Identifier">counters</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></span></tt> 的那个锁。 因为这个分析能够处理像 <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">.</span><span class="Identifier">field</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">fieldB</span><span class="Punctuation">[</span><span class="Identifier">j</span><span class="Punctuation">]</span></span></tt> 这样的路径，所以我们叫它 <span id="path-analysis_1">path analysis</span> &quot;路径分析&quot;。</p>
<p>路径分析 <strong>目前不健全</strong> ，但也不是一点儿用都没有。如果两条路径在语法上相同，则认为是等价的。</p>
<p>这意味着下面的代码(目前)可以编译通过，虽然真不应该如此：</p>

<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">locks</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">L</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span>
  <span class="Identifier">access</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">v</span></pre></p>
</p>
<p>手册仓库地址：https://github.com/VectorWorkshopBaoErJie/nimDocTranslate</p>
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2022-10-07 13:36:47 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
