<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim 教程 (第 III 部分)</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<!-- JS -->
<script type="text/javascript" src="dochack.js"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim 教程 (第 III 部分)</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">🌗 Match OS</option>
        <option value="dark">🌑 Dark</option>
        <option value="light">🌕 Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" onkeyup="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="引言_toc" href="#引言">引言</a></li>
<ul class="simple"><li><a class="reference" id="引言-宏实参_toc" href="#引言-宏实参">宏实参</a></li>
<li><a class="reference" id="引言-无类型实参_toc" href="#引言-无类型实参">无类型实参</a></li>
<li><a class="reference" id="引言-类型化实参_toc" href="#引言-类型化实参">类型化实参</a></li>
<li><a class="reference" id="引言-静态实参_toc" href="#引言-静态实参">静态实参</a></li>
<li><a class="reference" id="引言-代码块作为实参_toc" href="#引言-代码块作为实参">代码块作为实参</a></li>
<li><a class="reference" id="引言-语法树_toc" href="#引言-语法树">语法树</a></li>
<li><a class="reference" id="引言-自定义语义检查_toc" href="#引言-自定义语义检查">自定义语义检查</a></li>
<li><a class="reference" id="引言-代码生成_toc" href="#引言-代码生成">代码生成</a></li>
<li><a class="reference" id="引言-构建你的第一个宏_toc" href="#引言-构建你的第一个宏">构建你的第一个宏</a></li>
<li><a class="reference" id="引言-能力越大，责任越大_toc" href="#引言-能力越大，责任越大">能力越大，责任越大</a></li>
<li><a class="reference" id="引言-限制_toc" href="#引言-限制">限制</a></li>
</ul><li><a class="reference" id="更多示例_toc" href="#更多示例">更多示例</a></li>
<ul class="simple"><li><a class="reference" id="更多示例-strformat_toc" href="#更多示例-strformat">Strformat</a></li>
<li><a class="reference" id="更多示例-ast-pattern-matching_toc" href="#更多示例-ast-pattern-matching">Ast Pattern Matching</a></li>
<li><a class="reference" id="更多示例-opengl-沙盒_toc" href="#更多示例-opengl-沙盒">OpenGL 沙盒</a></li>
</ul>
</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Arne Döring</td></tr>
<tr><th class="docinfo-name">Version:</th><td>|nimversion|</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="引言" href="#引言">引言</a></h1><blockquote class="markdown-quote"><p>&quot;With Great Power Comes Great Responsibility.&quot; -- Spider Man's Uncle</p></blockquote>
<p>本文档是 Nim 宏系统的教程。宏是在编译时执行并将 Nim 语法树转换成一个不同树的函数。</p>
<p>可用宏实现的例子:</p>
<ul class="simple"><li>如果断言失败，则打印比较运算符两侧内容的断言宏。 <tt class="docutils literal"><span class="pre"><span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="Operator">$</span><span class="Identifier">a</span> <span class="StringLit">&quot; != &quot;</span> <span class="Operator">$</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt></li>
<li>打印符号的值和名称的调试宏。<tt class="docutils literal"><span class="pre"><span class="Identifier">myDebugEcho</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span> <span class="StringLit">&quot;a: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">a</span></span></tt></li>
<li>表达式的微分。 <tt class="docutils literal"><span class="pre"><span class="Identifier">diff</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">*</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="DecNumber">3</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Operator">*</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">d</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="DecNumber">3</span><span class="Operator">*</span><span class="Identifier">a</span><span class="Operator">*</span><span class="Identifier">pow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span><span class="DecNumber">2</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="DecNumber">2</span><span class="Operator">*</span><span class="Identifier">b</span><span class="Operator">*</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">c</span></span></tt></li>
</ul>

<h2><a class="toc-backref" id="引言-宏实参" href="#引言-宏实参">宏实参</a></h2><p>宏的实参具有两面性。一面用于重载解析，另一面用于宏内。例如，如果 <tt class="docutils literal"><span class="pre"><span class="Keyword">macro</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span></span></tt> 在表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 中被调用，<tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 必须是与 int 兼容的类型，但在宏<em>内</em> <tt class="docutils literal"><span class="pre"><span class="Identifier">arg</span></span></tt> 的类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt>，而非 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>! 这么做的原因当我们见到具体的例子时就明了了。</p>
<p>有两种方法可以给宏传参，实参必须是 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 其中一种。</p>

<h2><a class="toc-backref" id="引言-无类型实参" href="#引言-无类型实参">无类型实参</a></h2><p>无类型的宏实参将在语义检查前传给宏。这表示传给宏的语法树 Nim 尚不需要理解， 唯一的限制是它必须是可解析的。通常，宏不检查实参，而以某种方式在转换结果中使用它。 编译器会检查宏展开的结果，所以除了奇怪的错误消息之外，不会发生任何坏事。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 实参的缺点是其对重载解析不利。</p>
<p>无类型实参的优点是语法树可预知，也比 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 简单。</p>

<h2><a class="toc-backref" id="引言-类型化实参" href="#引言-类型化实参">类型化实参</a></h2><p>对于类型化实参，语义检查器会在将其传给宏之前进行语义检查与变换。 这里标识符节点解析成符号，树中的隐式类型转换被看作调用，模板被展开， 最重要的是节点有类型信息。类型化实参的实参列表可有 <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 类型。 但是其他所有类型，如 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt> 及 <tt class="docutils literal"><span class="pre"><span class="Identifier">MyObjectType</span></span></tt> 也是 类型化实参，它们作为一个语法树传递给宏。</p>

<h2><a class="toc-backref" id="引言-静态实参" href="#引言-静态实参">静态实参</a></h2><p>静态实参是一种将值作为值而不是作为语法树节点传递给宏的方法。 如对于表达式 <tt class="docutils literal"><span class="pre"><span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 中的 <tt class="docutils literal"><span class="pre"><span class="Keyword">macro</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span></span></tt>， <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 需要是一个整型常量，但在宏体中 <tt class="docutils literal"><span class="pre"><span class="Identifier">arg</span></span></tt> 就像一个普通的 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 类型参数。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">myMacro</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Keyword">static</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">arg</span> <span class="Comment"># just an int (7), not `NimNode`</span>

<span class="Identifier">myMacro</span><span class="Punctuation">(</span><span class="DecNumber">1</span> <span class="Operator">+</span> <span class="DecNumber">2</span> <span class="Operator">*</span> <span class="DecNumber">3</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="引言-代码块作为实参" href="#引言-代码块作为实参">代码块作为实参</a></h2><p>可在带有缩进的单独代码块中传递调用表达式的最后一个参数。 例如，以下代码示例是调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> 的一个有效(但不推荐)的方式:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hello &quot;</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Wor&quot;</span>
  <span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;ld!&quot;</span>
  <span class="Identifier">a</span> <span class="Operator">&amp;</span> <span class="Identifier">b</span></pre></p>
<p>对于宏来说，这种调用方式非常有用; 可用这种表示法将任意复杂的语法树传递给宏。</p>

<h2><a class="toc-backref" id="引言-语法树" href="#引言-语法树">语法树</a></h2><p>为了构建 Nim 语法树，我们需要知道如何用语法树表示 Nim 源码， 以及能被 Nim 编译器理解的树看起来是什么样子的。Nim 语法树的节点记录在 <a class="reference external" href="macros.html">macros</a> 模块中。但一种更具交互性的探索 Nim 语法树的方法 是使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">macros</span><span class="Operator">.</span><span class="Identifier">treeRepr</span></span></tt>，它将语法树转换为多行字符串以在控制台上打印。 它可用于探索实参表达式如何以树形式表示，以及生成语法树的调试打印。 <tt class="docutils literal"><span class="pre"><span class="Identifier">dumpTree</span></span></tt> 是一个预定义的宏，它只是以树表示形式打印其实参，不执行其他任何操作。 树表示的示例:</p>
<p><pre class="listing">
<span class="Identifier">dumpTree</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">mt</span><span class="Punctuation">:</span> <span class="Identifier">MyType</span> <span class="Operator">=</span> <span class="Identifier">MyType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span><span class="FloatNumber">123.456</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span><span class="StringLit">&quot;abcdef&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># output:</span>
<span class="Comment">#   StmtList</span>
<span class="Comment">#     VarSection</span>
<span class="Comment">#       IdentDefs</span>
<span class="Comment">#         Ident &quot;mt&quot;</span>
<span class="Comment">#         Ident &quot;MyType&quot;</span>
<span class="Comment">#         ObjConstr</span>
<span class="Comment">#           Ident &quot;MyType&quot;</span>
<span class="Comment">#           ExprColonExpr</span>
<span class="Comment">#             Ident &quot;a&quot;</span>
<span class="Comment">#             FloatLit 123.456</span>
<span class="Comment">#           ExprColonExpr</span>
<span class="Comment">#             Ident &quot;b&quot;</span>
<span class="Comment">#             StrLit &quot;abcdef&quot;</span></pre></p>

<h2><a class="toc-backref" id="引言-自定义语义检查" href="#引言-自定义语义检查">自定义语义检查</a></h2><p>宏对其实参做的第一件事应是检查其形式是否正确。不是每种错误输入的类型都需要在这里捕获， 但是任何可能在宏评估期间导致崩溃的东西都应被捕获并产生一个直观的错误消息。 <tt class="docutils literal"><span class="pre"><span class="Identifier">macros</span><span class="Operator">.</span><span class="Identifier">expectKind</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">macros</span><span class="Operator">.</span><span class="Identifier">expectLen</span></span></tt> 是一个好的开始。如果检查需要更复杂， 可用 <tt class="docutils literal"><span class="pre"><span class="Identifier">macros</span><span class="Operator">.</span><span class="Identifier">error</span></span></tt> proc 创建任意错误消息。</p>
<p><pre class="listing">
<span class="Keyword">macro</span> <span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">expectKind</span> <span class="Identifier">nnkInfix</span></pre></p>

<h2><a class="toc-backref" id="引言-代码生成" href="#引言-代码生成">代码生成</a></h2><p>有两种生成代码的方式。通过用含大量 <tt class="docutils literal"><span class="pre"><span class="Identifier">newTree</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">newLit</span></span></tt> 调用的表达式创建语法树， 或用 <tt class="docutils literal"><span class="pre"><span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span></span></tt> 表达式。第一种选项为语法树生成提供了最佳的低级控制，但第二种选项会简洁很多。 若您选择通过调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">newTree</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">newLit</span></span></tt> 来创建语法树，<tt class="docutils literal"><span class="pre"><span class="Identifier">macros</span><span class="Operator">.</span><span class="Identifier">dumpAstGen</span></span></tt> 宏可帮助您避免冗长。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span></span></tt> 允许您直接编写想要生成的代码。反引号用于将来自 <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt> 符号的代码插入到生成的表达式中。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>
<span class="Keyword">macro</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Punctuation">`</span><span class="Identifier">i</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Identifier">a</span> <span class="Identifier">b</span>
<span class="Identifier">doAssert</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="DecNumber">0</span></pre></p>
<p>可以在任何需要反引号的时候，使用自定义前缀。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>
<span class="Keyword">macro</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">quote</span><span class="Punctuation">(</span><span class="StringLit">&quot;@&quot;</span><span class="Punctuation">)</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Identifier">assert</span> <span class="Operator">@</span><span class="Identifier">i</span> <span class="Operator">==</span> <span class="DecNumber">0</span>

<span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
<span class="Identifier">a</span> <span class="Identifier">b</span></pre></p>
<p>想让注入宏的符号解析成作用域中的左值时需再用反引号括起。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>
<span class="Keyword">macro</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">quote</span><span class="Punctuation">(</span><span class="StringLit">&quot;@&quot;</span><span class="Punctuation">)</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Punctuation">`</span><span class="Operator">@</span><span class="Identifier">i</span><span class="Punctuation">`</span> <span class="Operator">=</span> <span class="DecNumber">0</span>

<span class="Identifier">a</span> <span class="Identifier">b</span>
<span class="Identifier">doAssert</span> <span class="Identifier">b</span> <span class="Operator">==</span> <span class="DecNumber">0</span></pre></p>
<p>请确保只将 <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt> 类型的符号注入到生成的语法树中。您可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">newLit</span></span></tt> 将任意值转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">NimNode</span></span></tt> 类型的表达式树，以便安全地注入到树中。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">type</span>
  <span class="Identifier">MyType</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">string</span>

<span class="Keyword">macro</span> <span class="Identifier">myMacro</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">mt</span><span class="Punctuation">:</span> <span class="Identifier">MyType</span> <span class="Operator">=</span> <span class="Identifier">MyType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span><span class="FloatNumber">123.456</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span><span class="StringLit">&quot;abcdef&quot;</span><span class="Punctuation">)</span>
  
  <span class="Comment"># ...</span>
  
  <span class="Keyword">let</span> <span class="Identifier">mtLit</span> <span class="Operator">=</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">mt</span><span class="Punctuation">)</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Punctuation">`</span><span class="Identifier">arg</span><span class="Punctuation">`</span>
    <span class="Identifier">echo</span> <span class="Punctuation">`</span><span class="Identifier">mtLit</span><span class="Punctuation">`</span>

<span class="Identifier">myMacro</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span></pre></p>
<p>调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">myMacro</span></span></tt> 将生成以下代码:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hallo&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">MyType</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="FloatNumber">123.456'f64</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="StringLit">&quot;abcdef&quot;</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="引言-构建你的第一个宏" href="#引言-构建你的第一个宏">构建你的第一个宏</a></h2><p>作为编写宏的起点，我们现在将展示如何实现前面提到的 <tt class="docutils literal"><span class="pre"><span class="Identifier">myAssert</span></span></tt> 宏。 首先要做的是构建一个使用宏的简单示例，接着打印实参。由此，可了解到正确的 实参该为什么样子。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">treeRepr</span>

<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">2</span>

<span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
Infix
  Ident &quot;!=&quot;
  Ident &quot;a&quot;
  Ident &quot;b&quot;</pre></p>
<p>从输出中可以看出，参数是一个中缀运算符(节点类型为 &quot;Infix&quot;)， 并且有两个位于索引 1 和 2 的操作数。有了这些信息，就可编写真正的宏了。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">macros</span>

<span class="Keyword">macro</span> <span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># all node kind identifiers are prefixed with &quot;nnk&quot;</span>
  <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">expectKind</span> <span class="Identifier">nnkInfix</span>
  <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">expectLen</span> <span class="DecNumber">3</span>
  <span class="Comment"># operator as string literal</span>
  <span class="Keyword">let</span> <span class="Identifier">op</span>  <span class="Operator">=</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="StringLit">&quot; &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">arg</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">repr</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; &quot;</span><span class="Punctuation">)</span>
  <span class="Keyword">let</span> <span class="Identifier">lhs</span> <span class="Operator">=</span> <span class="Identifier">arg</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span>
  <span class="Keyword">let</span> <span class="Identifier">rhs</span> <span class="Operator">=</span> <span class="Identifier">arg</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span>
  
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">quote</span> <span class="Keyword">do</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Punctuation">`</span><span class="Identifier">arg</span><span class="Punctuation">`</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">AssertionDefect</span><span class="Punctuation">,</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Identifier">lhs</span><span class="Punctuation">`</span> <span class="Operator">&amp;</span> <span class="Punctuation">`</span><span class="Identifier">op</span><span class="Punctuation">`</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Punctuation">`</span><span class="Identifier">rhs</span><span class="Punctuation">`</span><span class="Punctuation">)</span>

<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">2</span>

<span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
<span class="Identifier">myAssert</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span></pre></p>
<p>这是将生成的代码。要调试宏实际生成的内容，可以在宏的最后一行使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">repr</span></span></tt> 语句。 它也是用于获取此输出的语句。</p>
<p><pre class="listing">
<span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">!=</span> <span class="Identifier">b</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">AssertionDefect</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">a</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot; != &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">b</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="引言-能力越大，责任越大" href="#引言-能力越大，责任越大">能力越大，责任越大</a></h2><p>宏非常强大。一个好的建议是尽可能少地使用它们，但在必要时尽可能多地使用它们。 宏可以改变表达式的语义，但这对不知道宏做什么的人难以理解来说。因此，当宏非必要 且可以使用模板和泛型实现相同逻辑时，最好不要用宏。而用宏处理某事时，宏最好有 一个写得很好的文档。对所有声称自己的代码可以不言自明的人来说: 当涉及宏时， 实现对于文档来说是不够的。</p>

<h2><a class="toc-backref" id="引言-限制" href="#引言-限制">限制</a></h2><p>由于宏是在 NimVM 的编译器中评估的，因此宏具有 NimVM 的所有限制。 它们必须在纯 Nim 代码中实现。宏可以在 shell 上启动外部进程，但不能调用 C 函数， 除了那些被编译器内置的。</p>

<h1><a class="toc-backref" id="更多示例" href="#更多示例">更多示例</a></h1><p>本教程只讲解了宏系统的基础知识。下面一些宏可以启发你用宏都能做什么。</p>

<h2><a class="toc-backref" id="更多示例-strformat" href="#更多示例-strformat">Strformat</a></h2><p>Nim 标准库中，<tt class="docutils literal"><span class="pre"><span class="Identifier">strformat</span></span></tt> 库提供了一个在编译时解析字符串文字的宏。通常不建议 像这样在宏中解析字符串。解析出来的 AST 不能有类型信息，且在 VM 上实现的解析一般 不会很快。在 AST 节点上工作几乎总是推荐的方式。但是对于一个比 <tt class="docutils literal"><span class="pre"><span class="Identifier">assert</span></span></tt> 宏稍微 复杂的宏的实际用例来说，<tt class="docutils literal"><span class="pre"><span class="Identifier">strformat</span></span></tt> 仍是一个很好的例子。</p>
<p><a class="reference external" href="https://github.com/nim-lang/Nim/blob/5845716df8c96157a047c2bd6bcdd795a7a2b9b1/lib/pure/strformat.nim#L280">Strformat</a></p>

<h2><a class="toc-backref" id="更多示例-ast-pattern-matching" href="#更多示例-ast-pattern-matching">Ast Pattern Matching</a></h2><p>Ast Pattern Matching 是一个宏库，可帮助编写复杂的宏。 这可看作是如何使用新语义重新利用 Nim 语法树的一个很好的例子。</p>
<p><a class="reference external" href="https://github.com/krux02/ast-pattern-matching">Ast Pattern Matching</a></p>

<h2><a class="toc-backref" id="更多示例-opengl-沙盒" href="#更多示例-opengl-沙盒">OpenGL 沙盒</a></h2><p>此项目有一个完全用宏编写的 Nim 到 GLSL 的编译器。它通过递归扫描所有使用的函数符号来编译它们， 以便可以在 GPU 上执行交叉库函数。</p>
<p><a class="reference external" href="https://github.com/krux02/opengl-sandbox">OpenGL 沙盒</a> </p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2022-10-28 03:57:52 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
