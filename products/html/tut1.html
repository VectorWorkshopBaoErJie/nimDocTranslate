<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim 教程 (第 I 部分)</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<!-- JS -->
<script type="text/javascript" src="dochack.js"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim 教程 (第 I 部分)</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">🌗 Match OS</option>
        <option value="dark">🌑 Dark</option>
        <option value="light">🌕 Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" onkeyup="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="引言_toc" href="#引言">引言</a></li>
<li><a class="reference" id="第一个程序_toc" href="#第一个程序">第一个程序</a></li>
<li><a class="reference" id="词法元素_toc" href="#词法元素">词法元素</a></li>
<ul class="simple"><li><a class="reference" id="词法元素-字符串和字符字面量_toc" href="#词法元素-字符串和字符字面量">字符串和字符字面量</a></li>
<li><a class="reference" id="词法元素-注释_toc" href="#词法元素-注释">注释</a></li>
<li><a class="reference" id="词法元素-数字_toc" href="#词法元素-数字">数字</a></li>
</ul><li><a class="reference" id="var-语句_toc" href="#var-语句">var 语句</a></li>
<li><a class="reference" id="常量_toc" href="#常量">常量</a></li>
<li><a class="reference" id="let-语句_toc" href="#let-语句">let 语句</a></li>
<li><a class="reference" id="赋值语句_toc" href="#赋值语句">赋值语句</a></li>
<li><a class="reference" id="控制流语句_toc" href="#控制流语句">控制流语句</a></li>
<ul class="simple"><li><a class="reference" id="控制流语句-if-语句_toc" href="#控制流语句-if-语句">If 语句</a></li>
<li><a class="reference" id="控制流语句-case-语句_toc" href="#控制流语句-case-语句">Case 语句</a></li>
<li><a class="reference" id="控制流语句-while-语句_toc" href="#控制流语句-while-语句">While 语句</a></li>
<li><a class="reference" id="控制流语句-for-语句_toc" href="#控制流语句-for-语句">For 语句</a></li>
<li><a class="reference" id="控制流语句-作用域和-block-语句_toc" href="#控制流语句-作用域和-block-语句">作用域和 block 语句</a></li>
<li><a class="reference" id="控制流语句-break-语句_toc" href="#控制流语句-break-语句">Break 语句</a></li>
<li><a class="reference" id="控制流语句-continue-语句_toc" href="#控制流语句-continue-语句">Continue 语句</a></li>
<li><a class="reference" id="控制流语句-when-语句_toc" href="#控制流语句-when-语句">When 语句</a></li>
</ul><li><a class="reference" id="语句和缩进_toc" href="#语句和缩进">语句和缩进</a></li>
<li><a class="reference" id="过程_toc" href="#过程">过程</a></li>
<ul class="simple"><li><a class="reference" id="过程-result-变量_toc" href="#过程-result-变量">Result 变量</a></li>
<li><a class="reference" id="过程-参数_toc" href="#过程-参数">参数</a></li>
<li><a class="reference" id="过程-discard-语句_toc" href="#过程-discard-语句">Discard 语句</a></li>
<li><a class="reference" id="过程-具名参数_toc" href="#过程-具名参数">具名参数</a></li>
<li><a class="reference" id="过程-默认值_toc" href="#过程-默认值">默认值</a></li>
<li><a class="reference" id="过程-过程重载_toc" href="#过程-过程重载">过程重载</a></li>
<li><a class="reference" id="过程-运算符_toc" href="#过程-运算符">运算符</a></li>
<li><a class="reference" id="过程-前置声明_toc" href="#过程-前置声明">前置声明</a></li>
<li><a class="reference" id="过程-funcs-和-方法_toc" href="#过程-funcs-和-方法">Funcs 和 方法</a></li>
</ul><li><a class="reference" id="迭代器_toc" href="#迭代器">迭代器</a></li>
<li><a class="reference" id="基本类型_toc" href="#基本类型">基本类型</a></li>
<ul class="simple"><li><a class="reference" id="基本类型-布尔_toc" href="#基本类型-布尔">布尔</a></li>
<li><a class="reference" id="基本类型-字符_toc" href="#基本类型-字符">字符</a></li>
<li><a class="reference" id="基本类型-字符串_toc" href="#基本类型-字符串">字符串</a></li>
<li><a class="reference" id="基本类型-整数_toc" href="#基本类型-整数">整数</a></li>
<li><a class="reference" id="基本类型-浮点数_toc" href="#基本类型-浮点数">浮点数</a></li>
<li><a class="reference" id="基本类型-类型转换_toc" href="#基本类型-类型转换">类型转换</a></li>
</ul><li><a class="reference" id="内部类型表示_toc" href="#内部类型表示">内部类型表示</a></li>
<li><a class="reference" id="高阶类型_toc" href="#高阶类型">高阶类型</a></li>
<ul class="simple"><li><a class="reference" id="高阶类型-枚举_toc" href="#高阶类型-枚举">枚举</a></li>
<li><a class="reference" id="高阶类型-序数类型_toc" href="#高阶类型-序数类型">序数类型</a></li>
<li><a class="reference" id="高阶类型-子范围_toc" href="#高阶类型-子范围">子范围</a></li>
<li><a class="reference" id="高阶类型-集合_toc" href="#高阶类型-集合">集合</a></li>
<ul class="simple"><li><a class="reference" id="集合-位域_toc" href="#集合-位域">位域</a></li>
</ul><li><a class="reference" id="高阶类型-数组_toc" href="#高阶类型-数组">数组</a></li>
<li><a class="reference" id="高阶类型-序列_toc" href="#高阶类型-序列">序列</a></li>
<li><a class="reference" id="高阶类型-开放数组_toc" href="#高阶类型-开放数组">开放数组</a></li>
<li><a class="reference" id="高阶类型-可变参数_toc" href="#高阶类型-可变参数">可变参数</a></li>
<li><a class="reference" id="高阶类型-切片_toc" href="#高阶类型-切片">切片</a></li>
<li><a class="reference" id="高阶类型-对象_toc" href="#高阶类型-对象">对象</a></li>
<li><a class="reference" id="高阶类型-元组_toc" href="#高阶类型-元组">元组</a></li>
<li><a class="reference" id="高阶类型-引用和指针类型_toc" href="#高阶类型-引用和指针类型">引用和指针类型</a></li>
<li><a class="reference" id="高阶类型-程序类型_toc" href="#高阶类型-程序类型">程序类型</a></li>
<li><a class="reference" id="高阶类型-distinct-类型_toc" href="#高阶类型-distinct-类型">Distinct 类型</a></li>
</ul><li><a class="reference" id="模块_toc" href="#模块">模块</a></li>
<ul class="simple"><li><a class="reference" id="模块-排除符号_toc" href="#模块-排除符号">排除符号</a></li>
<li><a class="reference" id="模块-from-语句_toc" href="#模块-from-语句">From 语句</a></li>
<li><a class="reference" id="模块-include-语句_toc" href="#模块-include-语句">Include 语句</a></li>
</ul><li><a class="reference" id="第二部分_toc" href="#第二部分">第二部分</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td>|nimversion|</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="引言" href="#引言">引言</a></h1><blockquote class="markdown-quote"><p>&quot;Der Mensch ist doch ein Augentier -- Schöne Dinge wünsch' ich mir.&quot;</p></blockquote>
<p>本文是 <em>Nim</em> 编程语言教程。</p>
<p>本教程假定你熟悉基本的编程概念，如变量、类型及语句。</p>
<p>此处还有其他几份资料可供以学习 Nim:</p>
<ul class="simple"><li><a class="reference external" href="https://narimiran.github.io/nim-basics/">Nim 基础教程</a> - 对上述概念的 简单介绍</li>
<li><a class="reference external" href="https://learnxinyminutes.com/docs/nim/">五分钟速通 Nim</a> - 对 Nim 的五分钟 快速介绍</li>
<li><a class="reference external" href="manual.html">Nim 手册</a> - 更多语言高级特性的例子</li>
</ul>
<p>此教程中的所有代码样例，包括其余 Nim 文档中的，均遵循<a class="reference external" href="nep1.html">Nim 代码风格指南</a>。</p>

<h1><a class="toc-backref" id="第一个程序" href="#第一个程序">第一个程序</a></h1><p>我们将以一个修改过的 &quot;hello world&quot; 程序开启旅途。</p>
<p><pre class="listing">
<span class="Comment"># This is a comment</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>将代码保存在文件&quot;greetings.nim&quot;中。现在编译运行它:<pre>nim compile --run greetings.nim</pre>
</p>
<p>通过 <tt class="docutils literal"><span class="pre">--run</span></tt> <a class="reference external" href="nimc.html#compiler-usage-commandminusline-switches">开关</a>，Nim 将在编译完成后自动执行该文件。你可以使用在文件名后面追加的方式来为程序提供命令行参数:<pre>nim compile --run greetings.nim arg1 arg2</pre>
</p>
<p>常用指令和开关有简写，所以你也可以用:<pre>nim c -r greetings.nim</pre>
</p>
<p>这是 <strong>调试版本</strong>。 为编译成发行版需用:<pre>nim c -d:release greetings.nim</pre>
</p>
<p>默认情况下，为了让你调试时更轻松，Nim 编译器会产生大量的运行时检查。 通过 <tt class="docutils literal"><span class="pre">-d:release</span></tt>，一些检查会被<a class="reference external" href=" nimc.html#compiler-usage-compileminustime-symbols">关闭，优化将被打开</a>。</p>
<p>为了基准测试或能投产的代码，请使用 <tt class="docutils literal"><span class="pre">-d:release</span></tt> 开关。 为了与像 C 一样的不安全语言做性能上的比较，请使用 <tt class="docutils literal"><span class="pre">-d:danger</span></tt> 开关来获得有意义， 可比较的结果。否则，Nim 可能会因为一些在 C 中 <strong>甚至不可行的</strong> 检查而显得低能。</p>
<p>尽管程序做了什么应该已经十分明显了，但我还是要解释这种语法: 没有缩进的语句将在程序开始的时候被 执行。缩进是 Nim 用于给语句分组的一种方式。缩进只能由空格符来完成，制表符是不被允许的。</p>
<p>字符串字面量会被双引号括起来。<tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 语句声明了一个名称为 <tt class="docutils literal"><span class="pre"><span class="Identifier">name</span></span></tt>，类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt>， 值为 <a class="reference external" href="syncio.html#readLine,File">readLine</a> 过程的返回值的变量。由于编译器知道 <a class="reference external" href="syncio.html#readLine,File">readLine</a>返回一个字符串，你可以在声明中省略类型 (这被称作 <span id="local-type-inference_1">local type inference</span>)。所以下面这样也能正常工作:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span></pre></p>
<p>注意这基本是 Nim 中唯一存在的类型推断的形式: 这是简洁和可读性之间的一个很好的折中。</p>
<p>&quot;hello world&quot; 程序包含一些编译器已知的标识符: <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt>, <a class="reference external" href="syncio.html#readLine,File">readLine</a> 等。 这些内置的标识符声明在被其他模块隐式导入的 <a class="reference external" href="system.html">system</a> 模块中。</p>

<h1><a class="toc-backref" id="词法元素" href="#词法元素">词法元素</a></h1><p>让我们来仔细地看一下 Nim 的词法元素: 就像其他编程语言, Nim 由 (字符串) 字词， 标识符，关键字，注释，运算符和其他标点符号构成。</p>

<h2><a class="toc-backref" id="词法元素-字符串和字符字面量" href="#词法元素-字符串和字符字面量">字符串和字符字面量</a></h2><p>字符串字面量被双引号括起来; 字符在单引号中。特殊字符可被 <tt class="docutils literal"><span class="pre">\</span></tt> 转义: <tt class="docutils literal"><span class="pre">\n</span></tt> 表示新的一行, <tt class="docutils literal"><span class="pre">\t</span></tt> 表示制表符，等等。同样，也有<em>原始</em>字符串字面量:</p>
<p><pre class="listing">
<span class="RawData">r&quot;C:\program files\nim&quot;</span></pre></p>
<p>在原始字面量中，反斜杠不是转义字符。</p>
<p>第三种，也是最后一种书写字符串字面量的方法是通过<em>长字符串字面量</em>。 它们通过三对双引号写出: <tt class="docutils literal"><span class="pre"><span class="LongStringLit">&quot;&quot;&quot; ... &quot;&quot;&quot;</span></span></tt>; 它们可以跨越多行且 <tt class="docutils literal"><span class="pre">\</span></tt> 也不是 转义字符。例如，它们在嵌入 HTML 代码的时候非常有用。</p>

<h2><a class="toc-backref" id="词法元素-注释" href="#词法元素-注释">注释</a></h2><p>注释以哈希字符 <tt class="docutils literal"><span class="pre"><span class="Comment">#</span></span></tt> 开头，出现在除字符串或字符字面量以外的任何地方。 文档注释以 <tt class="docutils literal"><span class="pre"><span class="Comment">##</span></span></tt> 开头:</p>
<p><pre class="listing">
<span class="Comment"># A comment.</span>

<span class="Keyword">var</span> <span class="Identifier">myVariable</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment">## a documentation comment</span></pre></p>
<p>文档注释是 tokens; 因为它们属于语法树，所以它们只被允许出现在输入文件的特定地方! 此功能支持更简单的文档生成器。</p>
<p>多行注释以 <tt class="docutils literal"><span class="pre"><span class="LongComment">#[</span></span></tt> 开头并以 <tt class="docutils literal"><span class="pre"><span class="Comment">#]</span></span></tt> 结尾。多行注释也允许嵌套。</p>
<p><pre class="listing">
<span class="LongComment">#[
You can have any Nim code text commented
out inside this with no indentation restrictions.
      yes(&quot;May I ask a pointless question?&quot;)
  #[
     Note: these can be nested!!
  ]#
]#</span></pre></p>

<h2><a class="toc-backref" id="词法元素-数字" href="#词法元素-数字">数字</a></h2><p>数字字面量的书写和其他大多数语言一样。下划线，作为一种特殊的转折，被允许用以提高 可读性: <tt class="docutils literal"><span class="pre"><span class="DecNumber">1_000_000</span></span></tt> (一百万)。包含小数点的 (或 'e' 或 'E') 是浮点数字面量: <tt class="docutils literal"><span class="pre"><span class="FloatNumber">1.0e9</span></span></tt> (一亿)。十六进制的字面量以 <tt class="docutils literal"><span class="pre"><span class="HexNumber">0x</span></span></tt> 开头，二进制的字面量以 <tt class="docutils literal"><span class="pre"><span class="BinNumber">0b</span></span></tt> 开头， 而八进制字面量以 <tt class="docutils literal"><span class="pre"><span class="OctNumber">0o</span></span></tt> 开头。只以一个零开头不会产生一个八进制数。</p>

<h1><a class="toc-backref" id="var-语句" href="#var-语句">var 语句</a></h1><p>var 语句声明一个新的局部或全局变量:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># declares x and y to have the type `int`</span></pre></p>
<p>可以在关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 后用缩进列出一整个部分的变量:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Comment"># a comment can occur here too</span>
  <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>

<h1><a class="toc-backref" id="常量" href="#常量">常量</a></h1><p>常量是绑定了值的符号。常量的值不能改变。编译器必须能够在编译时计算常量表达式的值:</p>
<p><pre class="listing">
<span class="Keyword">const</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># the constant x contains the string &quot;abc&quot;</span></pre></p>
<p>可以在关键字 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 后用缩进列出一整个部分的常量:</p>
<p><pre class="listing">
<span class="Keyword">const</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># a comment can occur here too</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">2</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="DecNumber">5</span> <span class="Comment"># computations are possible</span></pre></p>

<h1><a class="toc-backref" id="let-语句" href="#let-语句">let 语句</a></h1><p><tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 语句像 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 语句一样发挥作用，但其声明的符号是<em>一次性赋值</em>的变量: 初始化后它们的值不能被改变:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># introduces a new variable `x` and binds a value to it</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># Illegal: assignment to `x`</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 之间的不同: <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> 引入了一个不能被重新赋值的变量， <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 意味着&quot;强制编译时评估并把它放到数据段&quot;:</p>
<p><pre class="listing">
<span class="Keyword">const</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># Error: constant expression expected</span></pre></p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">input</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>   <span class="Comment"># works</span></pre></p>

<h1><a class="toc-backref" id="赋值语句" href="#赋值语句">赋值语句</a></h1><p>赋值语句将一个新值赋到一个变量，或更一般的，分配到一个存储位置:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span> <span class="Comment"># introduces a new variable `x` and assigns a value to it</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>     <span class="Comment"># assigns a new value to `x`</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> 是<em>赋值运算符</em>。赋值运算符是可以被重载的。你可以通过 单个赋值运算符来声明多个变量，而所有变量将拥有同样的值。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">3</span>  <span class="Comment"># assigns 3 to the variables `x` and `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># outputs &quot;x 3&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># outputs &quot;y 3&quot;</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">42</span>        <span class="Comment"># changes `x` to 42 without changing `y`</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;x &quot;</span><span class="Punctuation">,</span> <span class="Identifier">x</span>  <span class="Comment"># outputs &quot;x 42&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;y &quot;</span><span class="Punctuation">,</span> <span class="Identifier">y</span>  <span class="Comment"># outputs &quot;y 3&quot;</span></pre></p>

<h1><a class="toc-backref" id="控制流语句" href="#控制流语句">控制流语句</a></h1><p>欢迎程序由 3 条依次执行的语句组成。 只有最原始的程序才能解决这个问题: 分支和循环也是需要的。</p>

<h2><a class="toc-backref" id="控制流语句-if-语句" href="#控制流语句-if-语句">If 语句</a></h2><p>if 语句是在控制流创建分支的一种方式:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>这里可以有零个或更多 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 分支，而 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 分支是可选的。 <tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 关键字比 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span> <span class="Keyword">if</span></span></tt> 短，且有助于避免过度缩进。 (<tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt> 是空字符串。它不包含字符。)</p>

<h2><a class="toc-backref" id="控制流语句-case-语句" href="#控制流语句-case-语句">Case 语句</a></h2><p>另一种创建分支的方式是通过 case 语句提供的。一个 case 语句运行多个分支:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">name</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Poor soul, you lost your name?&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;name&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Very funny, your name is name.&quot;</span>
<span class="Keyword">of</span> <span class="StringLit">&quot;Dave&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Frank&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Cool name!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Hi, &quot;</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="StringLit">&quot;!&quot;</span></pre></p>
<p>可以看出，对于 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 分支，可以用逗号分隔值。</p>
<p>case 语句可以处理整数，其他序数类型，以及字符串。 (什么是序数类型马上解释。) 整数和其他序数类型的值区间也是可以的:</p>
<p><pre class="listing">
<span class="Comment"># this statement will be explained later:</span>
<span class="Keyword">from</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;A number please: &quot;</span>
<span class="Keyword">let</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span></pre></p>
<p>然而，上面的代码<strong>不能编译</strong>: 因为你需要考虑 <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> 可能取到的所有值，但代码只处理了 <tt class="docutils literal"><span class="pre"><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">8</span></span></tt>。 因为列出所有值并不十分现实(尽管多亏了范围表达式这有可能实现)，我们通过告诉编译器所有其他值 不做任何事来处理这个情况:</p>
<p><pre class="listing">
<span class="Operator">...</span>
<span class="Keyword">case</span> <span class="Identifier">n</span>
<span class="Keyword">of</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="FloatNumber">4.</span><span class="Operator">.</span><span class="DecNumber">7</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is in the set: {0, 1, 2, 4, 5, 6, 7}&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">8</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;The number is 3 or 8&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Keyword">discard</span></pre></p>
<p>空<a class="reference internal" href="#过程-discard-语句">discard 语句</a>是一个<em>不做任何事</em>的语句。编译器知道含有 else 部分的 case 表达式 不会失败因此错误消失了。注意，处理所有字符串值是不可能的: 这也是为什么字符串的 case 语句 总是需要一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt> 分支。</p>
<p>通常，case 语句对于处理范围类型和枚举非常有用，因为编译器会检查你是否考虑了所有可能的值。</p>

<h2><a class="toc-backref" id="控制流语句-while-语句" href="#控制流语句-while-语句">While 语句</a></h2><p>while 语句是一个简单的循环结构:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;What's your name? &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
<span class="Keyword">while</span> <span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Please tell me your name: &quot;</span>
  <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span> <span class="Comment"># no `var`, because we do not declare a new variable here</span></pre></p>
<p>在这个例子中，只要用户什么都不输入(只敲回车键), while 循环就会一直询问用户的名字。</p>

<h2><a class="toc-backref" id="控制流语句-for-语句" href="#控制流语句-for-语句">For 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 语句是一个循环遍历<em>迭代器</em>提供元素的结构。该示例使用内置的 <a class="reference external" href=" system.html#countup.i,T,T,Positive">countup</a> 迭代器:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre></p>
<p>变量 <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> 由 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 循环隐式声明且类型为 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>，因为这就是 <a class="reference external" href=" system.html#countup.i,T,T,Positive">countup</a> 返回的类型。<tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> 遍历 1, 2, .., 10。 每个值都被 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt>-ed. 这段代码等效于:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to 10: &quot;</span>
<span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
<span class="Keyword">while</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
  <span class="Identifier">inc</span> <span class="Identifier">i</span> <span class="Comment"># increment i by 1</span>
<span class="Comment"># --&gt; Outputs 1 2 3 4 5 6 7 8 9 10 on different lines</span></pre></p>
<p>因为计数在程序中使用的很频繁，Nim 也提供了 <a class="reference external" href=" system.html#...i,T,T">..</a> 迭代器来做相同的事情:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre></p>
<p>实现倒计数也容易(但不太需要):</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Counting down from 10 to 1: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countdown</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span>
<span class="Comment"># --&gt; Outputs 10 9 8 7 6 5 4 3 2 1 on different lines</span></pre></p>
<p>从零开始的计数有两种简写 <tt class="docutils literal"><span class="pre"><span class="Operator">..&lt;</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span></span></tt> (<a class="reference external" href="system.html#^.t%2Cint">后向索引运算符</a>)，来简化数到 比最高下标少一:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="DecNumber">10</span><span class="Punctuation">:</span>
  <span class="Operator">...</span>  <span class="Comment"># the same as 0 .. 9</span></pre></p>
<p>或者</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
  <span class="Operator">...</span></pre></p>
<p>或者</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">s</span> <span class="Operator">=</span> <span class="StringLit">&quot;some string&quot;</span>
<span class="Keyword">for</span> <span class="Identifier">idx</span><span class="Punctuation">,</span> <span class="Identifier">c</span> <span class="Keyword">in</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Operator">...</span> <span class="Comment"># ^1 is the last element, ^2 would be one before it, and so on</span></pre></p>
<p>其他有助力于集合(比如数组和切片)的迭代器是</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">items</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">mitems</span></span></tt>， 他们分别提供不可变和可变元素，而</li>
<li><p><tt class="docutils literal"><span class="pre"><span class="Identifier">pairs</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">mpairs</span></span></tt> 提供了配对的元素和它们下标(分别为不可变和可变)</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">index</span><span class="Punctuation">,</span> <span class="Identifier">item</span> <span class="Keyword">in</span> <span class="Punctuation">[</span><span class="StringLit">&quot;a&quot;</span><span class="Punctuation">,</span><span class="StringLit">&quot;b&quot;</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Identifier">pairs</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">item</span><span class="Punctuation">,</span> <span class="StringLit">&quot; at index &quot;</span><span class="Punctuation">,</span> <span class="Identifier">index</span>
<span class="Comment"># =&gt; a at index 0</span>
<span class="Comment"># =&gt; b at index 1</span></pre></p>
</li>
</ul>

<h2><a class="toc-backref" id="控制流语句-作用域和-block-语句" href="#控制流语句-作用域和-block-语句">作用域和 block 语句</a></h2><p>控制流语句有一个未显露的特性: 他们打开了一个新的作用域。 这意味着接下来的例子中，<tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 在循环外不可访问:</p>
<p><pre class="listing">
<span class="Keyword">while</span> <span class="Identifier">false</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># does not work</span></pre></p>
<p>while (for) 语句引入了一个隐式的块。变量只有在它们被声明的块中可见。 <tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> 语句可以显式地打开一个新的块:</p>
<p><pre class="listing">
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;hi&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span> <span class="Comment"># does not work either</span></pre></p>
<p>块的<em>标签</em>(在这个例子中是 <tt class="docutils literal"><span class="pre"><span class="Identifier">myblock</span></span></tt>)是可选的。</p>

<h2><a class="toc-backref" id="控制流语句-break-语句" href="#控制流语句-break-语句">Break 语句</a></h2><p>使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">break</span></span></tt> 语句可以提早离开一个块。break 语句可以离开 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 或一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">block</span></span></tt> 语句。 除非给出块的标签，否则它会离开最里面的结构:</p>
<p><pre class="listing">
<span class="Keyword">block</span> <span class="Identifier">myblock</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Comment"># leaves the loop, but not the block</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;outside the block&quot;</span>

<span class="Keyword">block</span> <span class="Identifier">myblock2</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;entering block&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;looping&quot;</span>
    <span class="Keyword">break</span> <span class="Identifier">myblock2</span> <span class="Comment"># leaves the block (and the loop)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;still in block&quot;</span> <span class="Comment"># it won't be printed</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;outside the block&quot;</span></pre></p>

<h2><a class="toc-backref" id="控制流语句-continue-语句" href="#控制流语句-continue-语句">Continue 语句</a></h2><p>类似其他许多编程语言，一个 <tt class="docutils literal"><span class="pre"><span class="Keyword">continue</span></span></tt> 语句会立即开启下一轮迭代:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">1</span> <span class="Operator">..</span> <span class="DecNumber">5</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;=</span> <span class="DecNumber">3</span><span class="Punctuation">:</span> <span class="Keyword">continue</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span> <span class="Comment"># will only print 4 and 5</span></pre></p>

<h2><a class="toc-backref" id="控制流语句-when-语句" href="#控制流语句-when-语句">When 语句</a></h2><p>例:</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;windows&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Windows!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;linux&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Linux!&quot;</span>
<span class="Keyword">elif</span> <span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">hostOS</span> <span class="Operator">==</span> <span class="StringLit">&quot;macosx&quot;</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;running on Mac OS X!&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;unknown operating system&quot;</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句几乎和 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句相同，但在以下有所差异:</p>
<ul class="simple"><li>因为每种情况都会被编译器评估，所以其必须是个常量表达式。</li>
<li>分支中的语句不会开启新作用域。</li>
<li>编译器会检查语义并且<em>只</em>为第一个评估为 <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> 的情况生成代码。</li>
</ul>
<p>与 C语言 中的 <tt class="docutils literal"><span class="pre"><span class="Preprocessor">#ifdef</span></span></tt> 相似，<tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句在编写针对特定平台的代码时十分有用。</p>

<h1><a class="toc-backref" id="语句和缩进" href="#语句和缩进">语句和缩进</a></h1><p>至此我们介绍了基本的控制流语句，现在让我们回到 Nim 的缩进规则。</p>
<p>在 Nim 中，<em>简单语句</em>与<em>复杂语句</em>有别。<em>简单语句</em>不能包含其他语句: 赋值、过程调用或 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句都是简单语句。<em>复杂的语句</em>如 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt> 可以包含其他语句。为避免歧义，复杂语句必须 始终缩进，但单个简单语句不用:</p>
<p><pre class="listing">
<span class="Comment"># no indentation needed for single-assignment statement:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>

<span class="Comment"># indentation needed for nested if statement:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Comment"># indentation needed, because two statements follow the condition:</span>
<span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">false</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">false</span></pre></p>
<p><em>表达式</em>是语句的一部分，通常会产生一个值。if 语句中的条件就是个例子。 表达式可以在某些位置包含缩进以提高可读性:</p>
<p><pre class="listing">
<span class="Keyword">if</span> <span class="Identifier">thisIsaLongCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Keyword">and</span>
    <span class="Identifier">thisIsAnotherLongCondition</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span>
       <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">true</span></pre></p>
<p>根据经验，允许在运算符、左括号和逗号之后表达式内缩进。</p>
<p>凭借括号和分号 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">;</span><span class="Punctuation">)</span></span></tt>，你可使用只允许使用表达式的语句:</p>
<p><pre class="listing">
<span class="Comment"># computes fac(4) at compile time:</span>
<span class="Keyword">const</span> <span class="Identifier">fac4</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">;</span> <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">4</span><span class="Punctuation">:</span> <span class="Identifier">x</span> <span class="Operator">*=</span> <span class="Identifier">i</span><span class="Punctuation">;</span> <span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>

<h1><a class="toc-backref" id="过程" href="#过程">过程</a></h1><p>要在示例中定义像 <a class="reference external" href="system.html#echo,varargs[typed,]">echo</a> 和 <a class="reference external" href="syncio.html#readLine,File">readLine</a> 这样的新命令，需要<em>过程</em>的概念。 你可能习惯在其他语言中将它们称为<em>方法</em>或<em>函数</em>，但 Nim 将 <a class="reference external" href="tut1.html#procedures-funcs-and-methods">区分这些概念</a>。 在 Nim 中，新过程是使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 关键字定义的:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">question</span><span class="Punctuation">,</span> <span class="StringLit">&quot; (y/n)&quot;</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Keyword">case</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Punctuation">)</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Y&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;yes&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Yes&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">true</span>
    <span class="Keyword">of</span> <span class="StringLit">&quot;n&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;N&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;no&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;No&quot;</span><span class="Punctuation">:</span> <span class="Keyword">return</span> <span class="Identifier">false</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;Please be clear: yes or no&quot;</span>

<span class="Keyword">if</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;Should I delete all your important files?&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I'm sorry Dave, I'm afraid I can't do that.&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;I think you know what the problem is just as well as I do.&quot;</span></pre></p>
<p>这个例子展示了一个名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">yes</span></span></tt> 的过程，它询问用户一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt>， 若他们回答 &quot;yes&quot; (或类似的东西)，返回 true，若他们回答 &quot;no&quot; (或类似的东西)，返回 false。 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句将立即离开过程(因此也离开了 while 循环)。 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">question</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></span></tt> 语法表明过程需要一个名为 <tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt> 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt> 类型的参数 并返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 类型的值。<tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 类型是内置的: <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 的唯一有效值是 <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt>。 if 和 while 语句中的条件必须是 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> 类型。</p>
<p>一些术语: 在示例中，<tt class="docutils literal"><span class="pre"><span class="Identifier">question</span></span></tt> 被称为(正式的)<em>参数</em>， <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;Should I...&quot;</span></span></tt> 被称为传递给此参数的<em>实参</em>。</p>

<h2><a class="toc-backref" id="过程-result-变量" href="#过程-result-变量">Result 变量</a></h2><p>有返回值过程有一个隐式声明，即代表返回值的 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 变量。没跟表达式的 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span> <span class="Identifier">result</span></span></tt> 简写。过程结尾退出时如果没有 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句，<tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 值将被自动返回。</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">x</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
      <span class="Keyword">return</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">result</span> <span class="Operator">+</span> <span class="Identifier">i</span>

<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># echoes 0</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment"># echoes 12</span>
<span class="Identifier">echo</span> <span class="Identifier">sumTillNegative</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span> <span class="Punctuation">,</span> <span class="Operator">-</span><span class="DecNumber">1</span> <span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># echoes 7</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 变量已经在函数开头隐式声明，因此，例如，用 'var result' 再次声明会用同名的普通变量遮蔽它。 result 变量也已经使用类型的默认值进行了初始化。注意，引用数据类型在过程开始时将是 &quot;nil&quot;，因此可能需要手动初始化。</p>
<p>不使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句和不使用特殊变量 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 的过程将返回它最后一个表达式的值。 例如这个过程</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">helloWorld</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Hello, World!&quot;</span></pre></p>
<p>返回字符串 &quot;Hello, World&quot;。</p>

<h2><a class="toc-backref" id="过程-参数" href="#过程-参数">参数</a></h2><p>参数在过程中是不可变的。默认情况下，他们的值不可改变，因为这允许编译器更高效地实现参数的传递。 如果在过程中需要一个可变的变量，它应该在过程中以 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 来声明。遮蔽参数名称是可能的，实际上 这是惯用法:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printSeq</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">,</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">nprinted</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">nprinted</span> <span class="Operator">==</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">min</span><span class="Punctuation">(</span><span class="Identifier">nprinted</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">nprinted</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>
<p>如果过程需要修改调用者的参数，可使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 参数:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">res</span><span class="Punctuation">,</span> <span class="Identifier">remainder</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">div</span> <span class="Identifier">b</span>        <span class="Comment"># integer division</span>
  <span class="Identifier">remainder</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Keyword">mod</span> <span class="Identifier">b</span>  <span class="Comment"># integer modulo operation</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
<span class="Identifier">divmod</span><span class="Punctuation">(</span><span class="DecNumber">8</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Comment"># modifies x and y</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>
<span class="Identifier">echo</span> <span class="Identifier">y</span></pre></p>
<p>在这个例子中，<tt class="docutils literal"><span class="pre"><span class="Identifier">res</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">remainder</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span> <span class="Identifier">parameters</span></span></tt>。 Var 参数可以被过程修改且该修改调用者可知。注意上面的例子最好用元组作为返回值而不是使用 var 参数。</p>

<h2><a class="toc-backref" id="过程-discard-语句" href="#过程-discard-语句">Discard 语句</a></h2><p>调用仅需要其副作用而非返回值并忽略其返回值的过程，<strong>必须</strong>使用<tt class="docutils literal"><span class="pre"><span class="Keyword">discard</span></span></tt>语句。 Nim 不允许默默地丢弃返回值:</p>
<p><pre class="listing">
<span class="Keyword">discard</span> <span class="Identifier">yes</span><span class="Punctuation">(</span><span class="StringLit">&quot;May I ask a pointless question?&quot;</span><span class="Punctuation">)</span></pre></p>
<p>如果调用的过程 / 迭代器通过 <tt class="docutils literal"><span class="pre"><span class="Identifier">discardable</span></span></tt> 编译指示声明，返回值可以被隐式地忽略:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">discardable</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Identifier">p</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span> <span class="Comment"># now valid</span></pre></p>

<h2><a class="toc-backref" id="过程-具名参数" href="#过程-具名参数">具名参数</a></h2><p>通常一个过程有许多参数，但参数出现的顺序是不清楚的。尤其是在构建一个复杂数据类型时。 因此，传给过程的参数可以具名，由此参数属于哪个形参就清楚了:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">width</span><span class="Punctuation">,</span> <span class="Identifier">height</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">;</span> <span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">;</span>
                  <span class="Identifier">show</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre></p>
<p>注意我们使用具名参数调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt>，参数的顺序不再重要。混合使用具名参数和按顺序的参数 也是可能的，但可读性很差。</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span>
                     <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">,</span> <span class="Identifier">true</span><span class="Punctuation">)</span></pre></p>
<p>编译器检查每个形参是否只接收一个参数。</p>

<h2><a class="toc-backref" id="过程-默认值" href="#过程-默认值">默认值</a></h2><p>为了使 <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt> 过程更易用，应提供 <tt class="docutils literal"><span class="pre"><span class="Identifier">default</span> <span class="Identifier">values</span></span></tt>; 如果调用者未指定这些参数，则用这些值作参数:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">500</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">700</span><span class="Punctuation">,</span>
                  <span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span><span class="Punctuation">,</span>
                  <span class="Identifier">show</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Window</span> <span class="Operator">=</span>
   <span class="Operator">...</span>

<span class="Keyword">var</span> <span class="Identifier">w</span> <span class="Operator">=</span> <span class="Identifier">createWindow</span><span class="Punctuation">(</span><span class="Identifier">title</span> <span class="Operator">=</span> <span class="StringLit">&quot;My Application&quot;</span><span class="Punctuation">,</span> <span class="Identifier">height</span> <span class="Operator">=</span> <span class="DecNumber">600</span><span class="Punctuation">,</span> <span class="Identifier">width</span> <span class="Operator">=</span> <span class="DecNumber">800</span><span class="Punctuation">)</span></pre></p>
<p>现在调用 <tt class="docutils literal"><span class="pre"><span class="Identifier">createWindow</span></span></tt> 只需要设置与默认值不同的参数即可。</p>
<p>注意，类型推断适用于具有默认值的参数; 例如，不需要写 <tt class="docutils literal"><span class="pre"><span class="Identifier">title</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;unknown&quot;</span></span></tt>。</p>

<h2><a class="toc-backref" id="过程-过程重载" href="#过程-过程重载">过程重载</a></h2><p>Nim 提供了类似 C++ 的过程重载能力:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="StringLit">&quot;negative&quot;</span>
    <span class="Keyword">elif</span> <span class="Identifier">x</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="StringLit">&quot;positive&quot;</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="StringLit">&quot;zero&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="StringLit">&quot;yep&quot;</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="StringLit">&quot;nope&quot;</span>

<span class="Identifier">assert</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="DecNumber">13</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;positive&quot;</span> <span class="Comment"># calls the toString(x: int) proc</span>
<span class="Identifier">assert</span> <span class="Identifier">toString</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;yep&quot;</span>    <span class="Comment"># calls the toString(x: bool) proc</span></pre></p>
<p>(注意在 Nim 中，<tt class="docutils literal"><span class="pre"><span class="Identifier">toString</span></span></tt> 经常为 <a class="reference external" href="dollars.html">$</a> 运算符) 编译器选择最合适的过程来处理 <tt class="docutils literal"><span class="pre"><span class="Identifier">toString</span></span></tt> 调用。在此不讨论这种重载解析算法是如何工作的 -- 详情请见手册。 模棱两可的调用被报告为错误。</p>

<h2><a class="toc-backref" id="过程-运算符" href="#过程-运算符">运算符</a></h2><p>Nim 标准库大量使用重载 - 原因之一是每个像 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span></span></tt> 这样的运算符都只是一个重载的过程。 解析器允许你在<em>中缀符号</em> (<tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">b</span></span></tt>) 或 <em>前缀符号</em> (<tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Identifier">a</span></span></tt>) 中使用运算符。 一个中缀运算符通常接收两个参数，一个前缀运算符通常接收一个。 (后缀运算符是不可能的，因为这会模糊语义: <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">@</span> <span class="Operator">@</span> <span class="Identifier">b</span></span></tt> 是指 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt> 还是 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">@</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt>? 这通常指 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">@</span> <span class="Punctuation">(</span><span class="Operator">@</span><span class="Identifier">b</span><span class="Punctuation">)</span></span></tt>，因为在 Nim 中没有后缀运算符。)</p>
<p>除了一些内置的关键字运算符，如 <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">not</span></span></tt>, 运算符总是由这些字符组成: <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Operator">\</span> <span class="Operator">/</span> <span class="Operator">&lt;</span> <span class="Operator">&gt;</span> <span class="Operator">=</span> <span class="Operator">@</span> <span class="Operator">$</span> <span class="Operator">~</span> <span class="Operator">&amp;</span> <span class="Operator">%</span> <span class="Operator">!</span> <span class="Operator">?</span> <span class="Operator">^</span> <span class="Operator">.</span> <span class="Operator">|</span></span></tt></p>
<p>允许使用用户定义的运算符。没有什么能阻止你定义自己的 <tt class="docutils literal"><span class="pre"><span class="Operator">@!?+~</span></span></tt> 运算符， 但这样做可能会降低可读性。</p>
<p>运算符的优先级由其第一个字符确定。详情可以<a class="reference external" href="manual.html#syntax-precedence">在手册中找到</a>。</p>
<p>要定义一个新的运算符，请将运算符括在反引号 &quot;`&quot; 中:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myDataType</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">...</span>
<span class="Comment"># now the $ operator also works with myDataType, overloading resolution</span>
<span class="Comment"># ensures that $ works for built-in types just like before</span></pre></p>
<p>&quot;`&quot; 符号也可以像任何其他过程一样用于调用运算符:</p>
<p><pre class="listing">
<span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="DecNumber">7</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;true&quot;</span></pre></p>

<h2><a class="toc-backref" id="过程-前置声明" href="#过程-前置声明">前置声明</a></h2><p>每个变量、过程等都需要先声明才能使用。(这样做的原因是，在像 Nim 一样广泛支持元编程 的语言中避免这种需求并非易事)但是，对于相互递归的过程不能这样做:</p>
<p><pre class="listing">
<span class="Comment"># forward declaration:</span>
<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre></p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># makes sure we don't run into negative recursion</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span> <span class="Keyword">or</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">even</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">n</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Comment"># makes sure we don't run into negative recursion</span>
  <span class="Keyword">if</span> <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">false</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">n</span> <span class="Operator">==</span> <span class="DecNumber">0</span> <span class="Keyword">or</span> <span class="Identifier">odd</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>
<p>这里的 <tt class="docutils literal"><span class="pre"><span class="Identifier">odd</span></span></tt> 依赖 <tt class="docutils literal"><span class="pre"><span class="Identifier">even</span></span></tt>，反之亦然。因此，在完全定义之前，需要将 <tt class="docutils literal"><span class="pre"><span class="Identifier">even</span></span></tt> 引入编译器。 这种前置声明的语法很简单: 只需省略 <tt class="docutils literal"><span class="pre"><span class="Operator">=</span></span></tt> 和过程的主体。 <tt class="docutils literal"><span class="pre"><span class="Identifier">assert</span></span></tt> 只添加了边界条件， 稍后会在<a class="reference internal" href="#模块">模块</a>部分介绍。</p>
<p>后续版本会弱化对前置声明的要求。</p>
<p>该示例还表明，proc 的主体可以由单个表达式组成，然后隐式返回其值。</p>

<h2><a class="toc-backref" id="过程-funcs-和-方法" href="#过程-funcs-和-方法">Funcs 和 方法</a></h2><p>正如介绍中提到的，Nim 区分过程、函数和方法，后者分别由 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">method</span></span></tt> 关键字定义。 在某些方面，Nim 的定义比其他语言更迂腐。</p>
<p>函数更接近于纯数学函数的概念，如果你曾进行过函数式编程，你可能对它很熟悉。 本质上，它们是设置了额外限制的过程: 它们不能访问全局状态(<tt class="docutils literal"><span class="pre"><span class="Keyword">const</span></span></tt> 除外)且不能产生副作用。 <tt class="docutils literal"><span class="pre"><span class="Keyword">func</span></span></tt> 关键字基本上是用 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">noSideEffects</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 标记的 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 的别名。 然而，函数仍然可以更改它们被标记为 <tt class="docutils literal"><span class="pre"><span class="Keyword">var</span></span></tt> 的可变参数，以及任何 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 对象。</p>
<p>与过程不同，方法是动态分派的。这听起来有点复杂，但它是一个与继承和面向对象编程密切相关的概念。 如果你重载一个过程(两个具有相同名称但类型不同或具有不同参数集的过程称为重载)，则要使用的过程在编译时确定。 另一方面，方法依赖于从 <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt> 继承的对象。 这在<a class="reference external" href="tut2.html#object-orienting-programming-dynamic-dispatch">本教程的第二部分</a> 中有更深入的介绍。</p>

<h1><a class="toc-backref" id="迭代器" href="#迭代器">迭代器</a></h1><p>让我们回到简单的计数示例:</p>
<p><pre class="listing">
<span class="Identifier">echo</span> <span class="StringLit">&quot;Counting to ten: &quot;</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span></pre></p>
<p><a class="reference external" href="system.html#countup.i,T,T,Positive">countup</a> 过程可以写的支持循环吗? 让我们试试:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">return</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre></p>
<p>但是，这不起作用。问题是该过程不应只 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt>，而应该在迭代完成后返回并<strong>继续</strong>。 <em>返回并继续</em>的语句被称为 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt>。现在剩下要做的就是用 <tt class="docutils literal"><span class="pre"><span class="Keyword">iterator</span></span></tt> 替换 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 关键字， 这就是我们的第一个迭代器:</p>
<p><pre class="listing">
<span class="Keyword">iterator</span> <span class="Identifier">countup</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">res</span> <span class="Operator">=</span> <span class="Identifier">a</span>
  <span class="Keyword">while</span> <span class="Identifier">res</span> <span class="Operator">&lt;=</span> <span class="Identifier">b</span><span class="Punctuation">:</span>
    <span class="Keyword">yield</span> <span class="Identifier">res</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">res</span><span class="Punctuation">)</span></pre></p>
<p>迭代器看起来与过程非常相似，但有几个重要区别:</p>
<ul class="simple"><li>迭代器只能在 for 循环中调用。</li>
<li>迭代器不能含有 <tt class="docutils literal"><span class="pre"><span class="Keyword">return</span></span></tt> 语句。(相应的，过程中不能有 <tt class="docutils literal"><span class="pre"><span class="Keyword">yield</span></span></tt> 语句)</li>
<li>迭代器没有隐式的 <tt class="docutils literal"><span class="pre"><span class="Identifier">result</span></span></tt> 变量。</li>
<li>迭代器不支持递归。</li>
<li>迭代器不能前置声明，因为编译器必须能够内联一个迭代器。(这个限制将在未来版本的编译器中移除)</li>
</ul>
<p>但是，你也可以使用闭包迭代器来获得一组不同的限制。 详情请见 <a class="reference external" href=" manual.html#iterators-and-the-for-statement-firstminusclass-iterators">first-class iterators</a>。 迭代器可具有与过程相同的名称和参数，因为本质上它们具有自己的命名空间。因此， 通常将迭代器包装在同名的过程中，这些过程会累积迭代器的结果并将其作为序列返回， 例如 <a class="reference external" href="strutils.html">strutils 模块</a> 中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">split</span></span></tt>。</p>

<h1><a class="toc-backref" id="基本类型" href="#基本类型">基本类型</a></h1><p>本节详细介绍了基本的内置类型及它们的可用操作。</p>

<h2><a class="toc-backref" id="基本类型-布尔" href="#基本类型-布尔">布尔</a></h2><p>Nim 的布尔类型称为 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt>，由两个预定义值 <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">false</span></span></tt> 组成。 <tt class="docutils literal"><span class="pre"><span class="Keyword">while</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt>,<tt class="docutils literal"><span class="pre"><span class="Keyword">elif</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span></span></tt> 语句中的条件必须是布尔类型。</p>
<p>运算符 <tt class="docutils literal"><span class="pre"><span class="Keyword">not</span><span class="Punctuation">,</span> <span class="Keyword">and</span><span class="Punctuation">,</span> <span class="Keyword">or</span><span class="Punctuation">,</span> <span class="Keyword">xor</span><span class="Punctuation">,</span> <span class="Operator">&lt;</span><span class="Punctuation">,</span> <span class="Operator">&lt;=</span><span class="Punctuation">,</span> <span class="Operator">&gt;</span><span class="Punctuation">,</span> <span class="Operator">&gt;=</span><span class="Punctuation">,</span> <span class="Operator">!=</span><span class="Punctuation">,</span> <span class="Operator">==</span></span></tt> 是为 bool 类型定义的。 <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt> 运算符执行短路评估。例如:</p>
<p><pre class="listing">
<span class="Keyword">while</span> <span class="Identifier">p</span> <span class="Operator">!=</span> <span class="Keyword">nil</span> <span class="Keyword">and</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">!=</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># p.name is not evaluated if p == nil</span>
  <span class="Identifier">p</span> <span class="Operator">=</span> <span class="Identifier">p</span><span class="Operator">.</span><span class="Identifier">next</span></pre></p>

<h2><a class="toc-backref" id="基本类型-字符" href="#基本类型-字符">字符</a></h2><p><em>字符类型</em>称为 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt>。它的大小始终为一个字节，因此它不能表示大多数 UTF-8 字符， 但它<em>可以</em>表示 UTF-8 字符中一个组成字节。这样做是为了效率: 对于绝大多数用例， 产生的程序仍将正确处理 UTF-8，因为 UTF-8 是专门为此设计的。字符字面量用单引号括起来。</p>
<p>字符可以用 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&lt;</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&lt;=</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&gt;</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&gt;=</span></span></tt> 运算符进行比较。<tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 运算符将 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> 转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">string</span></span></tt>。字符不能与整数混合; 要获取 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> 的序数值，请使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span></span></tt> 过程。 使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">chr</span></span></tt> 过程完成从整数到 <tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> 的转换。</p>

<h2><a class="toc-backref" id="基本类型-字符串" href="#基本类型-字符串">字符串</a></h2><p>字符串变量是<strong>可变的</strong>，所以追加字符串是可能的，并且相当高效。 字符串在 Nim 中既以零为结尾，也有长度字段。一个字符串的长度可通过内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> 过程来获取; 长度永远不会计算结尾零。对结尾零的访问是个错误，它的存在只是为了 Nim 的字符串能够被零拷贝地 转换成 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt>。</p>
<p>字符串的赋值运算符将复制字符串。你可以使用 <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> 运算符连接字符串或使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">add</span></span></tt> 追加字符串。</p>
<p>字符串使用其字典顺序进行比较。支持所有比较运算符。按照惯例，所有字符串都是 UTF-8 编码的， 但这不是强制的。例如，从二进制文件中读取字符串时，它们只是一个字节序列。 索引操作 <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 表示 <tt class="docutils literal"><span class="pre"><span class="Identifier">s</span></span></tt> 的第 i 个 <em>char</em>，而不是第i个 <em>unichar</em>。</p>
<p>字符串变量被初始化为空字符串 <tt class="docutils literal"><span class="pre"><span class="StringLit">&quot;&quot;</span></span></tt>。</p>

<h2><a class="toc-backref" id="基本类型-整数" href="#基本类型-整数">整数</a></h2><p>Nim 有以下内置的整数类型: <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span> <span class="Identifier">int8</span> <span class="Identifier">int16</span> <span class="Identifier">int32</span> <span class="Identifier">int64</span> <span class="Identifier">uint</span> <span class="Identifier">uint8</span> <span class="Identifier">uint16</span> <span class="Identifier">uint32</span> <span class="Identifier">uint64</span></span></tt>.</p>
<p>默认整数类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt>。整数字面量可以用<em>类型后置</em>来指定非默认的整数类型:</p>
<p><pre class="listing">
<span class="Keyword">let</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">0</span>     <span class="Comment"># x is of type `int`</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="DecNumber">0'i8</span>  <span class="Comment"># y is of type `int8`</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="DecNumber">0'i32</span> <span class="Comment"># z is of type `int32`</span>
  <span class="Identifier">u</span> <span class="Operator">=</span> <span class="DecNumber">0'</span><span class="Identifier">u</span>   <span class="Comment"># u is of type `uint`</span></pre></p>
<p>大多数情况下，整数用于计数驻留在内存中的对象，因此 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 与指针具有相同的大小。</p>
<p>常用运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Keyword">div</span> <span class="Keyword">mod</span> <span class="Operator">&lt;</span> <span class="Operator">&lt;=</span> <span class="Operator">==</span> <span class="Operator">!=</span> <span class="Operator">&gt;</span> <span class="Operator">&gt;=</span></span></tt> 是为整数定义的。 <tt class="docutils literal"><span class="pre"><span class="Keyword">and</span> <span class="Keyword">or</span> <span class="Keyword">xor</span> <span class="Keyword">not</span></span></tt> 运算符也为整数定义并提供<em>按位</em>运算。 左移使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">shl</span></span></tt> 完成，右移使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">shr</span></span></tt> 操作符。 位移位运算符始终将其参数视为 <em>unsigned</em>。 对于<span id="算术位移_1">算术位移</span> 可以使用普通的乘法或除法。</p>
<p>无符号操作都会回绕; 它们不会导致溢出或下溢错误。</p>
<p>无损 <span id="automatic-type-conversion_1">Automatic type conversion</span> 在使用不同类型的整数类型表达式中执行。 然而，如果类型转换会导致信息丢失，则会引发 <span id="rangedefect_1">RangeDefect</span> (前提是在编译时无法检测到错误)。</p>

<h2><a class="toc-backref" id="基本类型-浮点数" href="#基本类型-浮点数">浮点数</a></h2><p>Nim 内置浮点类型: <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span> <span class="Identifier">float32</span> <span class="Identifier">float64</span></span></tt>。</p>
<p>默认的浮点类型是 <tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt>。在当前实现中，<tt class="docutils literal"><span class="pre"><span class="Identifier">float</span></span></tt> 是64位的。</p>
<p>浮点字面值可以有一个<em>类型后缀</em>来指定一个非默认的浮点类型:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="FloatNumber">0.0</span>      <span class="Comment"># x is of type `float`</span>
  <span class="Identifier">y</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f32</span>  <span class="Comment"># y is of type `float32`</span>
  <span class="Identifier">z</span> <span class="Operator">=</span> <span class="FloatNumber">0.0'f64</span>  <span class="Comment"># z is of type `float64`</span></pre></p>
<p>常见的运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">+</span> <span class="Operator">-</span> <span class="Operator">*</span> <span class="Operator">/</span> <span class="Operator">&lt;</span> <span class="Operator">&lt;=</span> <span class="Operator">==</span> <span class="Operator">!=</span> <span class="Operator">&gt;</span> <span class="Operator">&gt;=</span></span></tt> 已为浮点数定义，并遵循 IEEE-754 标准。</p>
<p>在具有不同浮点类型的表达式中将自动执行类型转换: 较小的类型会转换为较大的类型。 整数类型<strong>不会</strong>自动转换为浮点类型，反之亦然。进行这些转换可用 <a class="reference external" href="system.html#toInt,float">toInt</a> 和 <a class="reference external" href="system.html#toFloat,int">toFloat</a> 过程。</p>

<h2><a class="toc-backref" id="基本类型-类型转换" href="#基本类型-类型转换">类型转换</a></h2><p>数值类型之间的转换是通过将类型用作函数来执行的:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int32</span> <span class="Operator">=</span> <span class="FloatNumber">1.</span><span class="Identifier">int32</span>   <span class="Comment"># same as calling int32(1)</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int8</span>  <span class="Operator">=</span> <span class="Identifier">int8</span><span class="Punctuation">(</span><span class="CharLit">'a'</span><span class="Punctuation">)</span> <span class="Comment"># 'a' == 97'i8</span>
  <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span> <span class="FloatNumber">2.5</span>       <span class="Comment"># int(2.5) rounds down to 2</span>
  <span class="Identifier">sum</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">int</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">)</span> <span class="Comment"># sum == 100</span></pre></p>

<h1><a class="toc-backref" id="内部类型表示" href="#内部类型表示">内部类型表示</a></h1><p>如前所述，内置的 <a class="reference external" href="dollars.html">$</a> (stringify) 运算符将任意基本类型转为字符串， 然后你可以使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> 过程将其打印到控制台。但是，除非你为高级类型和你的自定义类型 进行定义，否则后者将不能与 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 运算符一起使用。你可以在只想调试复杂类型的当前值， 而不想编写其 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 运算符时，使用 <a class="reference external" href="system.html#repr,T">repr</a> 过程， 它适用于任何类型，甚至是带有周期的复杂数据图。以下示例表明，即使对于基本类型， <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">repr</span></span></tt> 输出之间也存在差异:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">myBool</span> <span class="Operator">=</span> <span class="Identifier">true</span>
  <span class="Identifier">myCharacter</span> <span class="Operator">=</span> <span class="CharLit">'n'</span>
  <span class="Identifier">myString</span> <span class="Operator">=</span> <span class="StringLit">&quot;nim&quot;</span>
  <span class="Identifier">myInteger</span> <span class="Operator">=</span> <span class="DecNumber">42</span>
  <span class="Identifier">myFloat</span> <span class="Operator">=</span> <span class="FloatNumber">3.14</span>
<span class="Identifier">echo</span> <span class="Identifier">myBool</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myBool</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; true:true</span>
<span class="Identifier">echo</span> <span class="Identifier">myCharacter</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myCharacter</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; n:'n'</span>
<span class="Identifier">echo</span> <span class="Identifier">myString</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myString</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; nim:0x10fa8c050&quot;nim&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">myInteger</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myInteger</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 42:42</span>
<span class="Identifier">echo</span> <span class="Identifier">myFloat</span><span class="Punctuation">,</span> <span class="StringLit">&quot;:&quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">myFloat</span><span class="Punctuation">)</span>
<span class="Comment"># --&gt; 3.14:3.14</span></pre></p>

<h1><a class="toc-backref" id="高阶类型" href="#高阶类型">高阶类型</a></h1><p>在 Nim 中，新的类型可以通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 语句来定义:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">biggestInt</span> <span class="Operator">=</span> <span class="Identifier">int64</span>      <span class="Comment"># biggest integer type that is available</span>
  <span class="Identifier">biggestFloat</span> <span class="Operator">=</span> <span class="Identifier">float64</span>  <span class="Comment"># biggest float type that is available</span></pre></p>
<p>枚举和对象类型只能在 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 语句中定义。</p>

<h2><a class="toc-backref" id="高阶类型-枚举" href="#高阶类型-枚举">枚举</a></h2><p>枚举类型的变量只能分配到其中某种枚举值。这些值是一组有序符号。每个符号在内部映射到一个整数值。 第一个符号在运行时用 0 表示，第二个用 1 表示，以此类推。例如:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">south</span>     <span class="Comment"># `x` is of type `Direction`; its value is `south`</span>
<span class="Identifier">echo</span> <span class="Identifier">x</span>            <span class="Comment"># prints &quot;south&quot;</span></pre></p>
<p>所有比较运算符都可以与枚举类型一起使用。</p>
<p>可以限定枚举的符号以避免歧义: <tt class="docutils literal"><span class="pre"><span class="Identifier">Direction</span><span class="Operator">.</span><span class="Identifier">south</span></span></tt>。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 运算符可以将任何枚举值转换为其名称，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span></span></tt> 过程可以将其转换为其底层整数值。</p>
<p>为了更好地与其他编程语言交互，可以为枚举类型的符号分配一个明确的序数值。 但是，序数值必须升序排列。</p>

<h2><a class="toc-backref" id="高阶类型-序数类型" href="#高阶类型-序数类型">序数类型</a></h2><p>枚举、整数类型、<tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> (以及子范围)称为序数类型。 序数类型有很多特殊操作:</p>
<table border="1" class="docutils"><tr><th>操作</th><th>说明</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">ord</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>返回用于表示 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 值的整数值</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 加一</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 增加 <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>; <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> 是一个整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 减一</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">dec</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 递减 <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt>; <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> 是一个整数</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的后继</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">succ</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的第 <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> 个后继</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">pred</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt></td><td>返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的前任</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">pred</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">)</span></span></tt></td><td>返回 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的第 <tt class="docutils literal"><span class="pre"><span class="Identifier">n</span></span></tt> 个前任</td></tr>
</table><p><a class="reference external" href="system.html#inc,T,int">inc</a>, <a class="reference external" href="system.html#dec,T,int">dec</a>, <a class="reference external" href=" system.html#succ,T,int">succ</a> 以及 <a class="reference external" href="system.html#pred,T,int">pred</a> 运算在引发 <tt class="docutils literal"><span class="pre"><span class="Identifier">RangeDefect</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">OverflowDefect</span></span></tt>. 时会失败。(当代码在恰当的运行时检查 被打开时时编译)</p>

<h2><a class="toc-backref" id="高阶类型-子范围" href="#高阶类型-子范围">子范围</a></h2><p>子范围类型是来自整数或枚举类型(基本类型)的值范围。例:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MySubrange</span> <span class="Operator">=</span> <span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">]</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">MySubrange</span></span></tt> 是 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 的子范围，它只能保存值 0 到 5。 将任何其他值分配给 <tt class="docutils literal"><span class="pre"><span class="Identifier">MySubrange</span></span></tt> 类型的变量是编译时或运行时错误。 允许从基本类型分配到其某一子范围类型(反之亦然)。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">system</span></span></tt> 模块将重要的 <a class="reference external" href="system.html#Natural">Natural</a> 类型定义为 <tt class="docutils literal"><span class="pre"><span class="Identifier">range</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">]</span></span></tt> (<a class="reference external" href="system.html#high,typedesc[T]">high</a> 返回 最大值)。 其他编程语言可能建议对自然数使用无符号整数。这通常是<strong>不明智的</strong>: 你不希望仅仅因为数字不能为负数而用无符号(会产生回绕)运算。Nim 的 <tt class="docutils literal"><span class="pre"><span class="Identifier">Natural</span></span></tt> 类型有助于避免这种常见的编程错误。</p>

<h2><a class="toc-backref" id="高阶类型-集合" href="#高阶类型-集合">集合</a></h2>集合类型是数学概念集合的模型。集合的基础类型只能是具有一定大小的序数类型，即:<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Identifier">int8</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">int16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">uint8</span></span></tt>/<tt class="docutils literal"><span class="pre"><span class="Identifier">byte</span></span></tt>-<tt class="docutils literal"><span class="pre"><span class="Identifier">uint16</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Identifier">char</span></span></tt></li>
<li><tt class="docutils literal"><span class="pre"><span class="Keyword">enum</span></span></tt></li>
</ul>
<p>或等价物。对于有符号的整数，集合的基础类型被定义为 <tt class="docutils literal"><span class="pre"><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">MaxSetElements</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 的范围，其中 <tt class="docutils literal"><span class="pre"><span class="Identifier">MaxSetElements</span></span></tt> 目前总是 2^16 。</p>
<p>原因是集合被实现为高性能的bit vector。 试图用太大类型来声明集合将导致一个错误:</p>
<p><pre class="listing">
  
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">int64</span><span class="Punctuation">]</span> <span class="Comment"># 错误: 集合太大，使用 `std/sets` 处理超过 2^16 元素的序数类型</span>
</pre></p>
<p><strong>注意:</strong> Nim还提供了<a class="reference external" href="set.html">hash sets</a>(你需要用 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">sets</span></span></tt> 导入)，它没有这样的限制。</p>
<p>集合可以通过集合构造器来构造: <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Punctuation">}</span></span></tt> 是空集。空集的类型与任何具体的集合类型兼容。 构造器也可以用来包含元素(和元素范围)。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">CharSet</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">char</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">CharSet</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Operator">..</span><span class="CharLit">'z'</span><span class="Punctuation">,</span> <span class="CharLit">'0'</span><span class="Operator">..</span><span class="CharLit">'9'</span><span class="Punctuation">}</span> <span class="Comment"># 这构建了一个包含从'a' 到 'z' 的字母和从 '0' 到 '9' 的数字的集合。</span></pre></p>
<p>集合支持以下操作。</p>
<table border="1" class="docutils"><tr><th>运算</th><th>含义</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">+</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的并集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">*</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的交集</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">-</span> <span class="Identifier">B</span></span></tt></td><td>两个集合的差集(A不包含B的元素)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">==</span> <span class="Identifier">B</span></span></tt></td><td>集合相等</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;=</span> <span class="Identifier">B</span></span></tt></td><td>子集关系(A是B的子集或等于B)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">&lt;</span> <span class="Identifier">B</span></span></tt></td><td>严格子集关系(A是B的真子集)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">in</span> <span class="Identifier">A</span></span></tt></td><td>集合成员关系(A包含元素e)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">e</span> <span class="Keyword">notin</span> <span class="Identifier">A</span></span></tt></td><td>A不包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">contains</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">e</span><span class="Punctuation">)</span></span></tt></td><td>A包含元素e</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">card</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">)</span></span></tt></td><td>A的基数(A中元素的数量)</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">incl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>相同于 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">+</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">excl</span><span class="Punctuation">(</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">elem</span><span class="Punctuation">)</span></span></tt></td><td>相同于 <tt class="docutils literal"><span class="pre"><span class="Identifier">A</span> <span class="Operator">=</span> <span class="Identifier">A</span> <span class="Operator">-</span> <span class="Punctuation">{</span><span class="Identifier">elem</span><span class="Punctuation">}</span></span></tt></td></tr>
</table>
<h3><a class="toc-backref" id="集合-位域" href="#集合-位域">位域</a></h3><p>集合经常被用来为过程的 <em>标记</em> 定义类型。 这是比定义整数常量更利落的解决方案(而且类型安全)，因为整数常量必须被 <tt class="docutils literal"><span class="pre"><span class="Keyword">or</span></span></tt> &quot;或&quot;在一起。</p>
<p>enum、set和cast可以像下面这样一起使用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyFlag</span><span class="Operator">*</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">size</span><span class="Punctuation">:</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">A</span>
    <span class="Identifier">B</span>
    <span class="Identifier">C</span>
    <span class="Identifier">D</span>
  <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Identifier">set</span><span class="Punctuation">[</span><span class="Identifier">MyFlag</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">cint</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">MyFlags</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">MyFlags</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">0</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">1</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">D</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">8</span>
<span class="Identifier">assert</span> <span class="Identifier">toNum</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">5</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Punctuation">}</span>
<span class="Identifier">assert</span> <span class="Identifier">toFlags</span><span class="Punctuation">(</span><span class="DecNumber">7</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="Punctuation">{</span><span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span><span class="Punctuation">,</span> <span class="Identifier">C</span><span class="Punctuation">}</span></pre></p>
<p>要注意set是怎样将枚举值转换为2的幂值。</p>
<p>如果在C中使用枚举和集合，请使用distinct cint。</p>
<p>关于与C语言的互操作性，参阅<a class="reference external" href="manual.html#implementation-specific-pragmas-bitsize-pragma">bitsize 编译指示</a>。 </p>

<h2><a class="toc-backref" id="高阶类型-数组" href="#高阶类型-数组">数组</a></h2><p>一个数组是一个简单，有固定长度的容器。数组中的每个元素类型相同。 数组的下标可以是任何序数类型。</p>
<p>可使用 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 构造数组:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">..</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>
<p>符号 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 用于访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的第 i 个元素。数组访问总是进行边界检查(在编译时或运行时)。 这些检查可以通过编译指示或使用 <tt class="docutils literal"><span class="pre">--bound_checks:off</span></tt> 命令行开关调用编译器来禁用。</p>
<p>数组是值类型，就像任何其他 Nim 类型一样。赋值运算符将复制整个数组的内容。</p>
<p>内置的 <a class="reference internal" href="#len">len</a> 过程返回数组的长度。<a class="reference internal" href="#low(a)">low(a)</a> 返回数组 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 最小的有效下标，而 <a class="reference internal" href="#high(a)">high(a)</a> 返回最大有效下标。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Direction</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">north</span><span class="Punctuation">,</span> <span class="Identifier">east</span><span class="Punctuation">,</span> <span class="Identifier">south</span><span class="Punctuation">,</span> <span class="Identifier">west</span>
  <span class="Identifier">BlinkLights</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">on</span><span class="Punctuation">,</span> <span class="Identifier">slowBlink</span><span class="Punctuation">,</span> <span class="Identifier">mediumBlink</span><span class="Punctuation">,</span> <span class="Identifier">fastBlink</span>
  <span class="Identifier">LevelSetting</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">level</span><span class="Punctuation">:</span> <span class="Identifier">LevelSetting</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">on</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">south</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">level</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fastBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">level</span>        <span class="Comment"># --&gt; [on, fastBlink, slowBlink, off]</span>
<span class="Identifier">echo</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; north</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>   <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">level</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; west</span></pre></p>
<p>其他语言中创建嵌套(多维)数组的语法是添加更多括号，因为通常每个维度的索引类型都被限制成 与其他维度相同。在 Nim 中，你可以有不同维度和不同的索引类型，因此嵌套语法略有不同。 在上一个示例，level 被定义为一个把另一个枚举当做索引的枚举数组，我们可以添加以下行来 添加一个 LightTower 类型，该类型细分为通过其整数索引访问其高度的 LevelSetting:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">LevelSetting</span><span class="Punctuation">]</span>
<span class="Keyword">var</span>
  <span class="Identifier">tower</span><span class="Punctuation">:</span> <span class="Identifier">LightTower</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">slowBlink</span>
<span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">[</span><span class="Identifier">east</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">mediumBlink</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">)</span>     <span class="Comment"># --&gt; 10</span>
<span class="Identifier">echo</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">tower</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span><span class="Punctuation">)</span>  <span class="Comment"># --&gt; 4</span>
<span class="Identifier">echo</span> <span class="Identifier">tower</span>          <span class="Comment"># --&gt; [[slowBlink, mediumBlink, ...more output..</span>
<span class="Comment"># The following lines don't compile due to type mismatch errors</span>
<span class="Comment">#tower[north][east] = on</span>
<span class="Comment">#tower[0][1] = on</span></pre></p>
<p>注意内置的 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span></span></tt> 过程是如何仅返回数组第一维长度的。定义 <tt class="docutils literal"><span class="pre"><span class="Identifier">LightTower</span></span></tt> 以更好地说明其嵌套性质的另一种方法是省略之前对 <tt class="docutils literal"><span class="pre"><span class="Identifier">LevelSetting</span></span></tt> 类型的定义， 并直接将其嵌入作为第一个维度的类型:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">LightTower</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">1.</span><span class="Operator">.</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="Identifier">north</span><span class="Operator">..</span><span class="Identifier">west</span><span class="Punctuation">,</span> <span class="Identifier">BlinkLights</span><span class="Punctuation">]</span><span class="Punctuation">]</span></pre></p>
<p>数组从零开始是很常见的，因此有一种快捷语法可以指定从零到指定索引减一的范围：</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">IntArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># an array that is indexed with 0..5</span>
  <span class="Identifier">QuickArray</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>  <span class="Comment"># an array that is indexed with 0..5</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">IntArray</span>
  <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">QuickArray</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span>
<span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">x</span>
<span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="Identifier">low</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Operator">..</span> <span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></pre></p>

<h2><a class="toc-backref" id="高阶类型-序列" href="#高阶类型-序列">序列</a></h2><p>序列类似于数组，但其长度是动态的，在运行时可能会发生变化(如字符串)。 由于序列大小可调，它们总是分配在堆上并受垃圾回收。</p>
<p>序列总是用从 0 开始的 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 进行索引。<a class="reference external" href="system.html#len,seq[T]">len</a>, <a class="reference external" href=" system.html#low,openArray[T]">low</a> 和 <a class="reference external" href=" system.html#high,openArray[T]">high</a> 操作也可用于序列。符号 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt> 可用于访问 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 的第 i 个元素。</p>
<p>序列可由数组构造器 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 与数组到序列运算符 <tt class="docutils literal"><span class="pre"><span class="Operator">@</span></span></tt> 一起构造。 为序列分配空间的另一种方法是调用内置的 <a class="reference external" href="system.html#newSeq">newSeq</a> 过程。</p>
<p>序列可被传递给一个开放数组参数。</p>
<p>例:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Comment"># a reference to a sequence of integers</span>
<span class="Identifier">x</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Comment"># the @ turns the array into a sequence allocated on the heap</span></pre></p>
<p>序列变量可用 <tt class="docutils literal"><span class="pre"><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 初始化。</p>
<p>当与序列一起使用时，<tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 语句可以与一个或两个变量一起使用。当你使用单变量形式时， 变量将保存序列提供的值。<tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 语句循环遍历的结果来自 <a class="reference external" href="system.html">system</a> 模块的 <a class="reference external" href="iterators.html#items.i,seq[T]">items()</a> 迭代器。但是如果使用双变量形式， 第一个变量将保存索引位置，第二个变量将保存值。这里的 <tt class="docutils literal"><span class="pre"><span class="Keyword">for</span></span></tt> 语句循环遍历结果来自 <a class="reference external" href="system.html">system</a> 模块的 <a class="reference external" href="iterators.html#pairs.i,seq[T]">pairs()</a> 迭代器。 例子:</p>
<p><pre class="listing">
<span class="Keyword">for</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">value</span>
<span class="Comment"># --&gt; 3</span>
<span class="Comment"># --&gt; 4</span>
<span class="Comment"># --&gt; 5</span>

<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">value</span> <span class="Keyword">in</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">5</span><span class="Punctuation">]</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;index: &quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">i</span><span class="Punctuation">,</span> <span class="StringLit">&quot;, value:&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="Identifier">value</span>
<span class="Comment"># --&gt; index: 0, value:3</span>
<span class="Comment"># --&gt; index: 1, value:4</span>
<span class="Comment"># --&gt; index: 2, value:5</span></pre></p>

<h2><a class="toc-backref" id="高阶类型-开放数组" href="#高阶类型-开放数组">开放数组</a></h2><p><strong>注意</strong>: 开放数组只能被用于参数。</p>
<p>通常，固定大小的数组非常不灵活。程序应该能够处理不同大小的数组。 <span id="openarray_1">openarray</span> 类型允许这样做。 开放数组总是用从位置 0 到 <tt class="docutils literal"><span class="pre"><span class="Identifier">int</span></span></tt> 进行索引。<a class="reference external" href="system.html#len,TOpenArray">len</a>, <a class="reference external" href=" system.html#low,openArray[T]">low</a> 和 <a class="reference external" href="system. html#high,openArray[T]">high</a> 操作也可用于开放数组。 任何具有兼容基类型的数组都可以传递给开放数组参数，索引类型无关紧要。</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">fruits</span><span class="Punctuation">:</span>   <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span>       <span class="Comment"># reference to a sequence of strings that is initialized with '@[]'</span>
  <span class="Identifier">capitals</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span>  <span class="Comment"># array of strings with a fixed size</span>

<span class="Identifier">capitals</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="StringLit">&quot;New York&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;London&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Berlin&quot;</span><span class="Punctuation">]</span>   <span class="Comment"># array 'capitals' allows assignment of only three elements</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Banana&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># sequence 'fruits' is dynamically expandable during runtime</span>
<span class="Identifier">fruits</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="StringLit">&quot;Mango&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">oa</span><span class="Punctuation">:</span> <span class="Identifier">openArray</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">oa</span><span class="Operator">.</span><span class="Identifier">len</span>

<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">fruits</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">2</span>     <span class="Comment"># procedure accepts a sequence as parameter</span>
<span class="Identifier">assert</span> <span class="Identifier">openArraySize</span><span class="Punctuation">(</span><span class="Identifier">capitals</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="DecNumber">3</span>   <span class="Comment"># but also an array type</span></pre></p>
<p>开放数组类型不能嵌套: 不支持多维开放数组，因为这需求很少且不能有效完成。</p>

<h2><a class="toc-backref" id="高阶类型-可变参数" href="#高阶类型-可变参数">可变参数</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Identifier">varargs</span></span></tt> 参数类似于开放数组参数。但它也是一种将可变数量的参数传递给过程的方法。 编译器自动将参数列表转换为数组:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;def&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>仅当 varargs 参数是过程标头中的最后一个参数时才进行此转换。在这种情况下也可执行类型转换:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">s</span> <span class="Keyword">in</span> <span class="Identifier">items</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">s</span><span class="Punctuation">)</span>
  <span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">)</span>

<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="FloatNumber">4.0</span><span class="Punctuation">)</span>
<span class="Comment"># is transformed by the compiler to:</span>
<span class="Identifier">myWriteln</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Punctuation">[</span><span class="Operator">$</span><span class="DecNumber">123</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">,</span> <span class="Operator">$</span><span class="FloatNumber">4.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>在此示例中，<a class="reference external" href="dollars.html">$</a> 将应用于传递给参数 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 的任何参数。请注意，应用于字符串的 <a class="reference external" href="dollars.html">$</a> 是 nop。</p>

<h2><a class="toc-backref" id="高阶类型-切片" href="#高阶类型-切片">切片</a></h2><p>切片在语法上看起来类似子范围类型，但被使用在不同的上下文中。切片只是一个切片类型的对象， 它包含两个边界，<tt class="docutils literal"><span class="pre"><span class="Identifier">a</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt>。切片本身并不是很有用，但其他集合类型定义了接受切片对象来定义范围的运算符。</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">a</span> <span class="Operator">=</span> <span class="StringLit">&quot;Nim is a programming language&quot;</span>
  <span class="Identifier">b</span> <span class="Operator">=</span> <span class="StringLit">&quot;Slices are useless.&quot;</span>

<span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="DecNumber">7</span> <span class="Operator">..</span> <span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Comment"># --&gt; 'a prog'</span>
<span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">b</span> <span class="Comment"># --&gt; 'Slices are useful.'</span></pre></p>
<p>在之前的示例中，切片用于修改字符串的一部分。切片的边界可以保存任何其类型支持的值， 但其实是过程使用了定义了可接受值的切片对象。</p>
<p>要理解指定字符串、数组、序列等索引的不同方法，必须记住 Nim 使用从零开始的索引。</p>
<p>所以字符串 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span></span></tt> 的长度为 19, 指定索引的两种不同方法是</p>
<p><pre class="listing">
<span class="StringLit">&quot;Slices are useless.&quot;</span>
 <span class="Operator">|</span>          <span class="Operator">|</span>     <span class="Operator">|</span>
 <span class="DecNumber">0</span>         <span class="DecNumber">11</span>    <span class="DecNumber">17</span>   <span class="Keyword">using</span> <span class="Identifier">indices</span>
<span class="Operator">^</span><span class="DecNumber">19</span>        <span class="Operator">^</span><span class="DecNumber">8</span>    <span class="Operator">^</span><span class="DecNumber">2</span>   <span class="Keyword">using</span> <span class="Operator">^</span> <span class="Identifier">syntax</span></pre></p>
<p>这里 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span></span></tt> 与 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">]</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span></span></tt> 等价，同时可以看到，<tt class="docutils literal"><span class="pre"><span class="Operator">^</span><span class="DecNumber">1</span></span></tt> 提供了一种表示  <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span></span></tt> 的速记方法。请见<a class="reference external" href="system.html#^.t%2Cint">向后索引运算符</a>。</p>
<p>在上面的例子中，因为字符串以句点结尾，要获取字符串的 &quot;useless&quot; 部分并将其替换为 &quot;useful&quot;。</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span></span></tt> 是 &quot;useless&quot; 部分，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> 用 &quot;useful&quot; 替换了 &quot;useless&quot; 部分，使结果变成 &quot;Slices are useful.&quot;</p>
<p>注 1: 其他的方式为 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">8</span> <span class="Operator">..</span> <span class="Operator">^</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> 或写成 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">11</span> <span class="Operator">..&lt;</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="StringLit">&quot;useful&quot;</span></span></tt>。</p>
<p>注 2: 由于 <tt class="docutils literal"><span class="pre"><span class="Operator">^</span></span></tt> 模板返回类型为 <a class="reference external" href="manual.html#types-distinct-type">distinct int</a> 即 <tt class="docutils literal"><span class="pre"><span class="Identifier">BackwardsIndex</span></span></tt>， 我们可以定义一个 <tt class="docutils literal"><span class="pre"><span class="Identifier">lastIndex</span></span></tt> 常量 <tt class="docutils literal"><span class="pre"><span class="Keyword">const</span> <span class="Identifier">lastIndex</span> <span class="Operator">=</span> <span class="Operator">^</span><span class="DecNumber">1</span></span></tt>，同时在之后使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span><span class="Punctuation">[</span><span class="DecNumber">0</span> <span class="Operator">..</span> <span class="Identifier">lastIndex</span><span class="Punctuation">]</span></span></tt>。</p>

<h2><a class="toc-backref" id="高阶类型-对象" href="#高阶类型-对象">对象</a></h2><p>将不同的值打包到具有名称的单个结构中的类型默认是对象类型。 对象是一种值类型，这意味着当一个对象被分配给一个新变量时，它的所有组件也会被复制。</p>
<p>每个对象类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span></span></tt> 都有一个可以初始化所有字段的构造函数 <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span><span class="Punctuation">(</span><span class="Identifier">field</span><span class="Punctuation">:</span> <span class="Identifier">value</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt>， 未指定的字段将采用其默认值。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">person1</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Keyword">var</span> <span class="Identifier">person2</span> <span class="Operator">=</span> <span class="Identifier">person1</span> <span class="Comment"># copy of person 1</span>

<span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Operator">+=</span> <span class="DecNumber">14</span>

<span class="Identifier">echo</span> <span class="Identifier">person1</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 30</span>
<span class="Identifier">echo</span> <span class="Identifier">person2</span><span class="Operator">.</span><span class="Identifier">age</span> <span class="Comment"># 44</span>


<span class="Comment"># the order may be changed</span>
<span class="Keyword">let</span> <span class="Identifier">person3</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">12</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Quentin&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># not every member needs to be specified</span>
<span class="Keyword">let</span> <span class="Identifier">person4</span> <span class="Operator">=</span> <span class="Identifier">Person</span><span class="Punctuation">(</span><span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">3</span><span class="Punctuation">)</span>
<span class="Comment"># unspecified members will be initialized with their default</span>
<span class="Comment"># values. In this case it is the empty string.</span>
<span class="Identifier">doAssert</span> <span class="Identifier">person4</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Operator">==</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<p>对其定义所处的模块外可见的对象字段必须用 <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt> 标记。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Comment"># the type is visible from other modules</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># the field of this type is visible from other modules</span>
    <span class="Identifier">age</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre></p>

<h2><a class="toc-backref" id="高阶类型-元组" href="#高阶类型-元组">元组</a></h2><p>元组非常类似于你到目前为止从对象中所看到的内容。它们值类型，赋值运算符将拷贝它们的每一个部分。 然而，与对象类型不同的是，元组类型是以结构为类型的，这意味着如果不同的元组类型以相同的顺序指定相同类型和相同名称的字段， 那么它们是<em>等效的</em>。</p>
<p>构造函数 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> 可用于构造元组。构造函数中字段的顺序必须与元组定义中的顺序相匹配。 但与对象不同的是，这里可能不会使用元组类型的名称。</p>
<p>与对象类型一样，符号 <tt class="docutils literal"><span class="pre"><span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">field</span></span></tt> 用于访问元组的字段。 另一个不可用于对象的符号 <tt class="docutils literal"><span class="pre"><span class="Identifier">t</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></span></tt>，可用来访问第 <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> 个字段。 这里 <tt class="docutils literal"><span class="pre"><span class="Identifier">i</span></span></tt> 必须是一个常量整数。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Comment"># type representing a person:</span>
  <span class="Comment"># A person consists of a name and an age.</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">tuple</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  
  <span class="Comment"># Alternative syntax for an equivalent type.</span>
  <span class="Identifier">PersonX</span> <span class="Operator">=</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  
  <span class="Comment"># anonymous field syntax</span>
  <span class="Identifier">PersonY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
  <span class="Identifier">personX</span><span class="Punctuation">:</span> <span class="Identifier">PersonX</span>
  <span class="Identifier">personY</span><span class="Punctuation">:</span> <span class="Identifier">PersonY</span>

<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>
<span class="Comment"># Person and PersonX are equivalent</span>
<span class="Identifier">personX</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># Create a tuple with anonymous fields:</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Comment"># A tuple with anonymous fields is compatible with a tuple that has</span>
<span class="Comment"># field names.</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Identifier">personY</span>
<span class="Identifier">personY</span> <span class="Operator">=</span> <span class="Identifier">person</span>

<span class="Comment"># Usually used for short tuple initialization syntax</span>
<span class="Identifier">person</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Peter&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">30</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">name</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Operator">.</span><span class="Identifier">age</span>  <span class="Comment"># 30</span>

<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Comment"># &quot;Peter&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">person</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span> <span class="Comment"># 30</span>

<span class="Comment"># You don't need to declare tuples in a separate type section.</span>
<span class="Keyword">var</span> <span class="Identifier">building</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">street</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">number</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
<span class="Identifier">building</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="StringLit">&quot;Rue del Percebe&quot;</span><span class="Punctuation">,</span> <span class="DecNumber">13</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">building</span><span class="Operator">.</span><span class="Identifier">street</span>

<span class="Comment"># The following line does not compile, they are different tuples!</span>
<span class="Comment">#person = building</span>
<span class="Comment"># --&gt; Error: type mismatch: got (tuple[street: string, number: int])</span>
<span class="Comment">#     but expected 'Person'</span></pre></p>
<p>虽然你在使用元组时不需要为其声明类型，但使用不同的字段名称创建的元组将被视为不同的对象， 尽管它们的字段具有相同的类型。</p>
<p>元组可以在变量赋值期间<em>解包</em>。 这可以很方便地将元组字段直接分配给单独的具命变量。 这方面的一个例子是 <a class="reference external" href="os.html">os 模块</a> 中的 <a class="reference external" href="os.html#splitFile,string">splitFile</a> 过程， 它同时返回路径的目录、名称和扩展名。为了使元组解包工作，你必须在要分配解包值的周围使用括号， 否则，你将为所有单个变量分配相同的值!例如:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">os</span>

<span class="Keyword">let</span>
  <span class="Identifier">path</span> <span class="Operator">=</span> <span class="StringLit">&quot;usr/local/nimc.html&quot;</span>
  <span class="Punctuation">(</span><span class="Identifier">dir</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">,</span> <span class="Identifier">ext</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
  <span class="Identifier">baddir</span><span class="Punctuation">,</span> <span class="Identifier">badname</span><span class="Punctuation">,</span> <span class="Identifier">badext</span> <span class="Operator">=</span> <span class="Identifier">splitFile</span><span class="Punctuation">(</span><span class="Identifier">path</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">dir</span>      <span class="Comment"># outputs &quot;usr/local&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">name</span>     <span class="Comment"># outputs &quot;nimc&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">ext</span>      <span class="Comment"># outputs &quot;.html&quot;</span>
<span class="Comment"># All the following output the same line:</span>
<span class="Comment"># &quot;(dir: usr/local, name: nimc, ext: .html)&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">baddir</span>
<span class="Identifier">echo</span> <span class="Identifier">badname</span>
<span class="Identifier">echo</span> <span class="Identifier">badext</span></pre></p>
<p>for 循环也支持元组解包:</p>
<p><pre class="listing">
<span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Punctuation">[</span><span class="Punctuation">(</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="CharLit">'a'</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">20</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="DecNumber">30</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">)</span><span class="Punctuation">]</span>

<span class="Keyword">for</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">a</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">x</span>
<span class="Comment"># This will output: 10; 20; 30</span>

<span class="Comment"># Accessing the index is also possible:</span>
<span class="Keyword">for</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">)</span> <span class="Keyword">in</span> <span class="Identifier">a</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">i</span><span class="Punctuation">,</span> <span class="Identifier">c</span>
<span class="Comment"># This will output: 0a; 1b; 2c</span></pre></p>
<p>元组的字段始终是公开的，它们不需要显式标记为导出，这与对象类型中的字段不同。</p>

<h2><a class="toc-backref" id="高阶类型-引用和指针类型" href="#高阶类型-引用和指针类型">引用和指针类型</a></h2><p>引用(类似于其他编程语言中的指针)是一种引入多对一关系的方法。 这意味着不同的引用可以指向和修改内存中的相同位置。</p>
<p>Nim 区分 <span id="traced_1">traced</span> 和 <span id="untraced_1">untraced</span> 引用。未跟踪的引用也称为<em>指针</em>。 跟踪的引用指向会被垃圾收集的堆中的对象，未跟踪的引用指向手动分配的对象或内存中其他地方的对象。 因此，未跟踪的引用是<em>不安全的</em>。但是，对于某些低级操作(如访问硬件)，未跟踪的引用是必要的。</p>
<p>跟踪引用使用 <strong>ref</strong> 关键字声明; 未跟踪的引用使用 <strong>ptr</strong> 关键字声明。</p>
<p>空的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 下标符号可用于<em>解除</em>一个引用，这意味着检索引用指向的实例。 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span></span></tt> (访问元组 / 对象字段)和 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt>(数组 / 字符串 / 序列索引)运算符对引用类型隐式解引用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="DecNumber">9</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
<span class="Comment"># no need to write n[].data; in fact n[].data is highly discouraged!</span></pre></p>
<p>要分配一个新的跟踪对象，可以使用内置过程 <tt class="docutils literal"><span class="pre"><span class="Identifier">new</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">var</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span></pre></p>
<p>可以用 <tt class="docutils literal"><span class="pre"><span class="Identifier">alloc</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">dealloc</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">realloc</span></span></tt> 来处理不跟踪的内存。 <a class="reference external" href="system.html">system</a> 模块中的文档包含更多细节。</p>
<p>如果一个引用<em>什么都没有</em>指向，其值为 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt>。</p>

<h2><a class="toc-backref" id="高阶类型-程序类型" href="#高阶类型-程序类型">程序类型</a></h2><p>过程类型是指向过程的(些许抽象的)指针。过程类型变量的值允许为 <tt class="docutils literal"><span class="pre"><span class="Keyword">nil</span></span></tt>。 Nim 使用过程类型来实现 <span id="functional_1">functional</span> 编程技术。</p>
<p>例:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">greet</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Hello, &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;!&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">bye</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="StringLit">&quot;Goodbye, &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">name</span> <span class="Operator">&amp;</span> <span class="StringLit">&quot;.&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">greeting</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">greeting</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">)</span>

<span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">greet</span><span class="Punctuation">,</span> <span class="StringLit">&quot;John&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">communicate</span><span class="Punctuation">(</span><span class="Identifier">bye</span><span class="Punctuation">,</span> <span class="StringLit">&quot;Mary&quot;</span><span class="Punctuation">)</span></pre></p>
<p>过程类型的一个微妙问题是过程的调用约定会影响类型兼容性: 过程类型只有在它们具有相同的调用约定时才兼容。 <a class="reference external" href="manual.html#types-procedural-type">手册</a> 中列出了不同的调用约定。</p>

<h2><a class="toc-backref" id="高阶类型-distinct-类型" href="#高阶类型-distinct-类型">Distinct 类型</a></h2><p>Distinct 类型允许创建&quot;不隐式与其基本类型之间存在子类型关系&quot;的新类型。 你必须<strong>明确</strong>定义 distinct 类型的所有行为。为减轻这个问题，distinct 类型及其基类型 之间可以相互转换。 <a class="reference external" href="manual.html#types-distinct-type">手册</a> 中提供了示例。</p>

<h1><a class="toc-backref" id="模块" href="#模块">模块</a></h1><p>Nim 支持使用<em>模块</em>概念将程序拆分为多个部分。每个模块都在自己的文件中。 模块启用 <span id="information-hiding_1">information hiding</span> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">separate</span> <span class="Identifier">compilation</span></span></tt>:idx:。 一个模块可以通过使用 <span id="import_1">import</span> 语句来访问另一个模块的符号。 只有标有星号 (<tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>) 的顶级符号会被导出:</p>
<p><pre class="listing">
<span class="Comment"># Module A</span>
<span class="Keyword">var</span>
  <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">`</span> <span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># allocate a new sequence:</span>
  <span class="Identifier">newSeq</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Comment"># multiply two int sequences:</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="DecNumber">0</span> <span class="Operator">..&lt;</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Identifier">b</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Comment"># test the new `*` operator for sequences:</span>
  <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">*</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="DecNumber">9</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre></p>
<p>上面的模块导出了 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">*</span></span></tt>，但没有导出 <tt class="docutils literal"><span class="pre"><span class="Identifier">y</span></span></tt>。</p>
<p>模块的顶级语句在程序开始时执行。例如，这可用于初始化复杂的数据结构。</p>
<p>每个模块都有一个特殊的魔术常量 <tt class="docutils literal"><span class="pre"><span class="Identifier">isMainModule</span></span></tt>，如果该模块被当做主文件编译，则该常量为真。 如上例所示，这对于在模块中嵌入测试非常有用。</p>
<p>模块的符号<em>可以</em>使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">module</span><span class="Operator">.</span><span class="Identifier">symbol</span></span></tt> 语法<em>限定</em>。如果一个符号是模棱两可的， 那它<em>必须</em>合规。当符号在两个(或多个)不同的模块中定义并且这两个模块都由第三个模块导入时， 该符号是模棱两可的:</p>
<p><pre class="listing">
<span class="Comment"># Module A</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">string</span></pre></p>
<p><pre class="listing">
<span class="Comment"># Module B</span>
<span class="Keyword">var</span> <span class="Identifier">x</span><span class="Operator">*:</span> <span class="Identifier">int</span></pre></p>
<p><pre class="listing">
<span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># error: x is ambiguous</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">A</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># okay: qualifier used</span>

<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># not ambiguous: uses the module C's x</span></pre></p>
<p>但这条规则不适用于过程或迭代器。这种情况适用重载规则:</p>
<p><pre class="listing">
<span class="Comment"># Module A</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre></p>
<p><pre class="listing">
<span class="Comment"># Module B</span>
<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Operator">$</span><span class="Identifier">a</span></pre></p>
<p><pre class="listing">
<span class="Comment"># Module C</span>
<span class="Keyword">import</span> <span class="Identifier">A</span><span class="Punctuation">,</span> <span class="Identifier">B</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># no error: A.x is called</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span>  <span class="Comment"># no error: B.x is called</span>

<span class="Keyword">proc</span> <span class="Identifier">x</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdout</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span><span class="Punctuation">)</span>   <span class="Comment"># ambiguous: which `x` is to call?</span></pre></p>

<h2><a class="toc-backref" id="模块-排除符号" href="#模块-排除符号">排除符号</a></h2><p>正常的 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> 语句将引入所有导出的符号。 这些可用 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 标识符点名限制哪个符号应当被排除。</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">mymodule</span> <span class="Keyword">except</span> <span class="Identifier">y</span></pre></p>

<h2><a class="toc-backref" id="模块-from-语句" href="#模块-from-语句">From 语句</a></h2><p>我们已经见识了简单的 <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span></span></tt> 语句，它只导入所有导出的符号。 若仅导入所列符号则可用 <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span> <span class="Keyword">import</span></span></tt> 语句代替:</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Keyword">from</span></span></tt> 语句还可以强制对符号进行命名空间限定，从而使符号经过限定后可用。</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># use x without any qualification</span></pre></p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">mymodule</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>  <span class="Comment"># must qualify x with the module name as prefix</span>

<span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>           <span class="Comment"># using x here without qualification is a compile error</span></pre></p>
<p>通常模块名因方便描述而变得很长，因此你还可以定义一个较短的别名以在限定符号时使用。</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">mymodule</span> <span class="Keyword">as</span> <span class="Identifier">m</span> <span class="Keyword">import</span> <span class="Keyword">nil</span>

<span class="Identifier">m</span><span class="Operator">.</span><span class="Identifier">x</span><span class="Punctuation">(</span><span class="Punctuation">)</span>         <span class="Comment"># m is aliasing mymodule</span></pre></p>

<h2><a class="toc-backref" id="模块-include-语句" href="#模块-include-语句">Include 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 语句做的事情和导入一个模块有着基本的不同: <tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 仅包含进一个文件。 <tt class="docutils literal"><span class="pre"><span class="Keyword">include</span></span></tt> 语句在将一个模块拆分成多个文件时有用:</p>
<p><pre class="listing">
<span class="Keyword">include</span> <span class="Identifier">fileA</span><span class="Punctuation">,</span> <span class="Identifier">fileB</span><span class="Punctuation">,</span> <span class="Identifier">fileC</span></pre></p>

<h1><a class="toc-backref" id="第二部分" href="#第二部分">第二部分</a></h1><p>好了，现在我们完成了基础，让我们看看 Nim 除了为程序化编程提供良好语法外 还提供了什么: <a class="reference external" href="tut2.html">第 II 部分</a></p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2022-10-28 03:56:32 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
