<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim 教程 (第 II 部分)</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<!-- JS -->
<script type="text/javascript" src="dochack.js"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim 教程 (第 II 部分)</h1>
      <div class="row">
  <div class="three columns">
    <div class="theme-select-wrapper">
      <label for="theme-select">Theme:&nbsp;</label>
      <select id="theme-select" onchange="setTheme(this.value)">
        <option value="auto">🌗 Match OS</option>
        <option value="dark">🌑 Dark</option>
        <option value="light">🌕 Light</option>
      </select>
    </div>
    <div id="global-links">
      <ul class="simple">
        <li><a href="theindex.html">Index</a></li>
      </ul>
    </div>
    <div id="searchInputDiv">
      Search: <input type="search" id="searchInput" onkeyup="search()"/>
    </div>
    <div>
      Group by:
      <select onchange="groupBy(this.value)">
        <option value="section">Section</option>
        <option value="type">Type</option>
      </select>
    </div>
    <ul class="simple simple-toc" id="toc-list">
  <li><a class="reference" id="引言_toc" href="#引言">引言</a></li>
<li><a class="reference" id="编译指示_toc" href="#编译指示">编译指示</a></li>
<li><a class="reference" id="面向对象编程_toc" href="#面向对象编程">面向对象编程</a></li>
<ul class="simple"><li><a class="reference" id="面向对象编程-继承_toc" href="#面向对象编程-继承">继承</a></li>
<li><a class="reference" id="面向对象编程-相互递归类型_toc" href="#面向对象编程-相互递归类型">相互递归类型</a></li>
<li><a class="reference" id="面向对象编程-类型转换_toc" href="#面向对象编程-类型转换">类型转换</a></li>
<li><a class="reference" id="面向对象编程-对象变体_toc" href="#面向对象编程-对象变体">对象变体</a></li>
<li><a class="reference" id="面向对象编程-方法调用语法_toc" href="#面向对象编程-方法调用语法">方法调用语法</a></li>
<li><a class="reference" id="面向对象编程-属性_toc" href="#面向对象编程-属性">属性</a></li>
<li><a class="reference" id="面向对象编程-动态分发_toc" href="#面向对象编程-动态分发">动态分发</a></li>
</ul><li><a class="reference" id="异常_toc" href="#异常">异常</a></li>
<ul class="simple"><li><a class="reference" id="异常-raise-语句_toc" href="#异常-raise-语句">Raise 语句</a></li>
<li><a class="reference" id="异常-try-语句_toc" href="#异常-try-语句">Try 语句</a></li>
<li><a class="reference" id="异常-用-raised-exceptions-注解过程_toc" href="#异常-用-raised-exceptions-注解过程">用 raised exceptions 注解过程</a></li>
</ul><li><a class="reference" id="泛型_toc" href="#泛型">泛型</a></li>
<li><a class="reference" id="模板_toc" href="#模板">模板</a></li>
<ul class="simple"><li><a class="reference" id="模板-例colon-提升过程_toc" href="#模板-例colon-提升过程">例: 提升过程</a></li>
</ul><li><a class="reference" id="编译成-javascript_toc" href="#编译成-javascript">编译成 JavaScript</a></li>
<li><a class="reference" id="第-3-部分_toc" href="#第-3-部分">第 3 部分</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
    
    <div id="tocRoot"></div>
    
    <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td>Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td>|nimversion|</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="引言" href="#引言">引言</a></h1><blockquote class="markdown-quote"><p>&quot;Repetition renders the ridiculous reasonable.&quot; -- Norman Wildberger</p></blockquote>
<p>本文档是有关 <em>Nim</em> 编程语言高级部分的教程。<strong>请注意，此文档有些过时，但</strong> <a class="reference external" href="manual.html">手册</a> <strong>中包含更多高级语言功能的示例。</strong></p>

<h1><a class="toc-backref" id="编译指示" href="#编译指示">编译指示</a></h1><p>编译指示是 Nim 为编译器提供额外信息 / 命令而不引入大量新关键字的方法。 编译指示包含在特殊的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 大括号中。本教程不涉及编译指示的内容。 详情请参阅 <a class="reference external" href="manual.html#pragmas">手册</a> 或 <a class="reference external" href=" nimc.html#additional-features">用户指导</a> 以了解可用的编译指示。</p>

<h1><a class="toc-backref" id="面向对象编程" href="#面向对象编程">面向对象编程</a></h1><p>虽然 Nim 对面向对象编程 (OOP) 的支持很简单，但你仍可使用强大的 OOP 技术。 OOP 被视为设计程序的<em>一种</em>方式，而非<em>唯一</em>方式。通常，使用过程能写出更简单有效的代码。 尤其是在设计上，首选组合比继承更好。</p>

<h2><a class="toc-backref" id="面向对象编程-继承" href="#面向对象编程-继承">继承</a></h2><p>Nim 中的继承完全是可选的。要使用继承并启用运行时类型信息，对象需从 <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt> 继承。 这可以通过直接继承或间接地继承继承了 <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt> 的对象来完成。尽管将使用了继承的类型 标记为 <tt class="docutils literal"><span class="pre"><span class="Keyword">ref</span></span></tt> 不是强制的，但这是惯用法。要在运行时检查对象是否属于某种类型，可用 <tt class="docutils literal"><span class="pre"><span class="Keyword">of</span></span></tt> 运算符。</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">name</span><span class="Operator">*:</span> <span class="Identifier">string</span>  <span class="Comment"># the * means that `name` is accessible from other modules</span>
    <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="Identifier">int</span>       <span class="Comment"># no * means that the field is hidden from other modules</span>
  
  <span class="Identifier">Student</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Person</span> <span class="Comment"># Student inherits from Person</span>
    <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="Identifier">int</span>                      <span class="Comment"># with an id field</span>

<span class="Keyword">var</span>
  <span class="Identifier">student</span><span class="Punctuation">:</span> <span class="Identifier">Student</span>
  <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span>
<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">student</span> <span class="Keyword">of</span> <span class="Identifier">Student</span><span class="Punctuation">)</span> <span class="Comment"># is true</span>
<span class="Comment"># object construction:</span>
<span class="Identifier">student</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Anton&quot;</span><span class="Punctuation">,</span> <span class="Identifier">age</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">student</span><span class="Punctuation">[</span><span class="Punctuation">]</span></pre></p>
<p>继承是使用 <tt class="docutils literal"><span class="pre"><span class="Keyword">object</span> <span class="Keyword">of</span></span></tt> 语法完成的。当前不支持多重继承。如果一个对象类型没有合适的父类， 可以选择 <tt class="docutils literal"><span class="pre"><span class="Identifier">RootObj</span></span></tt> 作为它的父类，但这只是一个约定。没有父类的对象被隐式设置为 <tt class="docutils literal"><span class="pre"><span class="Identifier">final</span></span></tt>。 你可用 <tt class="docutils literal"><span class="pre"><span class="Identifier">inheritable</span></span></tt> 编译指示来引入除 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">RootObj</span></span></tt> 之外的新对象根。 (例如，这在 GTK 包装器中使用)</p>
<p>每当使用继承时，都应该使用 Ref 对象。这不是绝对必要的，但是对于非 ref 对象，诸如 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span> <span class="Identifier">person</span><span class="Punctuation">:</span> <span class="Identifier">Person</span> <span class="Operator">=</span> <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">id</span><span class="Punctuation">:</span> <span class="DecNumber">123</span><span class="Punctuation">)</span></span></tt> 之类的赋值将截断子类字段。</p>
<p><strong>注意</strong>: 对于简单的代码重用，组合(<em>has-a</em> 关系)通常优于继承(<em>is-a</em> 关系)。 由于对象在 Nim 中是值类型，因此组合与继承一样高效。</p>

<h2><a class="toc-backref" id="面向对象编程-相互递归类型" href="#面向对象编程-相互递归类型">相互递归类型</a></h2><p>对象、元组和引用可以模拟相互依赖的非常复杂的数据结构; 在一个声明块中声明的类型是<em>相互递归</em>可知的。(其他类型都需要提前声明相应符号，这将减慢编译速度)</p>
<p>例:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>  <span class="Comment"># a reference to an object with the following field:</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>     <span class="Comment"># left and right subtrees</span>
    <span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">Sym</span>     <span class="Comment"># leaves contain a reference to a Sym</span>
  
  <span class="Identifier">Sym</span> <span class="Operator">=</span> <span class="Keyword">object</span>       <span class="Comment"># a symbol</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span>     <span class="Comment"># the symbol's name</span>
    <span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">int</span>        <span class="Comment"># the line the symbol was declared in</span>
    <span class="Identifier">code</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>       <span class="Comment"># the symbol's abstract syntax tree</span></pre></p>

<h2><a class="toc-backref" id="面向对象编程-类型转换" href="#面向对象编程-类型转换">类型转换</a></h2><p>Nim 区分 <span id="type-cast_1">type cast</span> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span> <span class="Identifier">conversions</span></span></tt>:idx:。 <tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span></span></tt> 运算符可用于类型强转，强制编译器将一种类型的位格式强转为另一种类型。</p>
<p>类型转换是将一种类型转换为另一种类型的一种更友好的方式: 它们保留抽象的<em>值</em>， 且不一定按照<em>位模式</em>转换。如果无法进行转换，编译器会报错或引发异常。</p>
<p>类型转换的语法是 <tt class="docutils literal"><span class="pre"><span class="Identifier">destination_type</span><span class="Punctuation">(</span><span class="Identifier">expression_to_convert</span><span class="Punctuation">)</span></span></tt> (类似普通的调用):</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">getID</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Person</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Identifier">Student</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">id</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Identifier">x</span></span></tt> 不是 <tt class="docutils literal"><span class="pre"><span class="Identifier">Student</span></span></tt>，则会引发 <tt class="docutils literal"><span class="pre"><span class="Identifier">InvalidObjectConversionDefect</span></span></tt> 异常。</p>

<h2><a class="toc-backref" id="面向对象编程-对象变体" href="#面向对象编程-对象变体">对象变体</a></h2><p>使用鉴别器来处理简单的对象变体是极其高效的。</p>
<p>例:</p>
<p><pre class="listing">
<span class="Comment"># This is an example how an abstract syntax tree could be modelled in Nim</span>
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span>  <span class="Comment"># the different node types</span>
    <span class="Identifier">nkInt</span><span class="Punctuation">,</span>          <span class="Comment"># a leaf with an integer value</span>
    <span class="Identifier">nkFloat</span><span class="Punctuation">,</span>        <span class="Comment"># a leaf with a float value</span>
    <span class="Identifier">nkString</span><span class="Punctuation">,</span>       <span class="Comment"># a leaf with a string value</span>
    <span class="Identifier">nkAdd</span><span class="Punctuation">,</span>          <span class="Comment"># an addition</span>
    <span class="Identifier">nkSub</span><span class="Punctuation">,</span>          <span class="Comment"># a subtraction</span>
    <span class="Identifier">nkIf</span>            <span class="Comment"># an if statement</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>  <span class="Comment"># the `kind` field is the discriminator</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInt</span><span class="Punctuation">:</span> <span class="Identifier">intVal</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Keyword">of</span> <span class="Identifier">nkFloat</span><span class="Punctuation">:</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="Identifier">float</span>
    <span class="Keyword">of</span> <span class="Identifier">nkString</span><span class="Punctuation">:</span> <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkAdd</span><span class="Punctuation">,</span> <span class="Identifier">nkSub</span><span class="Punctuation">:</span>
      <span class="Identifier">leftOp</span><span class="Punctuation">,</span> <span class="Identifier">rightOp</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Keyword">of</span> <span class="Identifier">nkIf</span><span class="Punctuation">:</span>
      <span class="Identifier">condition</span><span class="Punctuation">,</span> <span class="Identifier">thenPart</span><span class="Punctuation">,</span> <span class="Identifier">elsePart</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>

<span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">Node</span><span class="Punctuation">(</span><span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">nkFloat</span><span class="Punctuation">,</span> <span class="Identifier">floatVal</span><span class="Punctuation">:</span> <span class="FloatNumber">1.0</span><span class="Punctuation">)</span>
<span class="Comment"># the following statement raises an `FieldDefect` exception, because</span>
<span class="Comment"># n.kind's value does not fit:</span>
<span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">strVal</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span></pre></p>
<p>从示例中可以看出，使用鉴别器处理异构对象的一个优点是无需在不同对象类型之间进行转换。 然而，对无效对象字段的访问会引发异常。</p>

<h2><a class="toc-backref" id="面向对象编程-方法调用语法" href="#面向对象编程-方法调用语法">方法调用语法</a></h2><p>调用例程有一个语法糖: 可用 <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">.</span><span class="Identifier">methodName</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span></span></tt> 语法 代替 <tt class="docutils literal"><span class="pre"><span class="Identifier">methodName</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">,</span> <span class="Identifier">args</span><span class="Punctuation">)</span></span></tt>。如果没有其他参数，可省略括号: <tt class="docutils literal"><span class="pre"><span class="Identifier">obj</span><span class="Operator">.</span><span class="Identifier">len</span></span></tt> (而非 <tt class="docutils literal"><span class="pre"><span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">obj</span><span class="Punctuation">)</span></span></tt>)。</p>
<p>这种方法调用语法不限于对象，它可用于任何类型:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span>

<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Comment"># is the same as echo len(&quot;abc&quot;)</span>
<span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span><span class="Operator">.</span><span class="Identifier">toUpperAscii</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span><span class="Punctuation">(</span><span class="Punctuation">{</span><span class="CharLit">'a'</span><span class="Punctuation">,</span> <span class="CharLit">'b'</span><span class="Punctuation">,</span> <span class="CharLit">'c'</span><span class="Punctuation">}</span><span class="Operator">.</span><span class="Identifier">card</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Hallo&quot;</span><span class="Punctuation">)</span> <span class="Comment"># the same as writeLine(stdout, &quot;Hallo&quot;)</span></pre></p>
<p>(从另一个角度来看，方法调用的语法，提供了语义上缺省的后缀)</p>
<p>所以&quot;纯面向对象&quot;的代码很容易编写:</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Punctuation">[</span><span class="Identifier">strutils</span><span class="Punctuation">,</span> <span class="Identifier">sequtils</span><span class="Punctuation">]</span>

<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;Give a list of numbers (separated by spaces): &quot;</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">write</span><span class="Punctuation">(</span><span class="Identifier">stdin</span><span class="Operator">.</span><span class="Identifier">readLine</span><span class="Operator">.</span><span class="Identifier">splitWhitespace</span><span class="Operator">.</span><span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">parseInt</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">max</span><span class="Operator">.</span><span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Punctuation">)</span>
<span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot; is the maximum!&quot;</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="面向对象编程-属性" href="#面向对象编程-属性">属性</a></h2><p>如上例所示，Nim 不需要 <em>get-properties</em>: 使用<em>方法调用语法</em>调用的普通 get-procedures 与前者实现相同。但设置一个值的情况并不是这样; 为此，需要特殊的 setter 语法:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Socket</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
    <span class="Identifier">h</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># cannot be accessed from the outside of the module due to missing star</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Identifier">host</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Socket</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## setter of host address</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">h</span> <span class="Operator">=</span> <span class="Identifier">value</span>

<span class="Keyword">proc</span> <span class="Identifier">host</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment">## getter of host address</span>
  <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">h</span>

<span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">Socket</span>
<span class="Identifier">new</span> <span class="Identifier">s</span>
<span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">host</span> <span class="Operator">=</span> <span class="DecNumber">34</span>  <span class="Comment"># same as `host=`(s, 34)</span></pre></p>
<p>(该示例还显示了 <tt class="docutils literal"><span class="pre"><span class="Identifier">inline</span></span></tt> 过程)</p>
<p>数组访问运算符 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 可被重载以提供 <span id="array-properties_1">array properties</span>:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Vector</span><span class="Operator">*</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">,</span> <span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">float</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">float</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># setter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">v</span><span class="Punctuation">:</span> <span class="Identifier">Vector</span><span class="Punctuation">,</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">float</span> <span class="Operator">=</span>
  <span class="Comment"># getter</span>
  <span class="Keyword">case</span> <span class="Identifier">i</span>
  <span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">x</span>
  <span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">y</span>
  <span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">v</span><span class="Operator">.</span><span class="Identifier">z</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">assert</span><span class="Punctuation">(</span><span class="Identifier">false</span><span class="Punctuation">)</span></pre></p>
<p>这个例子很蠢，因为向量最好由一个提供了 <tt class="docutils literal"><span class="pre"><span class="Identifier">v</span><span class="Punctuation">[</span><span class="Punctuation">]</span></span></tt> 访问方式的元组来构建。</p>

<h2><a class="toc-backref" id="面向对象编程-动态分发" href="#面向对象编程-动态分发">动态分发</a></h2><p>过程总是使用静态分发。对于动态分发，应用 <tt class="docutils literal"><span class="pre"><span class="Keyword">method</span></span></tt> 替换 <tt class="docutils literal"><span class="pre"><span class="Keyword">proc</span></span></tt> 关键字:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Expression</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span> <span class="Comment">## abstract base class for an expression</span>
  <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
  <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Expression</span>
    <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span>

<span class="Comment"># watch out: 'eval' relies on dynamic binding</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">base</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># override this base method</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">x</span>
<span class="Keyword">method</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Literal</span> <span class="Operator">=</span> <span class="Identifier">Literal</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">x</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Expression</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PlusExpr</span> <span class="Operator">=</span> <span class="Identifier">PlusExpr</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">echo</span> <span class="Identifier">eval</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newPlus</span><span class="Punctuation">(</span><span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">newLit</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre></p>
<p>请注意，在示例中，构造函数 <tt class="docutils literal"><span class="pre"><span class="Identifier">newLit</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Identifier">newPlus</span></span></tt> 是过程， 因为它们使用静态绑定更有意义，但 <tt class="docutils literal"><span class="pre"><span class="Identifier">eval</span></span></tt> 是一种方法，因为它需要动态绑定。</p>
<p><strong>注意:</strong> 从 Nim 0.20 开始，要使用 multi-methods，必须在编译时显式传递 <tt class="docutils literal"><span class="pre">--multimethods:on</span></tt>。</p>
<p>在 multi-methods 中，所有具有对象类型的参数都将用于分发:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Thing</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">RootObj</span>
  <span class="Identifier">Unit</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Keyword">of</span> <span class="Identifier">Thing</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">quit</span> <span class="StringLit">&quot;to override!&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;1&quot;</span>

<span class="Keyword">method</span> <span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Thing</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;2&quot;</span>

<span class="Keyword">var</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">Unit</span>
<span class="Identifier">new</span> <span class="Identifier">a</span>
<span class="Identifier">new</span> <span class="Identifier">b</span>
<span class="Identifier">collide</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span> <span class="Comment"># output: 2</span></pre></p>
<p>如示例所示，对 multi-method 的调用不能模棱两可: collide 2 优于 collide 1， 因为解析深度从左到右降低。因此，<tt class="docutils literal"><span class="pre"><span class="Identifier">Unit</span><span class="Punctuation">,</span> <span class="Identifier">Thing</span></span></tt> 优于 <tt class="docutils literal"><span class="pre"><span class="Identifier">Thing</span><span class="Punctuation">,</span> <span class="Identifier">Unit</span></span></tt>。</p>
<p><strong>性能说明</strong>: Nim 不生成虚拟方法表，而是生成调度树。这避免了方法调用昂贵的间接分支并支持内联。 但是，编译时评估以及死代码消除等其他优化将不适用于方法。</p>

<h1><a class="toc-backref" id="异常" href="#异常">异常</a></h1><p>在 Nim 中，异常是对象。按照惯例，异常类型以 'Error' 为后缀。 <a class="reference external" href="system.html">system</a> 模块定义了你可能想要依照的异常层次结构。 异常从提供了公共接口的<tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">Exception</span></span></tt>派生。</p>
<p>异常必须在堆上分配，因为它们的生命周期是未知的。编译器将阻止你引发在栈上创建的异常。 所有引发的异常至少应在 <tt class="docutils literal"><span class="pre"><span class="Identifier">msg</span></span></tt> 字段中指定引发的原因。</p>
<p>异常应在<em>发生异常</em>的情况下引发，它们不应用作控制流的替代方法。</p>

<h2><a class="toc-backref" id="异常-raise-语句" href="#异常-raise-语句">Raise 语句</a></h2><p>引发异常是通过 <tt class="docutils literal"><span class="pre"><span class="Keyword">raise</span></span></tt> 语句完成的:</p>
<p><pre class="listing">
<span class="Keyword">var</span>
  <span class="Identifier">e</span><span class="Punctuation">:</span> <span class="Keyword">ref</span> <span class="Identifier">OSError</span>
<span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span>
<span class="Identifier">e</span><span class="Operator">.</span><span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span>
<span class="Keyword">raise</span> <span class="Identifier">e</span></pre></p>
<p>如果 <tt class="docutils literal"><span class="pre"><span class="Keyword">raise</span></span></tt> 关键字后面没有跟表达式，最后一个异常将被<em>再次引发</em>。 为避免重复这种常见的代码模式，可用 <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span></span></tt> 模块中的模板 <tt class="docutils literal"><span class="pre"><span class="Identifier">newException</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">OSError</span><span class="Punctuation">,</span> <span class="StringLit">&quot;the request to the OS failed&quot;</span><span class="Punctuation">)</span></pre></p>

<h2><a class="toc-backref" id="异常-try-语句" href="#异常-try-语句">Try 语句</a></h2><p><tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 语句处理异常:</p>
<p><pre class="listing">
<span class="Keyword">from</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">strutils</span> <span class="Keyword">import</span> <span class="Identifier">parseInt</span>

<span class="Comment"># read the first two lines of a text file that should contain numbers</span>
<span class="Comment"># and tries to add them</span>
<span class="Keyword">var</span>
  <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
<span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="StringLit">&quot;numbers.txt&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Keyword">let</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">readLine</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;sum: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">except</span> <span class="Identifier">OverflowDefect</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;overflow!&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;could not convert string to integer&quot;</span>
  <span class="Keyword">except</span> <span class="Identifier">IOError</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;IO error!&quot;</span>
  <span class="Keyword">except</span><span class="Punctuation">:</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Unknown exception!&quot;</span>
    <span class="Comment"># reraise the unknown exception:</span>
    <span class="Keyword">raise</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span></pre></p>
<p>除非有异常被引发，否则将执行 <tt class="docutils literal"><span class="pre"><span class="Keyword">try</span></span></tt> 之后的语句。然后执行之后可能达到的 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 部分。</p>
<p>如果存在未明确列出的异常，则执行空的 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 部分。它类似于 <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span></span></tt> 语句中的 <tt class="docutils literal"><span class="pre"><span class="Keyword">else</span></span></tt>。</p>
<p>若有 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 部分，它总是在异常处理之后执行。</p>
<p>异常在 <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 部分被<em>消费</em>。如果异常未被处理，则其通过调用堆栈传播。 这意味着如果发生异常，程序的其余部分——不在 <tt class="docutils literal"><span class="pre"><span class="Keyword">finally</span></span></tt> 子句中——通常不会被执行。</p>
<p>如果你需要<em>访问</em> <tt class="docutils literal"><span class="pre"><span class="Keyword">except</span></span></tt> 分支中的实际异常对象或消息，你可以使用[系统](system.html）模块中的 <a class="reference external" href="system.html#getCurrentException">getCurrentException()</a> 和 <a class="reference external" href=" system.html#getCurrentExceptionMsg">getCurrentExceptionMsg()</a> 过程。例如:</p>
<p><pre class="listing">
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Identifier">doSomethingHere</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">except</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span>
    <span class="Identifier">e</span> <span class="Operator">=</span> <span class="Identifier">getCurrentException</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="Identifier">getCurrentExceptionMsg</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Got exception &quot;</span><span class="Punctuation">,</span> <span class="Identifier">repr</span><span class="Punctuation">(</span><span class="Identifier">e</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot; with message &quot;</span><span class="Punctuation">,</span> <span class="Identifier">msg</span></pre></p>

<h2><a class="toc-backref" id="异常-用-raised-exceptions-注解过程" href="#异常-用-raised-exceptions-注解过程">用 raised exceptions 注解过程</a></h2><p>通过使用可选的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示，你可指定过程旨在引发一组特定的异常，或者根本不引发异常。 如果使用了 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示，编译器将验证这是否为真。例如，如果你指定过程会引发 <tt class="docutils literal"><span class="pre"><span class="Identifier">IOError</span></span></tt>， 并且在某个时候它(或它调用的其中一个过程)开始引发新异常，则编译器将阻止该过程编译。使用示例:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">complexProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">IOError</span><span class="Punctuation">,</span> <span class="Identifier">ArithmeticDefect</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span>

<span class="Keyword">proc</span> <span class="Identifier">simpleProc</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Operator">...</span></pre></p>
<p>一旦你有了这样的代码，如果引发的异常列表发生更改，编译器将停止并显示一个错误，指定停止验证编译指示 的过程行和未捕获的可引发的异常，以及未捕获的已引发异常所在的文件和行，这可帮助你找到已更改的违规代码。</p>
<p>如果你想将 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">raises</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示添加到现有代码中，编译器也可助你一臂之力。 将 <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">effects</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> 编译指示语句添加到你的过程中，编译器将把所有的推断效果输出到该点 (异常跟踪是 Nim effect 系统的一部分)。另一种查找过程引发的异常列表的更为隐晦的方法是使用 Nim <tt class="docutils literal"><span class="pre">doc</span></tt> 命令，该命令为整个模块生成文档，并用异常引发列表装饰所有过程。 你可<a class="reference external" href="manual.html#effect-system">在手册中阅读更多关于 Nim 的 effect 系统和相关编译指示的信息</a>。</p>

<h1><a class="toc-backref" id="泛型" href="#泛型">泛型</a></h1><p>泛型是 Nim 使用 <span id="type-parameters_1">type parameters</span> 参数化过程、迭代器或类型的方法。 泛型参数写在方括号内，例如 <tt class="docutils literal"><span class="pre"><span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt>。它们对高效的类型安全容器最有用:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">BinaryTree</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span> <span class="Comment"># BinaryTree is a generic type with</span>
                              <span class="Comment"># generic param `T`</span>
    <span class="Identifier">le</span><span class="Punctuation">,</span> <span class="Identifier">ri</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>     <span class="Comment"># left and right subtrees; may be nil</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span>                   <span class="Comment"># the data stored in a node</span>

<span class="Keyword">proc</span> <span class="Identifier">newNode</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Comment"># constructor for a node</span>
  <span class="Identifier">new</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># insert a node into the tree</span>
  <span class="Keyword">if</span> <span class="Identifier">root</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">root</span> <span class="Operator">=</span> <span class="Identifier">n</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">root</span>
    <span class="Keyword">while</span> <span class="Identifier">it</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Comment"># compare the data items; uses the generic `cmp` proc</span>
      <span class="Comment"># that works for any type that has a `==` and `&lt;` operator</span>
      <span class="Keyword">var</span> <span class="Identifier">c</span> <span class="Operator">=</span> <span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
      <span class="Keyword">if</span> <span class="Identifier">c</span> <span class="Operator">&lt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">le</span>
      <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Keyword">if</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
          <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span> <span class="Operator">=</span> <span class="Identifier">n</span>
          <span class="Keyword">return</span>
        <span class="Identifier">it</span> <span class="Operator">=</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">ri</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># convenience proc:</span>
  <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">)</span>

<span class="Keyword">iterator</span> <span class="Identifier">preorder</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Comment"># Preorder traversal of a binary tree.</span>
  <span class="Comment"># This uses an explicit stack (which is more efficient than</span>
  <span class="Comment"># a recursive iterator factory).</span>
  <span class="Keyword">var</span> <span class="Identifier">stack</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">var</span> <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">stack</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">while</span> <span class="Identifier">n</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
      <span class="Keyword">yield</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">data</span>
      <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">stack</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">ri</span><span class="Punctuation">)</span>  <span class="Comment"># push right subtree onto the stack</span>
      <span class="Identifier">n</span> <span class="Operator">=</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">le</span>          <span class="Comment"># and follow the left pointer</span>

<span class="Keyword">var</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">BinaryTree</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span> <span class="Comment"># instantiate a BinaryTree with `string`</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="Identifier">newNode</span><span class="Punctuation">(</span><span class="StringLit">&quot;hello&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Comment"># instantiates `newNode` and `add`</span>
<span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span>          <span class="Comment"># instantiates the second `add` proc</span>
<span class="Keyword">for</span> <span class="Identifier">str</span> <span class="Keyword">in</span> <span class="Identifier">preorder</span><span class="Punctuation">(</span><span class="Identifier">root</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Punctuation">)</span></pre></p>
<p>该例展示了一个泛型二叉树。根据上下文，方括号可用于引入类型参数或实例化泛型过程、迭代器或类型。 如示例所示，泛型支持重载: 使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">add</span></span></tt> 的最佳匹配。序列的内置 <tt class="docutils literal"><span class="pre"><span class="Identifier">add</span></span></tt> 过程不是隐藏的， 并且在 <tt class="docutils literal"><span class="pre"><span class="Identifier">preorder</span></span></tt> 迭代器中使用。</p>
<p>在方法调用语法中使用泛型时有一个特殊的 <tt class="docutils literal"><span class="pre"><span class="Punctuation">[</span><span class="Punctuation">:</span><span class="Identifier">T</span><span class="Punctuation">]</span></span></tt> 语法:</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span>

<span class="Keyword">var</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Comment"># i.foo[int]() # Error: expression 'foo(i)' has no type (or is ambiguous)</span>

<span class="Identifier">i</span><span class="Operator">.</span><span class="Identifier">foo</span><span class="Punctuation">[</span><span class="Punctuation">:</span><span class="Identifier">int</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Comment"># Success</span></pre></p>

<h1><a class="toc-backref" id="模板" href="#模板">模板</a></h1><p>模板是一种在 Nim 抽象语法树上执行的简单替换机制。模板在编译器的语义传递中处理。 它们与语言的其余部分很好地集成，且没有 C 的预处理器宏的缺陷。</p>
<p>要<em>调用</em>模板，请像调用过程一样调用它。</p>
<p>例:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Punctuation">`</span><span class="Operator">!=</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span>
  <span class="Comment"># this definition exists in the System module</span>
  <span class="Keyword">not</span> <span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>

<span class="Identifier">assert</span><span class="Punctuation">(</span><span class="DecNumber">5</span> <span class="Operator">!=</span> <span class="DecNumber">6</span><span class="Punctuation">)</span> <span class="Comment"># the compiler rewrites that to: assert(not (5 == 6))</span></pre></p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">!=</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&gt;</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Operator">&gt;=</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">in</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt>、<tt class="docutils literal"><span class="pre"><span class="Keyword">isnot</span></span></tt> 运算符实际上是模板: 这样做的好处是， 如果重载了 <tt class="docutils literal"><span class="pre"><span class="Operator">==</span></span></tt> 运算符，<tt class="docutils literal"><span class="pre"><span class="Operator">!=</span></span></tt> 运算符将自动可用并且正确运作。 (除了 IEEE 浮点数 —— NaN 破坏了基本的布尔逻辑)</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Operator">&gt;</span> <span class="Identifier">b</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">b</span> <span class="Operator">&lt;</span> <span class="Identifier">a</span></span></tt>。 <tt class="docutils literal"><span class="pre"><span class="Identifier">a</span> <span class="Keyword">in</span> <span class="Identifier">b</span></span></tt> 被转换为 <tt class="docutils literal"><span class="pre"><span class="Identifier">contains</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span></span></tt>。 <tt class="docutils literal"><span class="pre"><span class="Keyword">notin</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">isnot</span></span></tt> 语义显然。</p>
<p>模板对于惰性求值特别有用。考虑一个简单处理日志的过程:</p>
<p><pre class="listing">
<span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">proc</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>这段代码有个缺点: 如果哪天将 <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> 设为 false，那么仍会执行相当昂贵的 <tt class="docutils literal"><span class="pre"><span class="Operator">$</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Operator">&amp;</span></span></tt> 操作! (对过程的参数评估总是<em>即刻执行</em>的)。</p>
<p>将 <tt class="docutils literal"><span class="pre"><span class="Identifier">log</span></span></tt> 过程转换为模板可以解决这个问题:</p>
<p><pre class="listing">
<span class="Keyword">const</span>
  <span class="Identifier">debug</span> <span class="Operator">=</span> <span class="Identifier">true</span>

<span class="Keyword">template</span> <span class="Identifier">log</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">debug</span><span class="Punctuation">:</span> <span class="Identifier">stdout</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="Identifier">msg</span><span class="Punctuation">)</span>

<span class="Keyword">var</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="DecNumber">4</span>
<span class="Identifier">log</span><span class="Punctuation">(</span><span class="StringLit">&quot;x has the value: &quot;</span> <span class="Operator">&amp;</span> <span class="Operator">$</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre></p>
<p>参数的类型可以是普通类型或元类型 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">typed</span></span></tt> 或 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt>。 <tt class="docutils literal"><span class="pre"><span class="Keyword">type</span></span></tt> 表示只能将类型符号 作为参数给出，而 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt> 表示在将表达式传递给模板之前不执行符号查找和类型解析。</p>
<p>如果模板没有明确的返回类型，它将使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">void</span></span></tt> 以与过程和方法保持一致。</p>
<p>要将语句块传递给模板，请将最后一个参数设为 <tt class="docutils literal"><span class="pre"><span class="Identifier">untyped</span></span></tt>:</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">,</span> <span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">:</span> <span class="Identifier">FileMode</span><span class="Punctuation">,</span>
                  <span class="Identifier">body</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">fn</span> <span class="Operator">=</span> <span class="Identifier">filename</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">File</span>
  <span class="Keyword">if</span> <span class="Identifier">open</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fn</span><span class="Punctuation">,</span> <span class="Identifier">mode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">try</span><span class="Punctuation">:</span>
      <span class="Identifier">body</span>
    <span class="Keyword">finally</span><span class="Punctuation">:</span>
      <span class="Identifier">close</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;cannot open: &quot;</span> <span class="Operator">&amp;</span> <span class="Identifier">fn</span><span class="Punctuation">)</span>

<span class="Identifier">withFile</span><span class="Punctuation">(</span><span class="Identifier">txt</span><span class="Punctuation">,</span> <span class="StringLit">&quot;ttempl3.txt&quot;</span><span class="Punctuation">,</span> <span class="Identifier">fmWrite</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 1&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">txt</span><span class="Operator">.</span><span class="Identifier">writeLine</span><span class="Punctuation">(</span><span class="StringLit">&quot;line 2&quot;</span><span class="Punctuation">)</span></pre></p>
<p>在这个示例中，有两个 <tt class="docutils literal"><span class="pre"><span class="Identifier">writeLine</span></span></tt> 语句绑定到 <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> 参数。<tt class="docutils literal"><span class="pre"><span class="Identifier">withFile</span></span></tt> 模板包含样板代码， 这有助于避免一个常见的错误: 忘记关闭文件。注意 <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span> <span class="Identifier">fn</span> <span class="Operator">=</span> <span class="Identifier">filename</span></span></tt> 语句是如何确保 <tt class="docutils literal"><span class="pre"><span class="Identifier">filename</span></span></tt> 只评估一次的。</p>

<h2><a class="toc-backref" id="模板-例colon-提升过程" href="#模板-例colon-提升过程">例: 提升过程</a></h2><p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">std</span><span class="Operator">/</span><span class="Identifier">math</span>

<span class="Keyword">template</span> <span class="Identifier">liftScalarProc</span><span class="Punctuation">(</span><span class="Identifier">fname</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment">## Lift a proc taking one scalar parameter and returning a</span>
  <span class="Comment">## scalar value (eg `proc sssss[T](x: T): float`),</span>
  <span class="Comment">## to provide templated procs that can handle a single</span>
  <span class="Comment">## parameter of seq[T] or nested seq[seq[]] or the same type</span>
  <span class="Comment">##</span>
  <span class="Comment">##   ```Nim</span>
  <span class="Comment">##   liftScalarProc(abs)</span>
  <span class="Comment">##   # now abs(@[@[1,-2], @[-2,-3]]) == @[@[1,2], @[2,3]]</span>
  <span class="Comment">##   ```</span>
  <span class="Keyword">proc</span> <span class="Identifier">fname</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">openarray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">auto</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">temp</span><span class="Punctuation">:</span> <span class="Identifier">T</span>
    <span class="Keyword">type</span> <span class="Identifier">outType</span> <span class="Operator">=</span> <span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">fname</span><span class="Punctuation">(</span><span class="Identifier">temp</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">outType</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">)</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
      <span class="Identifier">result</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">fname</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span>

<span class="Identifier">liftScalarProc</span><span class="Punctuation">(</span><span class="Identifier">sqrt</span><span class="Punctuation">)</span>   <span class="Comment"># make sqrt() work for sequences</span>
<span class="Identifier">echo</span> <span class="Identifier">sqrt</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="FloatNumber">4.0</span><span class="Punctuation">,</span> <span class="FloatNumber">16.0</span><span class="Punctuation">,</span> <span class="FloatNumber">25.0</span><span class="Punctuation">,</span> <span class="FloatNumber">36.0</span><span class="Punctuation">]</span><span class="Punctuation">)</span>   <span class="Comment"># =&gt; @[2.0, 4.0, 5.0, 6.0]</span></pre></p>

<h1><a class="toc-backref" id="编译成-javascript" href="#编译成-javascript">编译成 JavaScript</a></h1><p>Nim 代码可编译成 JavaScript。但为了写出与 JavaScript 兼容的代码，你应遵循一下几条:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre"><span class="Keyword">addr</span></span></tt> 和 <tt class="docutils literal"><span class="pre"><span class="Keyword">ptr</span></span></tt> 在 JavaScript 中的语义略有不同。如果你不确定它们是如何转换为 JavaScript 的， 建议你避免使用它们。</li>
<li>JavaScript 中的 <tt class="docutils literal"><span class="pre"><span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt> 被翻译为 <tt class="docutils literal"><span class="pre"><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></span></tt>，除了有符号 / 无符号整数之间的转换。在这种情况下， 它的行为类似于 C 语言中的静态转换。</li>
<li>JavaScript 中的 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 表示 JavaScript 字符串。一种好的做法是在仅在语义合适时才使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 例如，不要使用 <tt class="docutils literal"><span class="pre"><span class="Identifier">cstring</span></span></tt> 作为二进制数据缓冲区。</li>
</ul>

<h1><a class="toc-backref" id="第-3-部分" href="#第-3-部分">第 3 部分</a></h1><p>下部分将用整章讲述基于宏的元编程: <a class="reference external" href="tut3.html">第 III 部分</a>. </p>
</p>
    
  </div>
</div>

      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2022-10-28 03:57:27 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
